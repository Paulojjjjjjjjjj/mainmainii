local function fancyNotify(step, total)
    local percentage = math.floor((step / total) * 100)
    local barLength = 20
    local filledLength = math.floor((step / total) * barLength)
    local bar = string.rep("‚ñà", filledLength) .. string.rep("‚ñë", barLength - filledLength)

    game.StarterGui:SetCore("SendNotification", {
        Title = "‚öîÔ∏è DZHUB ‚öîÔ∏è",
        Text = "üîÑ Loading... " .. percentage .. "%\n[" .. bar .. "]",
        Duration = 1
    })
end

-- Loading animation
task.spawn(function()
    local totalSteps = 15
    for i = 1, totalSteps do
        fancyNotify(i, totalSteps)
        task.wait(0.1)
    end

    -- Final notification
    game.StarterGui:SetCore("SendNotification", {
        Title = "‚úÖ DZHUB",
        Text = "Loading completed!",
        Duration = 2
    })
end)
task.wait(4)

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

--// Janela principal
local Window = Fluent:CreateWindow({
    Title = "Bubble Gum Simulator INFINITY | DZHUB",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl
})

--// Abas
local Tabs = {
    Main = Window:AddTab({ 
        Title = "Main", 
        Icon = "rbxassetid://14456045412" -- √çcone de casa
    }),
    EggHunt = Window:AddTab({ 
        Title = "Egg / Hunt", 
        Icon = "rbxassetid://119629336187267" -- √çcone de ovo
    }),
    Upgrades = Window:AddTab({ 
        Title = "Upgrades", 
        Icon = "rbxassetid://97136202386756" -- √çcone de seta para cima
    }),
    Potions = Window:AddTab({ 
        Title = "Potions", 
        Icon = "rbxassetid://109178225112633" -- √çcone de frasco
    }),
    Teleport = Window:AddTab({ 
        Title = "Teleport", 
        Icon = "rbxassetid://12689978575" -- √çcone de teletransporte
    }),
    Misc = Window:AddTab({ 
        Title = "Misc", 
        Icon = "rbxassetid://90998363974520" -- √çcone de engrenagem
    }),
    Settings = Window:AddTab({ 
        Title = "Settings", 
        Icon = "rbxassetid://96957318452720" -- √çcone de configura√ß√µes
    })
}

--// Vari√°veis globais
local AutoBlow = false
local AutoSell = false
local AutoHatch = false
local SelectedEgg = "Iceshard Egg"
local HatchAmount = 1

--// ======= [MAIN TAB SECTIONS] =======

local BlowSection = Tabs.Main:AddSection("Bubble Automation")
local CollectSection = Tabs.Main:AddSection("Auto Collect")
local UtilitiesSection = Tabs.Main:AddSection("Utilities")
local Egg = Tabs.EggHunt:AddSection("Egg")
local EggRift = Tabs.EggHunt:AddSection("Egg Rift")
local ChestHunt = Tabs.EggHunt:AddSection("Chest Hunt")
local GiftHunt = Tabs.EggHunt:AddSection("Gift Hunt")
local AutoPotionSection = Tabs.Potions:AddSection("Auto Use Potion")
local AutoCraftPotionSection = Tabs.Potions:AddSection("Auto Craft Potion")
local TeleportSection = Tabs.Teleport:AddSection("Unlock All Islands")
local CodeSection = Tabs.Misc:AddSection("Codes") 

--// Auto Blow
BlowSection:AddToggle("AutoBlow", {
    Title = "Auto Blow",
    Description = "Automatically blows the bubble",
    Default = false,
    Callback = function(state)
        AutoBlow = state
        task.spawn(function()
            while AutoBlow do
                pcall(function()
                    game:GetService("ReplicatedStorage")
                        .Shared.Framework.Network.Remote.Event
                        :FireServer("BlowBubble")
                end)
                task.wait(0.1)
            end
        end)
    end
})

--// Auto Sell
BlowSection:AddToggle("AutoSell", {
    Title = "Auto Sell",
    Description = "Sell the bubble automatically",
    Default = false,
    Callback = function(state)
        AutoSell = state
        task.spawn(function()
            while AutoSell do
                pcall(function()
                    game:GetService("ReplicatedStorage")
                        .Shared.Framework.Network.Remote.Event
                        :FireServer("SellBubble")
                end)
                task.wait(0.1)
            end
        end)
    end
})

local AutoCollect = false

CollectSection:AddToggle("AutoCollectToggle", {
    Title = "Auto Collect Coins/Gems/Crates",
    Description = "Automatically collect Coins/Gems/Crates",
    Default = false,
    Callback = function(state)
        AutoCollect = state
        
        if state then
            task.spawn(function()
                local pickupRemote = game:GetService("ReplicatedStorage"):WaitForChild("Remotes")
                                      :WaitForChild("Pickups"):WaitForChild("CollectPickup")
                
                while AutoCollect and task.wait(0.1) do
                    pcall(function()
                        local rendered = workspace:FindFirstChild("Rendered")
                        if rendered then
                            for _, folder in ipairs(rendered:GetChildren()) do
                                if folder.Name == "Chunker" then
                                    for _, model in ipairs(folder:GetChildren()) do
                                        if model:IsA("Model") then
                                            -- Coleta o pickup
                                            pickupRemote:FireServer(model.Name)
                                            -- Destroi o modelo ap√≥s coletar
                                            model:Destroy()
                                        end
                                    end
                                end
                            end
                        end
                    end)
                end
            end)
            Fluent:Notify({
                Title = "Auto Collect Enabled",
                Content = "Collecting and destroying pickups automatically",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Auto Collect Disabled",
                Content = "Auto Collect Off",
                Duration = 3
            })
        end
    end
})

CollectSection:AddToggle("AutoClaimChests", {
    Title = "Auto Claim Chests",
    Description = "Teleports and calls Giant and Void Chest in a loop",
    Default = false,
    Callback = function(state)
        getgenv().AutoClaimChests = state

        if state then
            spawn(function()
                local TweenService = game:GetService("TweenService")
                local Players = game:GetService("Players")
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local LocalPlayer = Players.LocalPlayer
                local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local HRP = Character:WaitForChild("HumanoidRootPart")

                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                local chestData = {
                    ["Void Chest"] = Vector3.new(76.66033172607422, 10148.2060546875, 52.507083892822266),
                    ["Giant Chest"] = Vector3.new(13.179579734802246, 427.93109130859375, 158.93988037109375)
                }

                local function tweenToPosition(pos, duration)
                    return TweenService:Create(HRP, TweenInfo.new(duration, Enum.EasingStyle.Linear), {
                        CFrame = CFrame.new(pos)
                    })
                end

                while getgenv().AutoClaimChests do
                    for chestName, position in pairs(chestData) do
                        local tween = tweenToPosition(position, 4)
                        tween:Play()
                        tween.Completed:Wait(0.3) -- espera terminar o movimento
                        task.wait(1)

                        -- Clama o ba√∫
                        RemoteEvent:FireServer("ClaimChest", chestName)
                        task.wait(0.1)
                    end
                    task.wait(1)
                end
            end)
        end
    end
})


CollectSection:AddToggle("AutoGiftGrabber", {
    Title = "Auto Collect Gift",
    Description = "Use gift, give claim",
    Default = false,
    Callback = function(state)
        getgenv().AutoGiftGrabber = state

        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network")
                local RemoteEvent = Network:WaitForChild("Remote"):WaitForChild("Event")
                local RenderedGifts = workspace:WaitForChild("Rendered"):WaitForChild("Gifts")

                while AutoGiftGrabber do
                    -- 1. Usa o gift
                    RemoteEvent:FireServer("UseGift", "Mystery Box", 1)

                    -- 2. Detecta e faz claim do gift
                    local giftPart = nil
                    local startTime = os.clock()

                    repeat
                        for _, obj in pairs(RenderedGifts:GetChildren()) do
                            if obj:IsA("BasePart") then
                                giftPart = obj
                                break
                            end
                        end
                        task.wait(0.3)
                    until giftPart or (os.clock() - startTime > 10) or not AutoGiftGrabber

                    -- 3. Processo de claim + destrui√ß√£o
                    if giftPart and AutoGiftGrabber then
                        -- Faz o claim
                        RemoteEvent:FireServer("ClaimGift", giftPart.Name)
                        
                        -- Destr√≥i a part ap√≥s 0.5 segundos (garantir que o server processou)
                        task.wait(0.3)
                        if giftPart.Parent then -- Verifica se ainda existe
                            giftPart:Destroy()
                        end
                    end

                    -- 4. Cooldown
                    task.wait(0.3)
                end
            end)
        end
    end
})

CollectSection:AddToggle("AutoClaimPlaytime", {
    Title = "Auto Claim Playtime Rewards",
    Description = "Automatically claims playtime rewards (1 to 9)",
    Default = false,
    Callback = function(state)
        AutoClaimPlaytime = state

        task.spawn(function()
            while AutoClaimPlaytime do
                for i = 1, 9 do
                    pcall(function()
                        local args = {
                            [1] = "ClaimPlaytime",
                            [2] = i
                        }

                        game:GetService("ReplicatedStorage")
                            :WaitForChild("Shared")
                            :WaitForChild("Framework")
                            :WaitForChild("Network")
                            :WaitForChild("Remote")
                            :WaitForChild("Function")
                            :InvokeServer(unpack(args))
                    end)
                end

                task.wait(1) -- Espera 5 segundos antes de repetir tudo
            end
        end)
    end
})

local equipBestRunning = false -- Vari√°vel de controle GLOBAL

UtilitiesSection:AddToggle("EquipBestToggle", {
    Title = "Auto Equip Best Pets",
    Description = "Automatically equips the best pets",
    Default = false,
    Callback = function(state)
        equipBestRunning = state
        
        if state then
            task.spawn(function()
                local remote = game:GetService("ReplicatedStorage")
                    :WaitForChild("Shared")
                    :WaitForChild("Framework")
                    :WaitForChild("Network")
                    :WaitForChild("Remote")
                    :WaitForChild("Event")
                
                while equipBestRunning do
                    local args = {[1] = "EquipBestPets"}
                    remote:FireServer(unpack(args))
                    task.wait(2) -- Espera 2 segundos
                end
            end)
            
            Fluent:Notify({
                Title = "Auto Equip Ativado",
                Content = "Equipping better pets automatically",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Auto Equip Desativado",
                Content = "Stopped equipping pets automatically",
                Duration = 3
            })
        end
    end
})

UtilitiesSection:AddToggle("AutoStartGenieQuest", {
    Title = "Auto Start Genie Quest",
    Description = "Automatically starts random Genius quests",
    Default = false,
    Callback = function(state)
        getgenv().AutoGenieQuest = state

        if state then
            task.spawn(function()
                local RemoteEvent = game:GetService("ReplicatedStorage")
                    :WaitForChild("Shared")
                    :WaitForChild("Framework")
                    :WaitForChild("Network")
                    :WaitForChild("Remote")
                    :WaitForChild("Event")

                while getgenv().AutoGenieQuest do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("StartGenieQuest", i)
                        task.wait(0.5)
                    end
                    task.wait(1)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoBuyAlienShop", {
    Title = "Auto Buy Alien Shop Items",
    Description = "Automatically buys items from alien-shop",
    Default = false,
    Callback = function(state)
        getgenv().AutoBuyAlienShop = state

        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework")
                    :WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

                while AutoBuyAlienShop do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("BuyShopItem", "alien-shop", i)
                        task.wait(0.5) -- pequeno delay entre compras
                    end

                    task.wait(0.5) -- espera 3s antes de comprar novamente
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoBuyShardShop", {
    Title = "Auto Buy Black Market Shop Items",
    Description = "Automatically buys items from shard shop",
    Default = false,
    Callback = function(state)
        getgenv().AutoBuyShardShop = state

        if state then
            task.spawn(function()
                local RemoteEvent = game:GetService("ReplicatedStorage")
                    :WaitForChild("Shared")
                    :WaitForChild("Framework")
                    :WaitForChild("Network")
                    :WaitForChild("Remote")
                    :WaitForChild("Event")

                while getgenv().AutoBuyShardShop do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("BuyShopItem", "shard-shop", i)
                        task.wait(0.5)
                    end
                    task.wait(5)
                end
            end)
        end
    end
})


UtilitiesSection:AddToggle("AutoDoggyJumpWin", {
    Title = "Auto Win Doggy",
    Description = "Simulates victory in the Doggy Jump minigame (Rewards 1 to 3)",
    Default = false,
    Callback = function(state)
        getgenv().AutoDoggyJumpWin = state

        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework")
                    :WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

                while AutoDoggyJumpWin do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("DoggyJumpWin", i)
                        task.wait(0.5)
                    end
                    task.wait(1) -- espera 3s antes de repetir
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoWheelSpin", {
    Title = "Auto Wheel Spin",
    Description = "Automatically spins both roulette wheels (free and paid)",
    Default = false,
    Callback = function(state)
        getgenv().AutoWheelSpin = state

        if state then
            task.spawn(function()
                local Event = game:GetService("ReplicatedStorage"):WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")
                
                local Function = game:GetService("ReplicatedStorage"):WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Function")

                while getgenv().AutoWheelSpin do
                    -- Roleta gr√°tis
                    pcall(function()
                        Event:FireServer("ClaimFreeWheelSpin")
                    end)
                    
                    -- Roleta paga
                    pcall(function()
                        Function:InvokeServer("WheelSpin")
                    end)
                    
                    task.wait(1) -- Espera exatamente 1 segundo
                end
            end)
        end
    end
})

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local SelectedEgg = "Common Egg"
local HatchAmount = 1
local AutoHatch = false

-- Posi√ß√µes dos ovos
local EggPositions = {
    ["Common Egg"] = Vector3.new(-83.11856079101562, 9.816669464111328, 2.463975429534912),
    ["Spotted Egg"] = Vector3.new(-94.04642486572266, 9.816669464111328, 8.982151985168457),
    ["Iceshard Egg"] = Vector3.new(-117.86749267578125, 9.816670417785645, 8.478747367858887),
    ["Spikey Egg"] = Vector3.new(-127.3304672241211, 9.926098823547363, 6.771097183227539),
    ["Magma Egg"] = Vector3.new(-134.0933837890625, 9.816493034362793, 0.9699831008911133),
    ["Crystal Egg"] = Vector3.new(-140.66168212890625, 9.816670417785645, -6.721883296966553),
    ["Lunar Egg"] = Vector3.new(-144.31298828125, 9.81663990020752, -16.05261993408203),
    ["Void Egg"] = Vector3.new(-146.59307861328125, 9.816607475280762, -26.15677833557129),
    ["Hell Egg"] = Vector3.new(-144.9036865234375, 9.816670417785645, -36.547821044921875),
    ["Nightmare Egg"] = Vector3.new(-142.51422119140625, 9.816670417785645, -45.37887954711914),
    ["Rainbow Egg"] = Vector3.new(-137.2113494873047, 9.816374778747559, -53.9847297668457),
    ["Infinity Egg"] = Vector3.new(-98.00410461425781, 8.299989700317383, -27.44309425354004)
}

-- Dropdown para sele√ß√£o do ovo
Egg:AddDropdown("EggDropdown", {
    Title = "Selecting Egg",
    Description = "Choose the egg you want to open",
    Values = {
        "Common Egg", "Spotted Egg", "Iceshard Egg", "Spikey Egg", "Magma Egg",
        "Crystal Egg", "Lunar Egg", "Void Egg", "Hell Egg", "Nightmare Egg",
        "Rainbow Egg", "Infinity Egg"
    },
    Multi = false,
    Default = 1,
    Callback = function(value)
        SelectedEgg = value
    end
})

-- Dropdown para quantidade de ovos
Egg:AddDropdown("HatchAmountDropdown", {
    Title = "Quantity of Eggs",
    Description = "Choose how many eggs to open at a time",
    Values = { "1", "3" },
    Multi = false,
    Default = 1,
    Callback = function(value)
        HatchAmount = tonumber(value)
    end
})

-- Toggle para Auto Hatch com teleporte e noclip
Egg:AddToggle("AutoHatch", {
    Title = "Auto Hatch",
    Description = "Automatically opens eggs with teleport",
    Default = false,
    Callback = function(state)
        AutoHatch = state

        if state then
            local Noclip = false
            local noclipConnection

            local function EnableNoclip()
                Noclip = true
                noclipConnection = RunService.Stepped:Connect(function()
                    if Noclip and LocalPlayer.Character then
                        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                            if part:IsA("BasePart") and part.CanCollide then
                                part.CanCollide = false
                            end
                        end
                    end
                end)
            end

            local function DisableNoclip()
                Noclip = false
                if noclipConnection then
                    noclipConnection:Disconnect()
                    noclipConnection = nil
                end
            end

            -- Teleporte antes de iniciar o loop de hatch
            local function teleportToEgg()
                local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
                local target = EggPositions[SelectedEgg]
                if target and HumanoidRootPart then
                    EnableNoclip()
                    local tween = TweenService:Create(
                        HumanoidRootPart,
                        TweenInfo.new(6, Enum.EasingStyle.Linear),
                        { CFrame = CFrame.new(target + Vector3.new(0, 3, 0)) }
                    )
                    tween:Play()
                    tween.Completed:Wait()
                    DisableNoclip()
                end
            end

            teleportToEgg()

            -- Loop de Auto Hatch
            task.spawn(function()
                while AutoHatch do
                    pcall(function()
                        game:GetService("ReplicatedStorage")
                            .Shared.Framework.Network.Remote.Event
                            :FireServer("HatchEgg", SelectedEgg, HatchAmount)
                    end)
                    task.wait(0.5)
                end
            end)
        end
    end
})

-- Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Rifts = workspace:WaitForChild("Rendered"):WaitForChild("Rifts")

-- Variables
local AutoRiftHatch = false
local SelectedRiftEggs = {}
local SelectedLuckMultipliers = {}
local ActiveTweens = {}
local CurrentTargetEgg = nil
local CurrentTargetMultiplier = nil
local NoClipEnabled = false
local NoClipConnection = nil

-- Egg Name Mapping
local EggNameMap = {
    ["spotted-egg"] = "Spotted Egg",
    ["iceshard-egg"] = "Iceshard Egg",
    ["spikey-egg"] = "Spikey Egg",
    ["magma-egg"] = "Magma Egg",
    ["crystal-egg"] = "Crystal Egg",
    ["lunar-egg"] = "Lunar Egg",
    ["void-egg"] = "Void Egg",
    ["hell-egg"] = "Hell Egg",
    ["nightmare-egg"] = "Nightmare Egg",
    ["rainbow-egg"] = "Rainbow Egg",
    ["infinity-egg"] = "Infinity Egg"
}

-- RemoteEvent
local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

-- Dropdown Egg Names
local RiftEggNames = {}
for k in pairs(EggNameMap) do
    table.insert(RiftEggNames, k)
end

local RiftEggDropdown = EggRift:AddDropdown("RiftEggDropdown", {
    Title = "Select Rift Eggs",
    Description = "Choose which eggs to hatch",
    Values = RiftEggNames,
    Multi = true,
    Default = {},
})

RiftEggDropdown:OnChanged(function(selectedTable)
    SelectedRiftEggs = {}
    for eggName, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedRiftEggs, eggName)
        end
    end
    Fluent:Notify({
        Title = "Egg Selection",
        Content = #SelectedRiftEggs > 0 and ("Selected: " .. table.concat(SelectedRiftEggs, ", ")) or "No eggs selected (will use all)",
        Duration = 3
    })
end)

local LuckMultiplierDropdown = EggRift:AddDropdown("LuckMultiplierDropdown", {
    Title = "Luck Multiplier",
    Description = "Select desired luck multipliers",
    Values = { "x5", "x7", "x10", "x25" },
    Multi = true,
    Default = {},
})

LuckMultiplierDropdown:OnChanged(function(selectedTable)
    SelectedLuckMultipliers = {}
    for multiplier, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedLuckMultipliers, multiplier)
        end
    end
    Fluent:Notify({
        Title = "Multiplier Selection",
        Content = #SelectedLuckMultipliers > 0 and ("Selected: " .. table.concat(SelectedLuckMultipliers, ", ")) or "No multipliers selected (will use all)",
        Duration = 3
    })
end)

-- NoClip Functionality
local function enableNoClip()
    if NoClipConnection then return end
    
    NoClipConnection = RunService.Stepped:Connect(function()
        if LocalPlayer.Character then
            for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function disableNoClip()
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    
    if LocalPlayer.Character then
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- Utility Functions
local function teleportToEgg(egg)
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    -- Cancel any existing tween
    if ActiveTweens[hrp] then 
        ActiveTweens[hrp]:Cancel() 
    end
    
    -- Enable NoClip during teleport
    enableNoClip()
    
    local targetCFrame = CFrame.new(egg:GetPivot().Position + Vector3.new(0, 3, 0))
    local tween = TweenService:Create(hrp, TweenInfo.new(6, Enum.EasingStyle.Linear), {CFrame = targetCFrame})
    ActiveTweens[hrp] = tween
    
    tween:Play()
    local success = pcall(function() 
        tween.Completed:Wait()
        -- Keep NoClip enabled during hatching
    end)
    
    ActiveTweens[hrp] = nil
    return success
end

local function hatchEgg(eggName)
    local args = {
        [1] = "HatchEgg",
        [2] = EggNameMap[eggName],
        [3] = 1
    }
    pcall(function()
        RemoteEvent:FireServer(unpack(args))
    end)
end

local function cancelAllOperations()
    for hrp, tween in pairs(ActiveTweens) do
        if tween then tween:Cancel() end
    end
    ActiveTweens = {}
    disableNoClip()
end

local function chooseNewTarget()
    if #SelectedRiftEggs > 0 then
        CurrentTargetEgg = SelectedRiftEggs[math.random(1, #SelectedRiftEggs)]
    else
        local eggs = {}
        for k in pairs(EggNameMap) do table.insert(eggs, k) end
        CurrentTargetEgg = eggs[math.random(1, #eggs)]
    end

    if #SelectedLuckMultipliers > 0 then
        CurrentTargetMultiplier = SelectedLuckMultipliers[math.random(1, #SelectedLuckMultipliers)]
    else
        CurrentTargetMultiplier = nil -- accept any multiplier
    end
end

-- Main Toggle
EggRift:AddToggle("AutoRiftHatchToggle", {
    Title = "Auto Hatch (Rift)",
    Description = "Automatically teleport and hatch rift eggs (with NoClip)",
    Default = false,
    Callback = function(state)
        AutoRiftHatch = state
        if state then
            chooseNewTarget()
            Fluent:Notify({ 
                Title = "Auto Hatch", 
                Content = "Started auto hatching with NoClip", 
                Duration = 3 
            })

            task.spawn(function()
                while AutoRiftHatch do
                    local found = false
                    for _, egg in pairs(Rifts:GetChildren()) do
                        if not AutoRiftHatch then break end
                        if egg:IsA("Model") and egg:FindFirstChild("Display") and egg.Name == CurrentTargetEgg then
                            local display = egg.Display
                            local gui = display:FindFirstChildWhichIsA("SurfaceGui")
                            local icon = gui and gui:FindFirstChild("Icon")
                            local luck = icon and icon:FindFirstChildWhichIsA("TextLabel")
                            if luck and luck.Text then
                                local validMultiplier = not CurrentTargetMultiplier or luck.Text == CurrentTargetMultiplier
                                if validMultiplier then
                                    found = true
                                    if teleportToEgg(egg) then
                                        repeat
                                            if not AutoRiftHatch then break end
                                            hatchEgg(egg.Name)
                                            task.wait(0.3)
                                        until not egg.Parent
                                    end
                                end
                            end
                        end
                    end

                    if not found then
                        local stillExists = false
                        for _, egg in pairs(Rifts:GetChildren()) do
                            if egg:IsA("Model") and egg.Name == CurrentTargetEgg then
                                local display = egg:FindFirstChild("Display")
                                local gui = display and display:FindFirstChildWhichIsA("SurfaceGui")
                                local icon = gui and gui:FindFirstChild("Icon")
                                local luck = icon and icon:FindFirstChildWhichIsA("TextLabel")
                                local validMultiplier = not CurrentTargetMultiplier or (luck and luck.Text == CurrentTargetMultiplier)
                                
                                if validMultiplier then
                                    stillExists = true
                                    break
                                end
                            end
                        end
                    
                        if not stillExists then
                            chooseNewTarget()
                        end
                    end                    

                    task.wait(0.5)
                end
                disableNoClip() -- Ensure NoClip is disabled when loop ends
            end)
        else
            cancelAllOperations()
            Fluent:Notify({ 
                Title = "Auto Hatch", 
                Content = "Stopped auto hatching", 
                Duration = 3 
            })
        end
    end
})

local AutoGoldenChest = false
local ActiveTween
local NoClipConnection

local function enableNoClip()
    if NoClipConnection then return end
    NoClipConnection = game:GetService("RunService").Stepped:Connect(function()
        if game.Players.LocalPlayer.Character then
            for _, part in ipairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function disableNoClip()
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
end

local function teleportAndFarm()
    while AutoGoldenChest do
        local chest = workspace.Rendered.Rifts:FindFirstChild("golden-chest")
        if chest then
            -- Teleport with TweenService (6 seconds)
            local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                enableNoClip()
                local tween = TweenService:Create(hrp, TweenInfo.new(7), {
                    CFrame = chest:GetPivot() * CFrame.new(0, 0, 0)
                })
                tween:Play()
                tween.Completed:Wait()
                
                -- Farm while chest exists
                while AutoGoldenChest and chest.Parent do
                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("UnlockRiftChest", "golden-chest")
                    task.wait(0.5)
                end
            end
        end
        task.wait(0.5)
    end
    disableNoClip()
end

-- Add this to your existing Fluent UI
ChestHunt:AddToggle("AutoGoldenChestToggle", {
    Title = "Auto Golden Chest",
    Description = "Teleport and farm golden chest automatically",
    Default = false,
    Callback = function(state)
        AutoGoldenChest = state
        if state then
            Fluent:Notify({
                Title = "Golden Chest",
                Content = "Started farming golden chest",
                Duration = 3
            })
            task.spawn(teleportAndFarm)
        else
            Fluent:Notify({
                Title = "Golden Chest",
                Content = "Stopped farming golden chest",
                Duration = 3
            })
        end
    end
})

local AutoGiftRift = false
local ActiveTween
local NoClipConnection

-- Fun√ß√£o NoClip (reutiliz√°vel)
local function manageNoClip(enable)
    if enable then
        if not NoClipConnection then
            NoClipConnection = game:GetService("RunService").Stepped:Connect(function()
                if game.Players.LocalPlayer.Character then
                    for _, part in ipairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if NoClipConnection then
            NoClipConnection:Disconnect()
            NoClipConnection = nil
        end
    end
end

-- Fun√ß√£o principal para o Gift Rift
local function teleportAndClaimGift()
    while AutoGiftRift do
        local gift = workspace.Rendered.Rifts:FindFirstChild("gift-rift")
        if gift then
            -- Teleporte com TweenService (6 segundos)
            local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                manageNoClip(true)
                local tween = TweenService:Create(hrp, TweenInfo.new(6), {
                    CFrame = gift:GetPivot() * CFrame.new(0, 0, -3)
                })
                tween:Play()
                tween.Completed:Wait()
                
                -- Fica reivindicando enquanto o gift existir
                while AutoGiftRift and gift.Parent do
                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimRiftGift", "gift-rift")
                    task.wait(0.5) -- Intervalo entre claims
                end
            end
        end
        task.wait(0.5) -- Verifica a cada 1 segundo se o gift reapareceu
    end
    manageNoClip(false)
end

-- Adicione esta toggle √† sua interface Fluent
GiftHunt:AddToggle("AutoGiftRiftToggle", {
    Title = "Auto Gift Rift",
    Description = "Automatically teleports and collects gifts",
    Default = false,
    Callback = function(state)
        AutoGiftRift = state
        if state then
            Fluent:Notify({
                Title = "Gift Rift",
                Content = "Starting automatic gifts collection",
                Duration = 3
            })
            task.spawn(teleportAndClaimGift)
        else
            Fluent:Notify({
                Title = "Gift Rift",
                Content = "Automatic collection deactivated",
                Duration = 3
            })
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgrade", {
    Title = "Auto Upgrade Mastery for Buffs",
    Description = "Runs Upgrade Mastery automatically when activated.",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgrade = state  -- Armazenando o estado para controle de loop

        if state then
            spawn(function()  -- Usando spawn para rodar em uma thread separada
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                while AutoUpgrade do  -- Enquanto a toggle estiver ativada, o loop continua
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Buffs"
                    }

                    -- Envia a requisi√ß√£o ao servidor
                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)  -- Intervalo entre as chamadas (ajust√°vel conforme necess√°rio)
                end
            end)
        else
            -- Se a toggle for desativada, o loop ser√° interrompido
            getgenv().AutoUpgrade = false
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgradePets", {
    Title = "Auto Upgrade Mastery for Pets",
    Description = "Runs Upgrade Mastery for Pets automatically when activated.",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgradePets = state  -- Controla o estado da toggle

        if state then
            spawn(function()  -- Usando spawn para rodar em uma thread separada
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                while AutoUpgradePets do  -- Enquanto a toggle estiver ativada, o loop continua
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Pets"  -- Aqui est√° o "Pets" que voc√™ mencionou
                    }

                    -- Envia a requisi√ß√£o ao servidor
                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)  -- Intervalo entre as chamadas (ajust√°vel conforme necess√°rio)
                end
            end)
        else
            -- Se a toggle for desativada, o loop ser√° interrompido
            getgenv().AutoUpgradePets = false
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgradeShops", {
    Title = "Auto Upgrade Mastery for Shops",
    Description = "Runs Upgrade Mastery for Shops automatically when activated.",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgradeShops = state  -- Controla o estado da toggle

        if state then
            spawn(function()  -- Usando spawn para rodar em uma thread separada
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                while AutoUpgradeShops do  -- Enquanto a toggle estiver ativada, o loop continua
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Shops"  -- Aqui est√° o "Shops" que voc√™ mencionou
                    }

                    -- Envia a requisi√ß√£o ao servidor
                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)  -- Intervalo entre as chamadas (ajust√°vel conforme necess√°rio)
                end
            end)
        else
            -- Se a toggle for desativada, o loop ser√° interrompido
            getgenv().AutoUpgradeShops = false
        end
    end
})

-- Tabela com po√ß√µes v√°lidas
local potionList = {}
local dropdownOptions = {}

local potionNames = {"Coins", "Lucky", "Speed", "Mythic"}
local tiers = {1, 2, 3, 4, 5, 6}
local roman = {"I", "II", "III", "IV", "V", "VI"}

-- Cria mapeamento: "Lucky I" ‚Üí {"Lucky", 1}
for _, potion in ipairs(potionNames) do
    for i, tier in ipairs(tiers) do
        local displayName = potion .. " " .. roman[i]
        potionList[displayName] = {potion, tier}
        table.insert(dropdownOptions, displayName)
    end
end

-- Criando o Dropdown com sele√ß√£o m√∫ltipla
local MultiDropdown = AutoPotionSection:AddDropdown("Po√ß√µes", {
    Title = "Selecting Potions",
    Description = "Choose the potions to use",
    Values = dropdownOptions,
    Multi = true,
    Default = {},  -- Predefinir po√ß√µes selecionadas
})

-- A vari√°vel SelectedPotions vai ser atualizada quando o usu√°rio fizer altera√ß√µes
local SelectedPotions = {}

-- Fun√ß√£o para capturar as sele√ß√µes ap√≥s mudan√ßa
MultiDropdown:OnChanged(function(Value)
    -- Atualiza a lista de po√ß√µes selecionadas
    SelectedPotions = {}
    for potion, _ in pairs(Value) do
        table.insert(SelectedPotions, potion)
    end

    -- Exibe as po√ß√µes selecionadas no console
    print("Selected potions:", table.concat(SelectedPotions, ", "))
end)

-- RemoteEvent
local RemoteEvent = game:GetService("ReplicatedStorage")
    :WaitForChild("Shared")
    :WaitForChild("Framework")
    :WaitForChild("Network")
    :WaitForChild("Remote")
    :WaitForChild("Event")

-- Toggle Auto Potion
AutoPotionSection:AddToggle("Auto Usar Po√ß√µes", {
    Title = "Auto Use Potion",
    Description = "Enables automatic use of selected potions",
    Default = false,
    Callback = function(state)
        getgenv().AutoPotion = state

        if state then
            Fluent:Notify({Title = "Auto Po√ß√µes", Content = "Activated", Duration = 3})

            task.spawn(function()
                while getgenv().AutoPotion do
                    -- Verifica se existem po√ß√µes selecionadas
                    if #SelectedPotions == 0 then
                        Fluent:Notify({
                            Title = "Warn",
                            Content = "No potions selected.",
                            Duration = 4
                        })
                        break
                    end

                    -- Envia as po√ß√µes selecionadas para o servidor
                    for _, displayName in ipairs(SelectedPotions) do
                        local data = potionList[displayName]
                        if data then
                            local name, tier = unpack(data)
                            print("Sending:", name, tier)
                            pcall(function()
                                RemoteEvent:FireServer("UsePotion", name, tier)
                            end)
                            task.wait(0.2)
                        else
                            warn("Potion invalid:", displayName)
                        end
                    end

                    task.wait(0.3)
                end
            end)
        else
            Fluent:Notify({Title = "Auto Potions", Content = "Deactivated", Duration = 3})
        end
    end
})

-- Tabela com po√ß√µes v√°lidas
local potionList = {}
local dropdownOptions = {}

local potionNames = {"Coins", "Lucky", "Speed", "Mythic"}
local tiers = {2, 3, 4, 5, 6}
local roman = {"II", "III", "IV", "V", "VI"}

-- Cria mapeamento: "Lucky I" ‚Üí {"Lucky", 1}
for _, potion in ipairs(potionNames) do
    for i, tier in ipairs(tiers) do
        local displayName = potion .. " " .. roman[i]
        potionList[displayName] = {potion, tier}
        table.insert(dropdownOptions, displayName)
    end
end

-- Criando o Dropdown com sele√ß√£o m√∫ltipla
local MultiDropdown = AutoCraftPotionSection:AddDropdown("Po√ß√µes", {
    Title = "Selecting Potions to Craft",
    Description = "Choose the potions and tiers you want to craft",
    Values = dropdownOptions,
    Multi = true,
    Default = {},
})

-- Lista com as po√ß√µes selecionadas
local SelectedPotions = {}

-- Atualiza quando o usu√°rio seleciona
MultiDropdown:OnChanged(function(Value)
    SelectedPotions = {}
    for potion, _ in pairs(Value) do
        table.insert(SelectedPotions, potion)
    end
    print("Po√ß√µes para craft:", table.concat(SelectedPotions, ", "))
end)

-- RemoteEvent
local RemoteEvent = game:GetService("ReplicatedStorage")
    :WaitForChild("Shared")
    :WaitForChild("Framework")
    :WaitForChild("Network")
    :WaitForChild("Remote")
    :WaitForChild("Event")

-- Toggle Auto Craft
AutoCraftPotionSection:AddToggle("Auto Craft Po√ß√µes", {
    Title = "Auto Craft Potion",
    Description = "Automatically brews selected potions",
    Default = false,
    Callback = function(state)
        getgenv().AutoCraftPotion = state

        if state then
            Fluent:Notify({Title = "Auto Craft", Content = "Activated", Duration = 3})

            task.spawn(function()
                while getgenv().AutoCraftPotion do
                    if #SelectedPotions == 0 then
                        Fluent:Notify({
                            Title = "Warn",
                            Content = "No potions selected for crafting.",
                            Duration = 4
                        })
                        break
                    end

                    for _, displayName in ipairs(SelectedPotions) do
                        local data = potionList[displayName]
                        if data then
                            local name, tier = unpack(data)
                            print("Craftando:", name, tier)
                            pcall(function()
                                RemoteEvent:FireServer("CraftPotion", name, tier, false)
                            end)
                            task.wait(0.2)
                        else
                            warn("Potion invalid:", displayName)
                        end
                    end

                    task.wait(1.5)
                end
            end)
        else
            Fluent:Notify({Title = "Auto Craft", Content = "Deactivated", Duration = 3})
        end
    end
})

-- Toggle para teleportar com TweenService
local AutoTween = false

TeleportSection:AddToggle("TweenTeleport", {
    Title = "Unlock All Island",
    Description = "unlock all the islands",
    Default = false,
    Callback = function(state)
        AutoTween = state

        if AutoTween then
            local targetPos = Vector3.new(5.7106, 16206.042, -8.6645)

            local character = game.Players.LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local hrp = character.HumanoidRootPart
                local tweenService = game:GetService("TweenService")

                local tweenInfo = TweenInfo.new(
                    20, -- tempo de transi√ß√£o (segundos)
                    Enum.EasingStyle.Linear,
                    Enum.EasingDirection.Out
                )

                local goal = { CFrame = CFrame.new(targetPos) }

                local tween = tweenService:Create(hrp, tweenInfo, goal)
                tween:Play()

                tween.Completed:Connect(function()
                    AutoTween = false
                end)
            end
        end
    end
})

-- Tabela com locais de teleporte
local teleportLocations = {
    ["Twilight Island"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",
    ["Outer Space"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Spawn (Overworld)"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["The Void"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Floating Island"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
    ["Zen"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn",
}

-- Loop para criar os bot√µes de teleporte
for name, path in pairs(teleportLocations) do
    Tabs.Teleport:AddButton({
        Title = name,
        Description = "Teleport to " .. name,
        Callback = function()
            local RemoteEvent = game:GetService("ReplicatedStorage")
                :WaitForChild("Shared")
                :WaitForChild("Framework")
                :WaitForChild("Network")
                :WaitForChild("Remote")
                :WaitForChild("Event")

            RemoteEvent:FireServer("Teleport", path)

            Fluent:Notify({
                Title = "Teleport",
                Content = "Teleport to: " .. name,
                Duration = 3
            })
        end
    })
end

--// Bot√£o de resgatar c√≥digos
CodeSection:AddButton({
    Title = "Redeem Codes",
    Description = "Redeem all available codes",
    Callback = function()
        local codes = { "Release", "Thanks", "Lucky" }
        for _, code in ipairs(codes) do
            local success, result = pcall(function()
                return game:GetService("ReplicatedStorage")
                    .Shared.Framework.Network.Remote.Function
                    :InvokeServer("RedeemCode", code)
            end)
            if success then
                print("Code redeemed:", code)
            else
                warn("Error redeeming code:", code, result)
            end
            task.wait(1)
        end
    end
})

--// ======= [SETTINGS] =======

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/BubbleGumInfinity")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

local CoreGui = game:GetService("CoreGui")

-- Remover qualquer GUI persistente anterior com o mesmo nome
local ExistingGui = CoreGui:FindFirstChild("MinimizeButtonGui")
if ExistingGui then
    ExistingGui:Destroy()
end

local ScreenGuiToMinimize

-- Itera por todos os ScreenGuis no CoreGui para encontrar o correto
for _, gui in ipairs(CoreGui:GetChildren()) do
    if gui:IsA("ScreenGui") then
        for _, descendant in ipairs(gui:GetDescendants()) do
            if descendant:IsA("TextLabel") and descendant.Text == "Bubble Gum Simulator INFINITY | DZHUB" then
                ScreenGuiToMinimize = gui
                break
            end
        end
    end
    if ScreenGuiToMinimize then break end
end

if not ScreenGuiToMinimize then
    warn("ScreenGui com o texto especificado n√£o encontrado.")
    return
end

print("ScreenGui encontrado:", ScreenGuiToMinimize.Name)

-- Criar bot√£o persistente
local MinimizeGui = Instance.new("ScreenGui", CoreGui)
MinimizeGui.Name = "MinimizeButtonGui"

local MinimizeButton = Instance.new("ImageButton", MinimizeGui)
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Size = UDim2.new(0, 44, 0, 45)
MinimizeButton.Position = UDim2.new(0.1, 0, 0.1, 0)
MinimizeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.BorderSizePixel = 0
MinimizeButton.Image = "rbxassetid://101109248169642" -- Substitua pelo ID da imagem desejado

-- Adicionar UICorner ao bot√£o para arredondar bordas
local UICorner = Instance.new("UICorner", MinimizeButton)

-- Fun√ß√£o para minimizar corretamente
MinimizeButton.MouseButton1Click:Connect(function()
    if Window and Window.Minimize then
        Window:Minimize()
    else
        warn("Fun√ß√£o Window:Minimize n√£o est√° dispon√≠vel.")
    end
end)

-- Adicionar funcionalidade de arrastar o bot√£o
local dragging = false
local dragStart, startPos

local function update(input)
    local delta = input.Position - dragStart
    MinimizeButton.Position = UDim2.new(
        startPos.X.Scale,
        startPos.X.Offset + delta.X,
        startPos.Y.Scale,
        startPos.Y.Offset + delta.Y
    )
end

MinimizeButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MinimizeButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

MinimizeButton.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        update(input)
    end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        update(input)
    end
end)

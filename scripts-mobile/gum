local Fluent = loadstring(game:HttpGet("https://github.com/Dexz00/DZ-Ui/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Dexz00/DZ-Ui/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Dexz00/DZ-Ui/master/Addons/InterfaceManager.lua"))()

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")

local player = Players.LocalPlayer
local LocalPlayer = player

local Window = Fluent:CreateWindow({
    Title = "Bubble Gum Simulator INFINITY | DZ HUB",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false,
    Theme = "Amethyst",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "rbxassetid://124620632231839" }),
    MiniGame = Window:AddTab({ Title = "MiniGame", Icon = "gamepad-2" }),
    EggHunt = Window:AddTab({ Title = "Egg / Hunt", Icon = "egg" }),
    Upgrades = Window:AddTab({ Title = "Upgrades", Icon = "arrow-big-up" }),
    Potions = Window:AddTab({ Title = "Potions", Icon = "glass-water" }),
    Teleport = Window:AddTab({ Title = "Teleport", Icon = "rbxassetid://12689978575" }),
    ServerHop = Window:AddTab({ Title = "Server Hop", Icon = "server" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "scroll" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local SellOptions = Tabs.Main:AddSection("Sell Options")
local BlowSection = Tabs.Main:AddSection("Bubble + Sell Automation")
local CollectSection = Tabs.Main:AddSection("Auto Collect")
local PetMatchSection = Tabs.MiniGame:AddSection("Pet Match")
local RobotClawSection = Tabs.MiniGame:AddSection("Robot Claw")
local BoardGameSection = Tabs.MiniGame:AddSection("Board Game")
local MerchantSection = Tabs.Main:AddSection("Merchant")
local UtilitiesSection = Tabs.Main:AddSection("Utilities")
local Egg = Tabs.EggHunt:AddSection("Egg")
local EggRift = Tabs.EggHunt:AddSection("Egg Rift")
local ChestHunt = Tabs.EggHunt:AddSection("Chest Hunt")
local GiftHunt = Tabs.EggHunt:AddSection("Gift Hunt")
local AutoPotionSection = Tabs.Potions:AddSection("Auto Use Potion")
local AutoCraftPotionSection = Tabs.Potions:AddSection("Auto Craft Potion")
local TeleportSection = Tabs.Teleport:AddSection("Unlock All Islands")
local CodeSection = Tabs.Misc:AddSection("Codes")

local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteEvent")
local RemoteFunction = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteFunction")

local dropAltitude = -100
local moveSpeed = 18
local claimAltitude = 3
local claimAttemptDelay = 0.5
local maxClaimAttempts = 10
local searchInterval = 1
local maxSellAttempts = 10
local sellAttemptDelay = 0.5

local AutoBlow = false
local AutoSell = false
local AutoHatch = false
local AutoCollect = false
local buyDiceLoop = false
local equipBestRunning = false
local AutoGoldenChest = false
local AutoRoyalChest = false
local AutoRiftHatch = false
local IsProcessingNormalHatch = false
local AutoUpgrade = false
local AutoUpgradePets = false
local AutoUpgradeShops = false
local AutoPotion = false
local AutoCraftPotion = false
local autoGiftRiftEnabled = false

local SelectedEgg = "Iceshard Egg"
local HatchAmount = 10
local SelectedRiftEggs = {}
local SelectedLuckMultipliers = {}
local CurrentTargetEgg = nil
local CurrentTargetMultiplier = nil
local sellMethod = "Storage Full"
local timedInterval = 120
local selectedMultiplier = "2x"
local CollectDistance = 40
local ActiveTweens = {}
local NoClipConnection = nil

local EggTeleportMap = {
    ["Common Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Spotted Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Iceshard Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Spikey Egg"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
    ["Magma Egg"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Crystal Egg"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Lunar Egg"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",
    ["Void Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Hell Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Nightmare Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Rainbow Egg"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn",
    ["Infinity Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Game Egg"] = "Workspace.Worlds.Minigame Paradise.PortalSpawn",
    ["Showman Egg"] = "Workspace.Worlds.Minigame Paradise.PortalSpawn",
    ["Mining Egg"] = "Workspace.Worlds.Minigame Paradise.PortalSpawn",
    ["Cyber Egg"] = "Workspace.Worlds.Minigame Paradise.PortalSpawn",
    ["200M Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn"
}

local EggPositions = {
    ["Common Egg"] = Vector3.new(-8.694, 9.299, -82.083),
    ["Spotted Egg"] = Vector3.new(-7.885, 9.299, -71.139),
    ["Iceshard Egg"] = Vector3.new(-8.795, 9.299, -59.287),
    ["Spikey Egg"] = Vector3.new(-6.725, 422.931, 157.788),
    ["Magma Egg"] = Vector3.new(-19.168, 2665.166, 8.449),
    ["Crystal Egg"] = Vector3.new(-18.302, 2665.166, 18.251),
    ["Lunar Egg"] = Vector3.new(-57.512, 6862.583, 79.986),
    ["Void Egg"] = Vector3.new(5.301, 10147.804, 188.563),
    ["Hell Egg"] = Vector3.new(-8.620, 10147.804, 193.417),
    ["Nightmare Egg"] = Vector3.new(-17.104, 10147.804, 185.614),
    ["Rainbow Egg"] = Vector3.new(-34.151, 15972.424, 45.445),
    ["Infinity Egg"] = Vector3.new(-96.606, 8.299, -27.740),
    ["Game Egg"] = Vector3.new(9835.315, 27.373, 171.214),
    ["Showman Egg"] = Vector3.new(9941.394, 26.922, 210.422),
    ["Mining Egg"] = Vector3.new(9915.380, 7681.251, 238.066),
    ["Cyber Egg"] = Vector3.new(9914.804, 13410.272, 242.392),
    ["200M Egg"] = Vector3.new(12.599, 9.655, -7.341)
}

local EggNameMap = {
    ["spotted-egg"] = "Spotted Egg",
    ["iceshard-egg"] = "Iceshard Egg",
    ["spikey-egg"] = "Spikey Egg",
    ["magma-egg"] = "Magma Egg",
    ["crystal-egg"] = "Crystal Egg",
    ["lunar-egg"] = "Lunar Egg",
    ["void-egg"] = "Void Egg",
    ["hell-egg"] = "Hell Egg",
    ["nightmare-egg"] = "Nightmare Egg",
    ["rainbow-egg"] = "Rainbow Egg",
    ["infinity-egg"] = "Infinity Egg",
    ["silly-egg"] = "Silly Egg",
    ["man-egg"] = "Man Egg",
    ["showman-egg"] = "Showman Egg",
    ["mining-egg"] = "Mining Egg",
    ["cyber-egg"] = "Cyber Egg"
}

local portalLocations = {
    ["Twilight Island | World 1"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",
    ["Outer Space | World 1"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Overworld Spawn | World 1"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["The Void | World 1"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Floating Island | World 1"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
    ["Zen | World 1"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn",
    ["Minigame Paradise Spawn | World 2"] = "Workspace.Worlds.Minigame Paradise.PortalSpawn",
    ["Dice Island | World 2"] = "Workspace.Worlds.Minigame Paradise.Islands.Dice Island.Island.Portal.Spawn",
    ["Minecart Forest | World 2"] = "Workspace.Worlds.Minigame Paradise.Islands.Minecart Forest.Island.Portal.Spawn",
    ["Robot Factory | World 2"] = "Workspace.Worlds.Minigame Paradise.Islands.Robot Factory.Island.Portal.Spawn"
}

local Multipliers = {
    ["2x | World 1"] = {
        position = Vector3.new(77.646, 8.919, -113.403),
        size = Vector3.new(10, 1, 10)
    },
    ["5x | World 1"] = {
        position = Vector3.new(-70.824, 6862.206, 116.410),
        size = Vector3.new(10, 1, 10)
    },
    ["250x | World 1"] = {
        position = Vector3.new(-326.694, 25.681, 191.227),
        size = Vector3.new(10, 1, 10)
    },
    ["10x | World 2"] = {
        position = Vector3.new(9852.754, 13409.273, 241.416),
        size = Vector3.new(10, 1, 10)
    },
    ["5x | World 2"] = {
        position = Vector3.new(9922.182, 26.373, 135.957),
        size = Vector3.new(10, 1, 10)
    }
}

local codes = {
    "update2",   
    "Easter",    
    "Release",   
    "Lucky"   
}

BlowSection:AddToggle("AutoBlow", {
    Title = "Auto Blow",
    Description = "Automatically blows the bubble",
    Default = false,
    Callback = function(state)
        AutoBlow = state
        if state then
            task.spawn(function()
                local lastBlowTime = 0
                while AutoBlow do
                    if tick() - lastBlowTime >= 0.1 then
                        pcall(function()
                            RemoteEvent:FireServer("BlowBubble")
                        end)
                        lastBlowTime = tick()
                    end
                    task.wait(0.5)
                end
            end)
        end
    end
})

local platform = nil
local autoFarmEnabled = false
local lastSell = os.clock()
local isSelling = false

local originalGravity = Workspace.Gravity
local originalPhysics = true
local originalHRPProperties = {}

local function getHRP()
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    
    if not originalHRPProperties.size then
        originalHRPProperties.size = hrp.Size
        originalHRPProperties.customPhysicalProperties = hrp.CustomPhysicalProperties
    end
    
    return hrp
end

local function setPhysicsEnabled(enabled)
    local char = player.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, enabled)
        end
        
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.AssemblyLinearVelocity = Vector3.new()
                part.AssemblyAngularVelocity = Vector3.new()
                part.CustomPhysicalProperties = enabled and originalHRPProperties.customPhysicalProperties or PhysicalProperties.new(0, 0, 0)
            end
        end
    end
end

local function createPlatform()
    if platform then
        platform:Destroy()
    end
    
    local config = Multipliers[selectedMultiplier]
    
    platform = Instance.new("Part")
    platform.Name = "TempPlatform"
    platform.Size = config.size
    platform.Anchored = true
    platform.CanCollide = true
    platform.Position = config.position
    platform.Transparency = 1
    platform.CastShadow = false
    platform.Parent = Workspace
end

local function teleportToBelow(pos)
    local hrp = getHRP()
    setPhysicsEnabled(false)
    hrp.CFrame = CFrame.new(pos.X, dropAltitude, pos.Z)
end

local function tweenToPositionXZ(targetPos)
    local hrp = getHRP()
    local startPos = hrp.Position
    local targetXZ = Vector3.new(targetPos.X, startPos.Y, targetPos.Z)
    local distance = (targetXZ - startPos).Magnitude
    local duration = distance / moveSpeed

    setPhysicsEnabled(false)
    
    local info = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
    local tween = TweenService:Create(hrp, info, {CFrame = CFrame.new(targetXZ)})
    
    local conn = RunService.Heartbeat:Connect(function()
        hrp.AssemblyLinearVelocity = Vector3.new()
        hrp.AssemblyAngularVelocity = Vector3.new()
    end)
    
    tween:Play()
    tween.Completed:Wait()
    conn:Disconnect()
end

local function getBubbleStorage()
    local playerGui = player:FindFirstChild("PlayerGui")
    if not playerGui then return 0, 0 end
    
    local label = playerGui
        :FindFirstChild("ScreenGui")
        :FindFirstChild("HUD")
        :FindFirstChild("Left")
        :FindFirstChild("Currency")
        :FindFirstChild("Bubble")
        :FindFirstChild("Frame")
        :FindFirstChild("Label")
    
    if not label then return 0, 0 end
    
    local txt = label.ContentText or label.Text
    local curStr, maxStr = txt:match("([%d,]+)%s*/%s*([%d,]+)")
    local cleanCurStr = curStr and curStr:gsub(",", "") or "0"
    local cleanMaxStr = maxStr and maxStr:gsub(",", "") or "0"
    local cur = tonumber(cleanCurStr) or 0
    local max = tonumber(cleanMaxStr) or 0
    
    return cur, max
end

local function teleportAndSell(pos)
    local hrp = getHRP()
    local yOffset = (hrp.Size.Y / 2) + (Multipliers[selectedMultiplier].size.Y / 2)
    local targetPos = pos + Vector3.new(0, yOffset, 0)
    
    setPhysicsEnabled(false)
    hrp.CFrame = CFrame.new(targetPos)

    if math.abs(hrp.Position.Y - targetPos.Y) < 5 then
        RemoteEvent:FireServer("SellBubble")
    end
    
    task.delay(0.5, function()
        setPhysicsEnabled(true)
    end)
end

local function restoreOriginalSettings()
    Workspace.Gravity = originalGravity

    setPhysicsEnabled(true)
    
    local char = player.Character
    if char then
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CustomPhysicalProperties = originalHRPProperties.customPhysicalProperties
        end
    end
end

local function sellBubblesWithMultiplier()
    if isSelling then return end
    isSelling = true
    
    local wasAutoFarmEnabled = autoFarmEnabled

    local originalPos = getHRP().Position

    createPlatform()

    teleportToBelow(originalPos)
    tweenToPositionXZ(Multipliers[selectedMultiplier].position)

    local attempts = 0
    local currentBubbles = 1 
    
    while currentBubbles > 0 and attempts < maxSellAttempts do
        attempts = attempts + 1

        teleportAndSell(Multipliers[selectedMultiplier].position)

        wait(sellAttemptDelay)

        currentBubbles, _ = getBubbleStorage()

        if currentBubbles <= 0 then
            break
        elseif attempts >= maxSellAttempts then
        end
    end

    teleportToBelow(Multipliers[selectedMultiplier].position)
    tweenToPositionXZ(originalPos)
    teleportAndSell(originalPos)

    wait(1)
    if platform then
        platform:Destroy()
        platform = nil
    end

    restoreOriginalSettings()

    lastSell = os.clock()
    isSelling = false
    
    if autoFarmEnabled then
    end
end

local function autoFarmTick()
    if not autoFarmEnabled then return end

    if not isSelling then
        RemoteEvent:FireServer("BlowBubble")

        local cur, max = getBubbleStorage()

        if sellMethod == "Storage Full" and cur > 0 and cur == max then
            task.spawn(sellBubblesWithMultiplier) 
        elseif sellMethod == "Timed" and os.clock() - lastSell >= timedInterval then
            task.spawn(sellBubblesWithMultiplier) 
        end
    end
end

local autoFarmConnection = nil

local function startAutoFarm()
    if autoFarmConnection then return end
    
    autoFarmEnabled = true
    lastSell = os.clock()

    autoFarmConnection = RunService.Heartbeat:Connect(function()
        if not game:GetService("RunService").Heartbeat:Wait() then return end
        if not autoFarmEnabled then 
            if autoFarmConnection then
                autoFarmConnection:Disconnect()
                autoFarmConnection = nil
            end
            return
        end

        autoFarmTick()
    end)
end

local function stopAutoFarm()
    autoFarmEnabled = false
    
    if autoFarmConnection then
        autoFarmConnection:Disconnect()
        autoFarmConnection = nil
    end
end

SellOptions:AddDropdown("SellMethodDropdown", {
    Title = "Auto Sell method",
    Description = "Choose when to sell the bubbles",
    Values = { "Storage Full", "Timed" },
    Multi = false,
    Default = "Storage Full",
    Callback = function(Value)
        sellMethod = Value
    end
})

SellOptions:AddInput("TimedIntervalInput", {
    Title = "Sales Interval (Seconds)",
    Description = "Time between sales in Timed mode",
    Default = "120",
    Placeholder = "Enter the time in seconds",
    Numeric = true,
    Finished = false,
    Callback = function(Value)
        timedInterval = tonumber(Value) or 120
    end
})

local Dropdown = SellOptions:AddDropdown("MultiplierDropdown", {
    Title = "Select the Multiplier",
    Description = "Choose the desired luck multiplier",
    Values = {"2x | World 1", "5x | World 1", "250x | World 1", "5x | World 2", "10x | World 2"},
    Multi = false,
    Default = "2x | World 1",
})

Dropdown:OnChanged(function(Value)
    selectedMultiplier = Value
end)

BlowSection:AddToggle("AutoFarmToggle", {
    Title = "Auto Sell + Auto Blow",
    Default = false,
    Callback = function(Value)
        if Value then
            startAutoFarm()
        else
            stopAutoFarm()
        end
    end
})

CollectSection:AddSlider("CollectDistanceSlider", {
    Title = "Pick-up distance",
    Default = 40,
    Min = 10,
    Max = 200,
    Rounding = 0,
    Callback = function(value)
        CollectDistance = value
    end
})

CollectSection:AddToggle("AutoCollectToggle", {
    Title = "Auto Collect Coins/Gems/Crates",
    Default = false,
    Callback = function(state)
        AutoCollect = state

        if state then
            task.spawn(function()
                local pickupRemote = game:GetService("ReplicatedStorage"):WaitForChild("Remotes")
                                          :WaitForChild("Pickups"):WaitForChild("CollectPickup")
                local LocalPlayer = Players.LocalPlayer
                local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

                while AutoCollect and task.wait(0.2) do
                    pcall(function()
                        local rendered = workspace:FindFirstChild("Rendered")
                        if rendered then
                            local itemsToCollect = {}

                            for _, folder in ipairs(rendered:GetChildren()) do
                                if folder.Name == "Chunker" then
                                    for _, model in ipairs(folder:GetChildren()) do
                                        if model:IsA("Model") and #model.Name >= 25 then
                                            local primaryPart = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                                            if primaryPart and Character and Character:FindFirstChild("HumanoidRootPart") then
                                                local distance = (primaryPart.Position - Character.HumanoidRootPart.Position).Magnitude
                                                if distance <= CollectDistance then
                                                    table.insert(itemsToCollect, model)
                                                end
                                            end
                                        end
                                    end
                                end
                            end

                            for i, model in ipairs(itemsToCollect) do
                                pickupRemote:FireServer(model.Name)
                                model:Destroy()

                                if i % 20 == 0 then
                                    task.wait(0.2)
                                end
                            end
                        end
                    end)
                end
            end)
        end
    end
})

MerchantSection:AddToggle("AutoBuyDice", {
    Title = "Auto Merchant Dice",
    Default = false,
    Callback = function(state)
        buyDiceLoop = state

        task.spawn(function()
            while buyDiceLoop do
                for i = 1, 3 do
                    local args = {
                        [1] = "BuyShopItem",
                        [2] = "dice-shop",
                        [3] = i
                    }
                    RemoteEvent:FireServer(unpack(args))

                    task.wait(0.2)
                end
            end
        end)
    end
})

MerchantSection:AddToggle("AutoBuyAlienShop", {
    Title = "Auto Buy Alien Shop Items",
    Default = false,
    Callback = function(state)
        getgenv().AutoBuyAlienShop = state

        if state then
            spawn(function()
                while AutoBuyAlienShop do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("BuyShopItem", "alien-shop", i)
                        task.wait(0.5)
                    end

                    task.wait(3)
                end
            end)
        end
    end
})

MerchantSection:AddToggle("AutoBuyShardShop", {
    Title = "Auto Buy Black Market Shop Items",
    Default = false,
    Callback = function(state)
        getgenv().AutoBuyShardShop = state

        if state then
            task.spawn(function()
                while getgenv().AutoBuyShardShop do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("BuyShopItem", "shard-shop", i)
                        task.wait(0.5)
                    end
                    task.wait(3)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("EquipBestToggle", {
    Title = "Auto Equip Best Pets",
    Default = false,
    Callback = function(state)
        equipBestRunning = state
        
        if state then
            task.spawn(function()
                while equipBestRunning do
                    local args = {[1] = "EquipBestPets"}
                    RemoteEvent:FireServer(unpack(args))
                    task.wait(2)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoClaimChests", {
    Title = "Auto Claim Chests",
    Default = false,
    Callback = function(state)
        getgenv().AutoClaimChests = state

        if state then
            spawn(function()
                local LocalPlayer = Players.LocalPlayer
                local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local HRP = Character:WaitForChild("HumanoidRootPart")
                local Humanoid = Character:WaitForChild("Humanoid")

                local chestData = {
                    ["Giant Chest"] = {
                        teleportTo = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
                        walkTo = Vector3.new(13.179, 427.931, 158.939),
                        path = "Giant Chest"
                    },
                    ["Void Chest"] = {
                        teleportTo = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
                        walkTo = Vector3.new(76.660, 10148.206, 52.507),
                        path = "Void Chest"
                    },
                    ["Ticket Chest"] = {
                        teleportTo = "Workspace.Worlds.Minigame Paradise.Islands.Dice Island.Island.Portal.Spawn",
                        walkTo = Vector3.new(9883.284, 2912.246, 233.726),
                        path = "Ticket Chest"
                    }
                }
                local function isChestReady(chestName)
                    local genericChest = Workspace.Rendered.Generic:FindFirstChild(chestName)
                    return genericChest and genericChest:FindFirstChild("Outer") ~= nil
                end

                for chestName, data in pairs(chestData) do
                    if not isChestReady(data.path) then
                        Fluent:Notify({
                            Title = "Cooldown",
                            Content = chestName .. " it's on cooldown!",
                            Duration = 4
                        })
                    end
                end

                local noclipConnection
                noclipConnection = RunService.Stepped:Connect(function()
                    if getgenv().AutoClaimChests then
                        for _, part in ipairs(Character:GetDescendants()) do
                            if part:IsA("BasePart") and part.CanCollide then
                                part.CanCollide = false
                            end
                        end
                    else
                        noclipConnection:Disconnect()
                    end
                end)

                local function fireTeleport(path)
                    RemoteEvent:FireServer("Teleport", path)
                    task.wait(2.5)
                end

                local function walkTo(position)
                    Humanoid:MoveTo(position)
                    Humanoid.MoveToFinished:Wait()
                end

                while getgenv().AutoClaimChests do
                    for chestName, data in pairs(chestData) do
                        if isChestReady(data.path) then
                            fireTeleport(data.teleportTo)
                            walkTo(data.walkTo)
                            task.wait(0.5)
                            RemoteEvent:FireServer("ClaimChest", chestName)
                            Fluent:Notify({
                                Title = "Chest Claimed",
                                Content = chestName .. " successfully collected!",
                                Duration = 3
                            })
                        end
                        task.wait(1)
                    end
                    task.wait(1)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoClaimSeason", {
    Title = "Auto Claim Season",
    Default = false,
    Callback = function(state)
        getgenv().AutoClaimSeason = state

        if state then
            task.spawn(function()
                while AutoClaimSeason do
                    local args = {
                        [1] = "ClaimSeason"
                    }

                    RemoteEvent:FireServer(unpack(args))
                    task.wait(5)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoClaimPlaytime", {
    Title = "Auto Claim Playtime Rewards",
    Default = false,
    Callback = function(state)
        AutoClaimPlaytime = state

        task.spawn(function()
            while AutoClaimPlaytime do
                for i = 1, 9 do
                    pcall(function()
                        RemoteFunction:InvokeServer("ClaimPlaytime", i)
                    end)
                end
                task.wait(5)
            end
        end)
    end
})

UtilitiesSection:AddToggle("AutoGiftGrabber", {
    Title = "Auto Open Mystery Box + Claim",
    Default = false,
    Callback = function(state)
        getgenv().AutoGiftGrabber = state

        if state then
            spawn(function()
                local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network")
                local RenderedGifts = workspace:WaitForChild("Rendered"):WaitForChild("Gifts")

                while AutoGiftGrabber do
                    RemoteEvent:FireServer("UseGift", "Mystery Box", 10)

                    local startTime = os.clock()
                    local detectedGifts = {}

                    repeat
                        for _, obj in pairs(RenderedGifts:GetChildren()) do
                            if obj:IsA("BasePart") and not detectedGifts[obj] then
                                detectedGifts[obj] = true
                                RemoteEvent:FireServer("ClaimGift", obj.Name)
                                
                                task.delay(0.3, function()
                                    if obj and obj.Parent then
                                        obj:Destroy()
                                    end
                                end)
                            end
                        end
                        task.wait(0.3)
                    until os.clock() - startTime > 10 or not AutoGiftGrabber

                    task.wait(0.3)
                end
            end)
        end 
    end
})

UtilitiesSection:AddToggle("AutoGiftGrabber", {
    Title = "Auto Open Golden Box + Claim",
    Default = false,
    Callback = function(state)
        getgenv().AutoGiftGrabber = state

        if state then
            spawn(function()
                local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network")
                local RenderedGifts = workspace:WaitForChild("Rendered"):WaitForChild("Gifts")

                while AutoGiftGrabber do
                    RemoteEvent:FireServer("UseGift", "Golden Box", 10)

                    local startTime = os.clock()
                    local detectedGifts = {}

                    repeat
                        for _, obj in pairs(RenderedGifts:GetChildren()) do
                            if obj:IsA("BasePart") and not detectedGifts[obj] then
                                detectedGifts[obj] = true
                                RemoteEvent:FireServer("ClaimGift", obj.Name)
                                
                                task.delay(0.5, function()
                                    if obj and obj.Parent then
                                        obj:Destroy()
                                    end
                                end)
                            end
                        end
                        task.wait(0.5)
                    until os.clock() - startTime > 10 or not AutoGiftGrabber

                    task.wait(0.5)
                end
            end)
        end 
    end
})

UtilitiesSection:AddToggle("AutoStartGenieQuest", {
    Title = "Auto Start Genie Quest",
    Default = false,
    Callback = function(state)
        getgenv().AutoGenieQuest = state

        if state then
            task.spawn(function()
                while getgenv().AutoGenieQuest do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("StartGenieQuest", i)
                        task.wait(1)
                    end
                    task.wait(1)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoDoggyJumpWin", {
    Title = "Auto Win Doggy",
    Default = false,
    Callback = function(state)
        getgenv().AutoDoggyJumpWin = state

        if state then
            spawn(function()
                while AutoDoggyJumpWin do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("DoggyJumpWin", i)
                        task.wait(1)
                    end
                    task.wait(3)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoWheelSpin", {
    Title = "Auto Wheel Spin",
    Default = false,
    Callback = function(state)
        getgenv().AutoWheelSpin = state

        if state then
            task.spawn(function()
                while getgenv().AutoWheelSpin do
                    pcall(function()
                        RemoteEvent:FireServer("ClaimFreeWheelSpin")
                    end)
                    
                    pcall(function()
                        RemoteFunction:InvokeServer("WheelSpin")
                    end)
                    
                    task.wait(1)
                end
            end)
        end
    end
})

local difficulties = {
    ["Easy"] = "Easy",
    ["Medium"] = "Medium",
    ["Hard"] = "Hard",
    ["Insane"] = "Insane"
}

local selectedDifficulty = "Easy"

local Dropdown = PetMatchSection:AddDropdown("MinigameDifficulty", {
    Title = "Difficulty",
    Description = "Choose the minigame difficulty",
    Values = {"Easy", "Medium", "Hard", "Insane"},
    Multi = false,
    Default = 1,
})

Dropdown:OnChanged(function(Value)
    selectedDifficulty = Value
end)

local AutoSkipCooldown = false

PetMatchSection:AddToggle("AutoSkipMinigameToggle", {
    Title = "Auto Skip Minigame",
    Default = false,
    Callback = function(state)
        AutoSkipCooldown = state
        if state then
            task.spawn(function()
                while AutoSkipCooldown do
                    local args = {
                        [1] = "SkipMinigameCooldown",
                        [2] = "Pet Match"
                    }

                    local success, err = pcall(function()
                        RemoteEvent:FireServer(unpack(args)) -- usa a variável global
                    end)

                    if not success then
                        warn("Erro ao tentar pular cooldown: ", err)
                    end

                    task.wait(5)
                end
            end)
        end
    end
})

local Toggle = PetMatchSection:AddToggle("StartMinigameToggle", {
    Title = "Auto Pet Match",
    Default = false,
    Callback = function(state)
        if state then
            local args = {
                [1] = "StartMinigame",
                [2] = "Pet Match",
                [3] = selectedDifficulty
            }

            RemoteEvent:FireServer(unpack(args))

            task.wait(2)

            local startTime = tick()
            while tick() - startTime < 5 do
                RemoteEvent:FireServer("FinishMinigame")
                task.wait(0.1) 
            end
        end
    end
})

local selectedDifficulty = "Easy" 
local autoRunning = false


local function startMinigame()
    local args = {
        [1] = "StartMinigame",
        [2] = "Robot Claw",
        [3] = selectedDifficulty
    }

    RemoteEvent:FireServer(unpack(args)) -- usa a variável global

    task.wait(1)
end

local function printCapsules()
    local clawMachineFolder = workspace:FindFirstChild("ClawMachine")
    if clawMachineFolder then
        for _, child in pairs(clawMachineFolder:GetChildren()) do
            if child.Name == "Capsule" then
                
                local itemGUID = child:GetAttribute("ItemGUID")
                if itemGUID then
                else

                    local itemGUIDObj = child:FindFirstChild("ItemGUID")
                    if itemGUIDObj then
                    end
                end
            end
        end
    end
end

local function grabCapsule()
    local clawMachineFolder = workspace:FindFirstChild("ClawMachine")
    
    if not clawMachineFolder then
        return false
    end

    local capsule = nil
    for _, obj in pairs(clawMachineFolder:GetChildren()) do
        if obj.Name == "Capsule" then
            capsule = obj
            break
        end
    end

    if capsule then

        local itemGUID = capsule:GetAttribute("ItemGUID")

        if not itemGUID then
            local itemGUIDObj = capsule:FindFirstChild("ItemGUID")
            if itemGUIDObj and itemGUIDObj.Value then
                itemGUID = itemGUIDObj.Value
            end
        end
        
        if itemGUID then
            local args = {
                [1] = "GrabMinigameItem",
                [2] = itemGUID
            }

            local success, error = pcall(function()
                RemoteEvent:FireServer(unpack(args)) -- usa a variável global
            end)
            
            if success then
            end

            task.wait(2)

            if capsule and capsule.Parent then
                capsule:Destroy()
            end
            
            return true
        else
            if capsule and capsule.Parent then
                capsule:Destroy()
            end
            return true
        end
    end
    
    return false 
end

local function capsuleExists()
    local clawMachineFolder = workspace:FindFirstChild("ClawMachine")
    
    if not clawMachineFolder then
        return false
    end
    
    for _, obj in pairs(clawMachineFolder:GetChildren()) do
        if obj.Name == "Capsule" then
            return true
        end
    end
    return false
end

local function finishMinigame()
    local args = {
        [1] = "FinishMinigame"
    }

    RemoteEvent:FireServer(unpack(args)) -- usando variável global
end

local function runFullCycle()
    if autoRunning then
        startMinigame() 

        task.wait(3)
        
        local maxAttempts = 20 
        local attempts = 0

        while capsuleExists() and autoRunning and attempts < maxAttempts do
            local gotCapsule = grabCapsule()
            attempts = attempts + 1
            
            if gotCapsule then
                task.wait(2)
            else
                task.wait(2)
            end
        end
        
        task.wait(1)
        
        if not capsuleExists() or attempts >= maxAttempts then
            finishMinigame() 

            task.wait(0.1)

            if autoRunning then
                runFullCycle()
            end
        else
            if autoRunning then
                runFullCycle()
            end
        end
    end
end

RobotClawSection:AddDropdown("DifficultySelector", {
    Title = "Select Difficulty",
    Description = "Choose the difficulty for the Robot Claw game",
    Values = {"Easy", "Medium", "Hard", "Insane"},
    Multi = false,
    Default = 1
}):OnChanged(function(value)
    selectedDifficulty = value
end)

local AutoSkipRobotClaw = false

RobotClawSection:AddToggle("AutoSkipRobotClawToggle", {
    Title = "Auto Skip Robot Claw",
    Default = false,
    Callback = function(state)
        AutoSkipRobotClaw = state
        if state then
            task.spawn(function()
                while AutoSkipRobotClaw do
                    local args = {
                        [1] = "SkipMinigameCooldown",
                        [2] = "Robot Claw"
                    }

                    local success, err = pcall(function()
                        RemoteEvent:FireServer(unpack(args)) -- usando a variável global
                    end)

                    if not success then
                        warn("Erro ao pular cooldown do Robot Claw:", err)
                    end

                    task.wait(5)
                end
            end)
        end
    end
})

RobotClawSection:AddToggle("StartMinigameToggle", {
    Title = "Auto Robot Claw",
    Default = false,
    Callback = function(state)
        autoRunning = state
        if autoRunning then
            runFullCycle()
        end
    end
})

local selectedPetUUID = nil
local selectedDices = {}
local autoRunning = false

local petsDropdown
local diceDropdown
local petsMap = {}

local function cleanUUID(rawName)
    return rawName:gsub("-stack", ""):gsub("-team%-%d+", ""):gsub("-%d+$", "")
end

local function refreshPets()
    petsMap = {}
    local petDropdownList = {}

    local petFolders = {
        player.PlayerGui.ScreenGui.Inventory.Frame.Inner.Pets.Main.ScrollingFrame.Pets,
        player.PlayerGui.ScreenGui.Inventory.Frame.Inner.Pets.Main.ScrollingFrame.Team.Main.List
    }

    for _, folder in pairs(petFolders) do
        for _, obj in pairs(folder:GetChildren()) do
            local uuid = cleanUUID(obj.Name)
            local displayNameGui = obj:FindFirstChild("Inner") and obj.Inner:FindFirstChild("Button") and obj.Inner.Button:FindFirstChild("Inner") and obj.Inner.Button.Inner:FindFirstChild("DisplayName")
            if displayNameGui and displayNameGui:IsA("TextLabel") then
                local displayName = displayNameGui.Text
                if not petsMap[displayName] then
                    petsMap[displayName] = uuid
                    table.insert(petDropdownList, displayName)
                end
            end
        end
    end

    if petsDropdown then
        petsDropdown:SetValues(petDropdownList)
    end
end

local function sendToServer(action, uuid)
    local args = {}

    if action == "ChoosePiece" then
        args = {
            [1] = "ChoosePiece",
            [2] = uuid
        }
    elseif action == "ClaimTile" then
        args = {
            [1] = "ClaimTile"
        }
    end

    RemoteEvent:FireServer(unpack(args))
end

local function rollDice(diceType)
    local args = {
        [1] = "RollDice",
        [2] = diceType
    }

    RemoteFunction:InvokeServer(unpack(args))
end

-- Pet dropdown (apenas 1)
petsDropdown = BoardGameSection:AddDropdown("PetSelector", {
    Title = "Select Pet",
    Description = "Choose a pet to use",
    Values = {},
    Multi = false,
    Default = nil
})

petsDropdown:OnChanged(function(value)
    selectedPetUUID = petsMap[value]
    if selectedPetUUID then
        sendToServer("ChoosePiece", selectedPetUUID)
    end
end)

-- Dice dropdown (multi)
diceDropdown = BoardGameSection:AddDropdown("DiceSelector", {
    Title = "Dice Types",
    Description = "Choose one or more dice types",
    Values = {"Dice", "Giant Dice", "Golden Dice"},
    Multi = true,
    Default = {}
})

diceDropdown:OnChanged(function(value)
    selectedDices = {}
    for diceName, isSelected in pairs(value) do
        if isSelected then
            table.insert(selectedDices, diceName)
        end
    end
    print("Selected dice types:", table.concat(selectedDices, ", "))
end)

-- Botão para atualizar pets
BoardGameSection:AddButton({
    Title = "🔄 Refresh Pets",
    Description = "Update pet list from inventory and team",
    Callback = function()
        refreshPets()
    end
})

-- Auto Dice Farm Toggle
BoardGameSection:AddToggle("AutoDiceToggle", {
    Title = "Auto Dice Farm",
    Default = false,
    Callback = function(state)
        autoRunning = state
        task.spawn(function()
            while autoRunning do
                if selectedPetUUID and #selectedDices > 0 then
                    sendToServer("ChoosePiece", selectedPetUUID)

                    for _, dice in ipairs(selectedDices) do
                        rollDice(dice)

                        local start = tick()
                        while tick() - start < 1 and autoRunning do
                            sendToServer("ClaimTile")
                            task.wait(0.1)
                        end

                        task.wait(0.5)
                    end
                end
                task.wait(0.5)
            end
        end)
    end
})

-- Atualiza lista inicialmente
refreshPets()

local Noclip = false
local NoclipConnection = nil

local function EnableNoclip()
    if NoclipConnection then NoclipConnection:Disconnect() end
    Noclip = true
    NoclipConnection = RunService.Stepped:Connect(function()
        if Noclip and LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function DisableNoclip()
    Noclip = false
    if NoclipConnection then
        NoclipConnection:Disconnect()
        NoclipConnection = nil
    end
end

local function GetEggNames()
    local keys = {}
    for eggName in pairs(EggTeleportMap) do
        table.insert(keys, eggName)
    end
    return keys
end

local EggDropdown = Egg:AddDropdown("EggDropdown", {
    Title = "Selecting Egg",
    Description = "Choose the egg you want to open",
    Values = GetEggNames(),
    Multi = false,
    Default = 1
})

EggDropdown:OnChanged(function(val)
    SelectedEgg = val
end)

local function TeleportToWorld(eggName)
    local teleportPath = EggTeleportMap[eggName]
    if teleportPath then
        RemoteEvent:FireServer("Teleport", teleportPath)
        return true
    end
    return false
end

local function CheckForValidRiftEggs()
    if not AutoRiftHatch then return false end

    if SelectedRiftEggs == nil then
        SelectedRiftEggs = {}
        return false
    end
    
    if #SelectedRiftEggs == 0 then return false end
    
    local Rifts = workspace:WaitForChild("Rendered"):WaitForChild("Rifts")
    for _, egg in pairs(Rifts:GetChildren()) do
        if egg:IsA("Model") and egg:FindFirstChild("Display") then
            local isSelectedEgg = false
            for _, selectedEgg in pairs(SelectedRiftEggs) do
                if egg.Name == selectedEgg then
                    isSelectedEgg = true
                    break
                end
            end
            
            if isSelectedEgg then
                local display = egg.Display
                local gui = display and display:FindFirstChildWhichIsA("SurfaceGui")
                local icon = gui and gui:FindFirstChild("Icon")
                local luck = icon and icon:FindFirstChildWhichIsA("TextLabel")

                if SelectedLuckMultipliers == nil then
                    SelectedLuckMultipliers = {}
                end
                
                local validMultiplier = #SelectedLuckMultipliers == 0
                if luck and luck.Text then
                    for _, multi in pairs(SelectedLuckMultipliers) do
                        if luck.Text == multi then
                            validMultiplier = true
                            break
                        end
                    end
                end
                
                if validMultiplier then
                    return true
                end
            end
        end
    end
    
    return false
end

local function StartNormalHatching()
    if IsProcessingNormalHatch then return end
    IsProcessingNormalHatch = true
    
    task.spawn(function()
        local target = EggPositions[SelectedEgg]
        if not target then
            IsProcessingNormalHatch = false
            return
        end

        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
        local Humanoid = Character:WaitForChild("Humanoid")

        local yDifference = math.abs(HumanoidRootPart.Position.Y - target.Y)
        local maxAttempts = 3
        local attempts = 0

        while yDifference > 3 and attempts < maxAttempts do
            attempts = attempts + 1

            TeleportToWorld(SelectedEgg)
            task.wait(2)
            
            Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
            yDifference = math.abs(HumanoidRootPart.Position.Y - target.Y)
        end
        
        Humanoid:MoveTo(target)
        local reached = false
        
        local connection
        connection = Humanoid.MoveToFinished:Connect(function(success)
            if success then 
                reached = true 
                if connection then
                    connection:Disconnect()
                end
            end
        end)

        while not reached and AutoHatch and not (AutoRiftHatch and CheckForValidRiftEggs()) do
            task.wait(0.5)
        end

        while AutoHatch and not (AutoRiftHatch and CheckForValidRiftEggs()) do
            pcall(function()
                RemoteEvent:FireServer("HatchEgg", SelectedEgg, HatchAmount)
            end)
            task.wait(0.5)
        end
        
        IsProcessingNormalHatch = false
    end)
end

Egg:AddToggle("AutoHatch", {
    Title = "Auto Hatch",
    Description = "Automatically opens eggs after walking to them",
    Default = false,
    Callback = function(state)
        AutoHatch = state
        
        if state then
            EnableNoclip()
            
            if not (AutoRiftHatch and CheckForValidRiftEggs()) then
                StartNormalHatching()
            end
        elseif not state then
            if not AutoRiftHatch then
                DisableNoclip()
            end
        end
    end
})

local Rifts = workspace:WaitForChild("Rendered"):WaitForChild("Rifts")

local IsHandlingRiftEgg = false
local NoClipEnabled = false
local originalGravity = workspace.Gravity
local PlayerImmobilized = false
local ImmobilizeConnection = nil

local RiftEggNames = {}
for k in pairs(EggNameMap) do
    table.insert(RiftEggNames, k)
end

local RiftEggDropdown = EggRift:AddDropdown("RiftEggDropdown", {
    Title = "Select Rift Eggs",
    Description = "Choose which eggs to hatch",
    Values = RiftEggNames,
    Multi = true,
    Default = {},
})

RiftEggDropdown:OnChanged(function(selectedTable)
    SelectedRiftEggs = {}
    for eggName, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedRiftEggs, eggName)
        end
    end
end)

local LuckMultiplierDropdown = EggRift:AddDropdown("LuckMultiplierDropdown", {
    Title = "Luck Multiplier",
    Description = "Select desired luck multipliers",
    Values = { "x5", "x7", "x10", "x25" },
    Multi = true,
    Default = {},
})

LuckMultiplierDropdown:OnChanged(function(selectedTable)
    SelectedLuckMultipliers = {}
    for multiplier, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedLuckMultipliers, multiplier)
        end
    end
end)

local function immobilizePlayer()
    if PlayerImmobilized then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local originalWalkSpeed = humanoid.WalkSpeed
    local originalJumpPower = humanoid.JumpPower
    local originalAutoRotate = humanoid.AutoRotate

    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    humanoid.AutoRotate = false

    if ImmobilizeConnection then
        ImmobilizeConnection:Disconnect()
    end
    
    ImmobilizeConnection = RunService.Heartbeat:Connect(function()
        if character and character:FindFirstChild("HumanoidRootPart") then
            character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            character.HumanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
            if humanoid then
                local animator = humanoid:FindFirstChildOfClass("Animator")
                if animator then
                    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                        if track.Name:lower():match("walk") or track.Name:lower():match("run") or track.Name:lower():match("jump") then
                            track:Stop()
                        end
                    end
                end
            end
        end
    end)
    
    PlayerImmobilized = true
end

local function restorePlayerMobility()
    if not PlayerImmobilized then return end
    
    if ImmobilizeConnection then
        ImmobilizeConnection:Disconnect()
        ImmobilizeConnection = nil
    end
    
    local character = LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = 16
            humanoid.JumpPower = 50
            humanoid.AutoRotate = true
        end
    end
    
    PlayerImmobilized = false
end

local function setPhysicsEnabled(enabled)
  if not LocalPlayer.Character then return end
  
  for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
      if part:IsA("BasePart") then
          part.CanCollide = enabled
          part.AssemblyLinearVelocity = Vector3.new()
          part.AssemblyAngularVelocity = Vector3.new()
      end
  end
  
  local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
  if humanoid then
      humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, enabled)
  end
end

local function enableNoClip()
    if NoClipConnection then return end
    
    NoClipConnection = RunService.Stepped:Connect(function()
        if LocalPlayer.Character then
            for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
    
    NoClipEnabled = true
end

local function disableNoClip()
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    
    if LocalPlayer.Character then
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    
    NoClipEnabled = false

    restorePlayerMobility()
end

local function teleportToEgg(egg)
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    local eggRealName = EggNameMap[egg.Name]
    if not eggRealName then return false end

    immobilizePlayer()
    
    local eggPos = egg:GetPivot().Position

    local yDifference = math.abs(hrp.Position.Y - eggPos.Y)
    local maxAttempts = 3
    local attempts = 0

    while yDifference > 3 and attempts < maxAttempts do
        attempts = attempts + 1

        TeleportToWorld(eggRealName)

        task.wait(2)

        hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then 
            restorePlayerMobility()
            return false 
        end
        
        yDifference = math.abs(hrp.Position.Y - eggPos.Y)
    end

    local originalPos = hrp.Position

    setPhysicsEnabled(false)
    hrp.CFrame = CFrame.new(originalPos.X, dropAltitude, originalPos.Z)
    
    local targetXZ = Vector3.new(eggPos.X, dropAltitude, eggPos.Z)
    local distance = (targetXZ - hrp.Position).Magnitude
    local duration = distance / moveSpeed
    
    local info = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
    local tween = TweenService:Create(hrp, info, {CFrame = CFrame.new(targetXZ)})
    
    tween:Play()
    tween.Completed:Wait()
    
    hrp.CFrame = CFrame.new(eggPos.X, eggPos.Y + 3, eggPos.Z)
    
    return true
end

local function hatchEgg(eggName)
    local args = {
        [1] = "HatchEgg",
        [2] = EggNameMap[eggName],
        [3] = 10
    }
    pcall(function()
        RemoteEvent:FireServer(unpack(args))
    end)
end

local function cancelAllOperations()
    for hrp, tween in pairs(ActiveTweens) do
        if tween then tween:Cancel() end
    end
    ActiveTweens = {}
    disableNoClip()
    restorePlayerMobility()
end

local function chooseNewTarget()
    if SelectedRiftEggs == nil then
        SelectedRiftEggs = {}
    end
    
    if #SelectedRiftEggs > 0 then
        CurrentTargetEgg = SelectedRiftEggs[math.random(1, #SelectedRiftEggs)]
    else
        local eggs = {}
        for k in pairs(EggNameMap) do table.insert(eggs, k) end
        CurrentTargetEgg = eggs[math.random(1, #eggs)]
    end

    if SelectedLuckMultipliers == nil then
        SelectedLuckMultipliers = {}
    end
    
    if #SelectedLuckMultipliers > 0 then
        CurrentTargetMultiplier = SelectedLuckMultipliers[math.random(1, #SelectedLuckMultipliers)]
    else
        CurrentTargetMultiplier = nil 
    end
end

EggRift:AddToggle("AutoRiftHatchToggle", {
    Title = "Auto Hatch (Rift)",
    Description = "Automatically teleport and hatch rift eggs when available",
    Default = false,
    Callback = function(state)
        AutoRiftHatch = state
        
        if state then
            enableNoClip() 
            
            chooseNewTarget()
            task.spawn(function()
                while AutoRiftHatch do
                    IsHandlingRiftEgg = false
                    local foundValidEgg = false
                    
                    for _, egg in pairs(Rifts:GetChildren()) do
                        if not AutoRiftHatch then break end
                        
                        local isSelectedEgg = false
                        if SelectedRiftEggs ~= nil then
                            for _, selectedEgg in pairs(SelectedRiftEggs) do
                                if egg.Name == selectedEgg then
                                    isSelectedEgg = true
                                    break
                                end
                            end
                        end
                        
                        if isSelectedEgg and egg:IsA("Model") and egg:FindFirstChild("Display") then
                            local display = egg.Display
                            local gui = display and display:FindFirstChildWhichIsA("SurfaceGui")
                            local icon = gui and gui:FindFirstChild("Icon")
                            local luck = icon and icon:FindFirstChildWhichIsA("TextLabel")
                            
                            if SelectedLuckMultipliers == nil then
                                SelectedLuckMultipliers = {}
                            end
                            
                            local validMultiplier = #SelectedLuckMultipliers == 0
                            if luck and luck.Text then
                                for _, multi in pairs(SelectedLuckMultipliers) do
                                    if luck.Text == multi then
                                        validMultiplier = true
                                        break
                                    end
                                end
                            end
                            
                            if validMultiplier then
                                foundValidEgg = true
                                IsHandlingRiftEgg = true
                                
                                task.wait(0.5)
                                if teleportToEgg(egg) then
                                    while AutoRiftHatch and egg.Parent do
                                        hatchEgg(egg.Name)
                                        task.wait(0.5)
                                    end
                                    
                                    restorePlayerMobility()
                                end
                                
                                break 
                            end
                        end
                    end
                    
                    if not foundValidEgg and AutoHatch and not IsProcessingNormalHatch then
                        restorePlayerMobility()
                        StartNormalHatching()
                    end
                    
                    if not foundValidEgg then
                        chooseNewTarget()
                        restorePlayerMobility()
                    end
                end
                
                if AutoHatch then
                    if not IsProcessingNormalHatch then
                        restorePlayerMobility() 
                        StartNormalHatching()
                    end
                else
                    disableNoClip() 
                    restorePlayerMobility() 
                end
            end)
        else
            IsHandlingRiftEgg = false
            
            for hrp, tween in pairs(ActiveTweens) do
                if tween then tween:Cancel() end
            end
            ActiveTweens = {}
            
            if AutoHatch then
                if not IsProcessingNormalHatch then
                    restorePlayerMobility()
                    StartNormalHatching()
                end
            else
                disableNoClip()
                restorePlayerMobility()
            end
        end
    end
})

local UNLOCK_DELAY = 0.1
local DEFAULT_GRAVITY = Workspace.Gravity

local NoClipConnection
local ImmobilizeConnection
local PlayerImmobilized = false

local AutoGoldenChest = false
local AutoRoyalChest = false
local AutoDiceRift = false

local function setGravity(enabled)
    Workspace.Gravity = enabled and DEFAULT_GRAVITY or 0
end

local function immobilizePlayer()
    if PlayerImmobilized then return end

    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    humanoid.AutoRotate = false

    if ImmobilizeConnection then
        ImmobilizeConnection:Disconnect()
    end

    ImmobilizeConnection = RunService.Heartbeat:Connect(function()
        if character and character:FindFirstChild("HumanoidRootPart") then
            character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            character.HumanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
        end
    end)

    PlayerImmobilized = true
end

local function restorePlayerMobility()
    if not PlayerImmobilized then return end

    if ImmobilizeConnection then
        ImmobilizeConnection:Disconnect()
        ImmobilizeConnection = nil
    end

    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = 16
            humanoid.JumpPower = 50
            humanoid.AutoRotate = true
        end
    end

    PlayerImmobilized = false
end

local function manageNoClip(enable)
    if enable then
        if NoClipConnection then return end
        NoClipConnection = RunService.Stepped:Connect(function()
            if player.Character then
                for _, part in ipairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if NoClipConnection then
            NoClipConnection:Disconnect()
            NoClipConnection = nil
        end
    end
end

local function getChestPosition(chest)
    local outputPart = chest:FindFirstChild("Output")
    if outputPart then
        return outputPart.Position
    end
    return chest:GetPivot().Position
end

local function safeTeleportToChest(chestName)
    while (chestName == "golden-chest" and AutoGoldenChest) or
          (chestName == "royal-chest" and AutoRoyalChest) do
        local chest = workspace.Rendered.Rifts:FindFirstChild(chestName)
        if chest then
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                immobilizePlayer()
                manageNoClip(true)
                setGravity(false)

                local chestPos = getChestPosition(chest)

                hrp.CFrame = CFrame.new(hrp.Position.X, dropAltitude, hrp.Position.Z)

                local targetXZ = Vector3.new(chestPos.X, dropAltitude, chestPos.Z)
                local tween = TweenService:Create(hrp, TweenInfo.new((targetXZ - hrp.Position).Magnitude / moveSpeed, Enum.EasingStyle.Linear), {
                    CFrame = CFrame.new(targetXZ)
                })
                tween:Play()
                tween.Completed:Wait()

                hrp.CFrame = CFrame.new(chestPos.X, chestPos.Y + claimAltitude, chestPos.Z)

                while ((chestName == "golden-chest" and AutoGoldenChest) or
                      (chestName == "royal-chest" and AutoRoyalChest)) and chest.Parent do
                    RemoteEvent:FireServer("UnlockRiftChest", chestName)
                    task.wait(UNLOCK_DELAY)
                end

                restorePlayerMobility()
                manageNoClip(false)
                setGravity(true)
            end
        end
        task.wait(1)
    end

    restorePlayerMobility()
    manageNoClip(false)
    setGravity(true)
end

local function safeTeleportToRift(riftName)
    while (riftName == "dice-rift" and AutoDiceRift) do
        local rift = workspace.Rendered.Rifts:FindFirstChild(riftName)
        if rift then
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                immobilizePlayer()
                manageNoClip(true)
                setGravity(false)

                local riftPos = getChestPosition(rift)

                hrp.CFrame = CFrame.new(hrp.Position.X, dropAltitude, hrp.Position.Z)

                local targetXZ = Vector3.new(riftPos.X, dropAltitude, riftPos.Z)
                local tween = TweenService:Create(hrp, TweenInfo.new((targetXZ - hrp.Position).Magnitude / moveSpeed, Enum.EasingStyle.Linear), {
                    CFrame = CFrame.new(targetXZ)
                })
                tween:Play()
                tween.Completed:Wait()

                hrp.CFrame = CFrame.new(riftPos.X, riftPos.Y + claimAltitude, riftPos.Z)

                while AutoDiceRift and rift.Parent do
                    RemoteEvent:FireServer("UnlockRiftChest", riftName)
                    task.wait(UNLOCK_DELAY)
                end

                restorePlayerMobility()
                manageNoClip(false)
                setGravity(true)
            end
        end
        task.wait(1)
    end

    restorePlayerMobility()
    manageNoClip(false)
    setGravity(true)
end

ChestHunt:AddToggle("AutoGoldenChestToggle", {
    Title = "Auto Golden Chest",
    Default = false,
    Callback = function(state)
        AutoGoldenChest = state
        if state then
            task.spawn(safeTeleportToChest, "golden-chest")
        else
            restorePlayerMobility()
            setGravity(true)
        end
    end
})

ChestHunt:AddToggle("AutoRoyalChestToggle", {
    Title = "Auto Royal Chest",
    Default = false,
    Callback = function(state)
        AutoRoyalChest = state
        if state then
            task.spawn(safeTeleportToChest, "royal-chest")
        else
            restorePlayerMobility()
            setGravity(true)
        end
    end
})

ChestHunt:AddToggle("AutoDiceRiftToggle", {
    Title = "Auto Dice Rift",
    Default = false,
    Callback = function(state)
        AutoDiceRift = state
        if state then
            task.spawn(safeTeleportToRift, "dice-rift")
        else
            restorePlayerMobility()
            setGravity(true)
        end
    end
})

local noClipConnection = nil

local function getHRP()
    local character = player.Character or player.CharacterAdded:Wait()
    return character:WaitForChild("HumanoidRootPart")
end

local function setNoClip(enabled)
    if enabled then
        if not noClipConnection then
            noClipConnection = RunService.Stepped:Connect(function()
                if player.Character then
                    for _, part in ipairs(player.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if noClipConnection then
            noClipConnection:Disconnect()
            noClipConnection = nil
        end
    end
end

local function findGiftRift()
    local gift = Workspace:FindFirstChild("Rendered", true) and 
                Workspace.Rendered:FindFirstChild("Rifts") and 
                Workspace.Rendered.Rifts:FindFirstChild("gift-rift")
    
    if gift then return gift end
    
    for _, child in pairs(Workspace:GetDescendants()) do
        if child.Name == "Rifts" then
            gift = child:FindFirstChild("gift-rift")
            if gift then return gift end
        end
    end
    
    for _, obj in pairs(Workspace:GetDescendants()) do
        if (obj.Name:lower():find("gift") and obj.Name:lower():find("rift")) or 
           obj.Name:lower() == "gift-rift" then
            return obj
        end
    end
    
    return nil
end

local function teleportTo(position)
    local hrp = getHRP()
    hrp.CFrame = CFrame.new(position)
end

local function giftRiftLoop()
    while autoGiftRiftEnabled do
        local gift = findGiftRift()
        
        if gift then
            local giftPosition = gift:GetPivot().Position
            local hrp = getHRP()
            local originalPosition = hrp.Position
            
            setNoClip(true)
            
            teleportTo(Vector3.new(originalPosition.X, dropAltitude, originalPosition.Z))
            task.wait(0.1)
            
            teleportTo(Vector3.new(giftPosition.X, dropAltitude, giftPosition.Z))
            task.wait(0.1)

            teleportTo(Vector3.new(giftPosition.X, claimAltitude, giftPosition.Z))
            
            local attempts = 0
            while autoGiftRiftEnabled and gift.Parent and attempts < maxClaimAttempts do
                attempts = attempts + 1
                
                RemoteEvent:FireServer("ClaimRiftGift", "gift-rift")
                
                if gift:FindFirstChild("Gift") then
                    gift.Gift:Destroy()
                end
                
                if gift and gift.Parent then
                    gift:Destroy()
                end
                
                task.wait(claimAttemptDelay)
                
                if not gift.Parent then
                    break
                end
            end
            
            teleportTo(Vector3.new(giftPosition.X, dropAltitude, giftPosition.Z))
            task.wait(0.1)
            teleportTo(Vector3.new(originalPosition.X, dropAltitude, originalPosition.Z))
            task.wait(0.1)
            teleportTo(Vector3.new(originalPosition.X, originalPosition.Y, originalPosition.Z))
            
            setNoClip(false)
        end
        
        task.wait(searchInterval)
    end
end

local function toggleAutoGiftRift(enabled)
    autoGiftRiftEnabled = enabled
    
    if enabled then
        task.spawn(giftRiftLoop)
    else
        setNoClip(false)
    end
end

GiftHunt:AddToggle("AutoGiftRiftToggle", {
    Title = "Auto Gift Rift",
    Description = "Automatically claims gift rifts",
    Default = false,
    Callback = function(Value)
        toggleAutoGiftRift(Value)
    end
})

Tabs.Upgrades:AddToggle("AutoUpgrade", {
    Title = "Auto Upgrade Mastery for Buffs",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgrade = state
        if state then
            spawn(function()
                while AutoUpgrade do
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Buffs"
                    }

                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)
                end
            end)
        else
            getgenv().AutoUpgrade = false
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgradePets", {
    Title = "Auto Upgrade Mastery for Pets",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgradePets = state
        if state then
            spawn(function()
                while AutoUpgradePets do
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Pets"  
                    }

                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)  
                end
            end)
        else
            getgenv().AutoUpgradePets = false
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgradeShops", {
    Title = "Auto Upgrade Mastery for Shops",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgradeShops = state 
        if state then
            spawn(function()  
                while AutoUpgradeShops do  
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Shops"  
                    }

                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1) 
                end
            end)
        else
            getgenv().AutoUpgradeShops = false
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgradeShops", {
    Title = "Auto Upgrade Mastery for Minigames",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgradeShops = state 
        if state then
            spawn(function()  
                while AutoUpgradeShops do  
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Minigames"  
                    }

                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1) 
                end
            end)
        else
            getgenv().AutoUpgradeShops = false
        end
    end
})

local potionList = {}
local dropdownOptions = {}

local potionNames = {"Coins", "Lucky", "Speed", "Mythic"}
local tiers = {1, 2, 3, 4, 5,}
local roman = {"I", "II", "III", "IV", "V"}

for _, potion in ipairs(potionNames) do
    for i, tier in ipairs(tiers) do
        local displayName = potion .. " " .. roman[i]
        potionList[displayName] = {potion, tier}
        table.insert(dropdownOptions, displayName)
    end
end

local MultiDropdown = AutoPotionSection:AddDropdown("Poções", {
    Title = "Selecting Potions",
    Description = "Choose the potions to use",
    Values = dropdownOptions,
    Multi = true,
    Default = {}, 
})

local SelectedPotions = {}

MultiDropdown:OnChanged(function(Value)
    SelectedPotions = {}
    for potion, _ in pairs(Value) do
        table.insert(SelectedPotions, potion)
    end

end)

AutoPotionSection:AddToggle("Auto Usar Poções", {
    Title = "Auto Use Potion",
    Description = "Enables automatic use of selected potions",
    Default = false,
    Callback = function(state)
        getgenv().AutoPotion = state

        if state then
            task.spawn(function()
                while getgenv().AutoPotion do
                    if #SelectedPotions == 0 then
                        Fluent:Notify({
                            Title = "Warn",
                            Content = "No potions selected.",
                            Duration = 4
                        })
                        break
                    end

                    for _, displayName in ipairs(SelectedPotions) do
                        local data = potionList[displayName]
                        if data then
                            local name, tier = unpack(data)
                            pcall(function()
                                RemoteEvent:FireServer("UsePotion", name, tier)
                            end)
                            task.wait(0.5)
                        else
                            warn("Potion invalid:", displayName)
                        end
                    end

                    task.wait(0.5)
                end
            end)
        end
    end
})

local potionList = {}
local dropdownOptions = {}

local potionNames = {"Coins", "Lucky", "Speed", "Mythic"}
local tiers = {2, 3, 4, 5}
local roman = {"II", "III", "IV", "V"}

for _, potion in ipairs(potionNames) do
    for i, tier in ipairs(tiers) do
        local displayName = potion .. " " .. roman[i]
        potionList[displayName] = {potion, tier}
        table.insert(dropdownOptions, displayName)
    end
end

local MultiDropdown = AutoCraftPotionSection:AddDropdown("Poções", {
    Title = "Selecting Potions to Craft",
    Description = "Choose the potions and tiers you want to craft",
    Values = dropdownOptions,
    Multi = true,
    Default = {},
})

local SelectedPotions = {}

MultiDropdown:OnChanged(function(Value)
    SelectedPotions = {}
    for potion, _ in pairs(Value) do
        table.insert(SelectedPotions, potion)
    end
end)

AutoCraftPotionSection:AddToggle("Auto Craft Poções", {
    Title = "Auto Craft Potion",
    Description = "Automatically brews selected potions",
    Default = false,
    Callback = function(state)
        getgenv().AutoCraftPotion = state

        if state then
            task.spawn(function()
                while getgenv().AutoCraftPotion do
                    if #SelectedPotions == 0 then
                        Fluent:Notify({
                            Title = "Warn",
                            Content = "No potions selected for crafting.",
                            Duration = 4
                        })
                        break
                    end

                    for _, displayName in ipairs(SelectedPotions) do
                        local data = potionList[displayName]
                        if data then
                            local name, tier = unpack(data)
                            pcall(function()
                                RemoteEvent:FireServer("CraftPotion", name, tier, false)
                            end)
                            task.wait(0.1)
                        else
                            warn("Potion invalid:", displayName)
                        end
                    end

                    task.wait(0.1)
                end
            end)
        end
    end
})

local Rifts = workspace:WaitForChild("Rendered"):WaitForChild("Rifts")

local request = (syn and syn.request) or (http and http.request) or http_request or (krnl and krnl.request)
if not request then
    Fluent:Notify({
        Title = "Erro de Compatibilidade",
        Content = "Seu executor não suporta requisições HTTP (server hop não funcionará).",
        SubContent = "Use AWP, Wave ou outro com suporte a request.",
        Duration = 8
    })
    return
end

local function serverHop()
    local response = request({
        Url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100",
        Method = "GET"
    })

    if response and response.Body then
        local data = HttpService:JSONDecode(response.Body)
        for _, server in ipairs(data.data) do
            if server.playing < server.maxPlayers and server.id ~= game.JobId then
                TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id, LocalPlayer)
                return
            end
        end
    else
        warn("Falha ao buscar servidores.")
    end
end

local RiftEggNames = {}
for k in pairs(EggNameMap) do
    table.insert(RiftEggNames, k)
end

local RiftEggDropdown = Tabs.ServerHop:AddDropdown("RiftEggDropdown", {
    Title = "Select Rift Eggs",
    Description = "Choose which eggs to hatch",
    Values = RiftEggNames,
    Multi = true,
    Default = {},
})

RiftEggDropdown:OnChanged(function(selectedTable)
    SelectedRiftEggs = {}
    for eggName, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedRiftEggs, eggName)
        end
    end
end)

local LuckMultiplierDropdown = Tabs.ServerHop:AddDropdown("LuckMultiplierDropdown", {
    Title = "Luck Multiplier",
    Description = "Select desired luck multipliers",
    Values = { "x5", "x7", "x10", "x25" },
    Multi = true,
    Default = {},
})

LuckMultiplierDropdown:OnChanged(function(selectedTable)
    SelectedLuckMultipliers = {}
    for multiplier, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedLuckMultipliers, multiplier)
        end
    end
end)

local function enableNoClip()
    if NoClipConnection then return end
    NoClipConnection = RunService.Stepped:Connect(function()
        if LocalPlayer.Character then
            for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function disableNoClip()
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    if LocalPlayer.Character then
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

local function teleportToEgg(egg)
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    if ActiveTweens[hrp] then ActiveTweens[hrp]:Cancel() end
    enableNoClip()

    local targetCFrame = CFrame.new(egg:GetPivot().Position + Vector3.new(0, 3, 0))
    local tween = TweenService:Create(hrp, TweenInfo.new(6, Enum.EasingStyle.Linear), {CFrame = targetCFrame})
    ActiveTweens[hrp] = tween

    tween:Play()
    local success = pcall(function()
        tween.Completed:Wait()
    end)

    ActiveTweens[hrp] = nil
    return success
end

local function hatchEgg(eggName)
    local args = {
        [1] = "HatchEgg",
        [2] = EggNameMap[eggName],
        [3] = 10
    }
    pcall(function()
        RemoteEvent:FireServer(unpack(args))
    end)
end

local function cancelAllOperations()
    for hrp, tween in pairs(ActiveTweens) do
        if tween then tween:Cancel() end
    end
    ActiveTweens = {}
    disableNoClip()
end

local function chooseNewTarget()
    if #SelectedRiftEggs > 0 then
        CurrentTargetEgg = SelectedRiftEggs[math.random(1, #SelectedRiftEggs)]
    else
        local eggs = {}
        for k in pairs(EggNameMap) do table.insert(eggs, k) end
        CurrentTargetEgg = eggs[math.random(1, #eggs)]
    end

    if #SelectedLuckMultipliers > 0 then
        CurrentTargetMultiplier = SelectedLuckMultipliers[math.random(1, #SelectedLuckMultipliers)]
    else
        CurrentTargetMultiplier = nil
    end
end

Tabs.ServerHop:AddToggle("AutoRiftHatchToggle", {
    Title = "Auto Server Hop",
    Default = false,
    Callback = function(state)
        AutoRiftHatch = state
        if state then
            chooseNewTarget()
            task.spawn(function()
                while AutoRiftHatch do
                    local found = false
                    for _, egg in pairs(Rifts:GetChildren()) do
                        if not AutoRiftHatch then break end
                        if egg:IsA("Model") and egg:FindFirstChild("Display") and egg.Name == CurrentTargetEgg then
                            local gui = egg.Display:FindFirstChildWhichIsA("SurfaceGui")
                            local icon = gui and gui:FindFirstChild("Icon")
                            local luck = icon and icon:FindFirstChildWhichIsA("TextLabel")
                            if luck and luck.Text then
                                local validMultiplier = not CurrentTargetMultiplier or luck.Text == CurrentTargetMultiplier
                                if validMultiplier then
                                    found = true
                                    task.wait(2)
                                    if teleportToEgg(egg) then
                                        while AutoRiftHatch and egg.Parent do
                                            hatchEgg(egg.Name)
                                            task.wait(0.5)
                                        end
                                    end
                                end
                            end
                        end
                    end

                    if not found then
                        warn("[Auto Hatch] Nenhum ovo com multiplicador desejado. Fazendo server hop...")
                        serverHop()
                        task.wait(10)
                    end

                    task.wait(0.5)
                end
                disableNoClip()
            end)
        else
            cancelAllOperations()
        end
    end
})

for name, path in pairs(portalLocations) do
    Tabs.Teleport:AddButton({
        Title = name,
        Callback = function()
            RemoteEvent:FireServer("Teleport", path)

            Fluent:Notify({
                Title = "Teleport",
                Content = "Teleported to: " .. name,
                Duration = 3
            })
        end
    })
end

CodeSection:AddButton({
    Title = "Redeem Codes",
    Description = "Redeem all available codes",
    Callback = function()      
        for _, code in ipairs(codes) do
            local success, result = pcall(function()
                return RemoteFunction:InvokeServer("RedeemCode", code)
            end)
            if not success then
                warn("Error redeeming code:", code, result)
            end
            task.wait(2)
        end
    end
})

local AntiAfkConfig = {
    connection = nil
}

function AntiAfkConfig:Toggle(state)
    local player = game:GetService("Players").LocalPlayer
    if state then
        self.connection = player.Idled:Connect(function()
            local vu = game:GetService("VirtualUser")
            vu:CaptureController()
            vu:ClickButton2(Vector2.new())
        end)
    else
        if self.connection then
            self.connection:Disconnect()
            self.connection = nil
        end
    end
end

function AntiAfkConfig:Unload()
    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end
end

local Toggle = Tabs.Misc:AddToggle("MyToggle", {
    Title = "Anti AFK", 
    Default = false,
    Callback = function(state)
        if state then
            AntiAfkConfig:Toggle(true)
        else
            AntiAfkConfig:Toggle(false)
        end
    end
})

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/BubbleGumInfinity")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
Window:SelectTab(1)
Fluent:Notify({
    Title = "Bubble Gum Simulator INFINITY | DZ HUB",
    Content = "Script loaded successfully!",
    Duration = 5
})

local ExistingGui = CoreGui:FindFirstChild("MinimizeButtonGui")
if ExistingGui then ExistingGui:Destroy() end

local ScreenGuiToMinimize
for _, gui in ipairs(CoreGui:GetChildren()) do
    if gui:IsA("ScreenGui") then
        for _, descendant in ipairs(gui:GetDescendants()) do
            if descendant:IsA("TextLabel") and descendant.Text == "Bubble Gum Simulator INFINITY | DZ HUB" then
                ScreenGuiToMinimize = gui
                break
            end
        end
    end
    if ScreenGuiToMinimize then break end
end

if not ScreenGuiToMinimize then
    warn("ScreenGui com o texto especificado não encontrado.")
    return
end

local MinimizeGui = Instance.new("ScreenGui", CoreGui)
MinimizeGui.Name = "MinimizeButtonGui"

local MinimizeButton = Instance.new("ImageButton", MinimizeGui)
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Size = UDim2.new(0, 50, 0, 50)
MinimizeButton.Position = UDim2.new(0.1, 0, 0.1, 0)
MinimizeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.BorderSizePixel = 0
MinimizeButton.ImageRectSize = Vector2.new(256, 256)

local UICorner = Instance.new("UICorner", MinimizeButton)

local spritesheets = {
    "rbxassetid://90726870075493",
    "rbxassetid://85859195506939",
    "rbxassetid://140138471003989",
    "rbxassetid://92694094525674"
}

local frameWidth, frameHeight = 256, 256
local framesPerSheet = 4
local totalFrames = #spritesheets * framesPerSheet
local currentFrame = 0

MinimizeButton.Image = spritesheets[1]

task.spawn(function()
    while true do
        currentFrame = (currentFrame + 1) % totalFrames
        local sheetIndex = math.floor(currentFrame / framesPerSheet) + 1
        local frameIndex = currentFrame % framesPerSheet

        MinimizeButton.Image = spritesheets[sheetIndex]
        MinimizeButton.ImageRectOffset = Vector2.new(frameIndex * frameWidth, 0)

        task.wait(0.01) 
    end
end)

MinimizeButton.MouseButton1Click:Connect(function()
    if Window and Window.Minimize then
        Window:Minimize()
    else
        warn("Minimize function not available")
    end
end)

local dragging = false
local dragStart, startPos

local function update(input)
    local delta = input.Position - dragStart
    MinimizeButton.Position = UDim2.new(
        startPos.X.Scale,
        startPos.X.Offset + delta.X,
        startPos.Y.Scale,
        startPos.Y.Offset + delta.Y
    )
end

MinimizeButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MinimizeButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

MinimizeButton.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        update(input)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        update(input)
    end
end)
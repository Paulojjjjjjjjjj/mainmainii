local Fluent = loadstring(game:HttpGet("https://github.com/Dexz00/DZ-Ui/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Dexz00/DZ-Ui/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Dexz00/DZ-Ui/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Bubble Gum Simulator INFINITY | DZ HUB",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false,
    Theme = "Amethyst",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ 
        Title = "Main",
        Icon = "rbxassetid://124620632231839"
    }),
    AutoTask = Window:AddTab({ 
        Title = "Auto Task",
        Icon = "mail-question"
    }),
    EggHunt = Window:AddTab({ 
        Title = "Egg / Hunt",
        Icon = "egg"
    }),
    Upgrades = Window:AddTab({ 
        Title = "Upgrades",
        Icon = "arrow-big-up"
    }),
    Potions = Window:AddTab({ 
        Title = "Potions",
        Icon = "glass-water"
    }),
    Teleport = Window:AddTab({ 
        Title = "Teleport",
        Icon = "rbxassetid://12689978575"
    }),
    ServerHop = Window:AddTab({ 
        Title = "Server Hop",
        Icon = "server"
    }),
    Misc = Window:AddTab({ 
        Title = "Misc",
        Icon = "scroll"
    }),
    Settings = Window:AddTab({ 
        Title = "Settings",
        Icon = "settings"
    })
}

local AutoBlow = false
local AutoSell = false
local AutoHatch = false
local SelectedEgg = "Iceshard Egg"
local HatchAmount = 1

local SellOptions = Tabs.Main:AddSection("Sell Options")
local BlowSection = Tabs.Main:AddSection("Bubble + Sell Automation")
local CollectSection = Tabs.Main:AddSection("Auto Collect")
local UtilitiesSection = Tabs.Main:AddSection("Utilities")
local Egg = Tabs.EggHunt:AddSection("Egg")
local EggRift = Tabs.EggHunt:AddSection("Egg Rift")
local ChestHunt = Tabs.EggHunt:AddSection("Chest Hunt")
local GiftHunt = Tabs.EggHunt:AddSection("Gift Hunt")
local AutoPotionSection = Tabs.Potions:AddSection("Auto Use Potion")
local AutoCraftPotionSection = Tabs.Potions:AddSection("Auto Craft Potion")
local TeleportSection = Tabs.Teleport:AddSection("Unlock All Islands")
local CodeSection = Tabs.Misc:AddSection("Codes") 

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer

local AutoBlow = false
BlowSection:AddToggle("AutoBlow", {
    Title = "Auto Blow",
    Description = "Automatically blows the bubble",
    Default = false,
    Callback = function(state)
        AutoBlow = state
        if state then
            task.spawn(function()
                local lastBlowTime = 0
                local remote = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")
                while AutoBlow do
                    if tick() - lastBlowTime >= 0.1 then
                        pcall(function()
                            remote:FireServer("BlowBubble")
                        end)
                        lastBlowTime = tick()
                    end
                    task.wait(0.5)
                end
            end)
        end
    end
})

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- Configurações dos multiplicadores
local Multipliers = {
    ["2x"] = {
        position = Vector3.new(77.64643859863281, 8.919782638549805, -113.40311431884766),
        size = Vector3.new(10, 1, 10)
    },
    ["5x"] = {
        position = Vector3.new(-70.8243179321289, 6862.2060546875, 116.41088104248047),
        size = Vector3.new(10, 1, 10)
    },
    ["250x"] = {
        position = Vector3.new(-326.694946, 25.6819572, 191.227875),
        size = Vector3.new(10, 1, 10)
    }
}

-- Variáveis de controle
local platform = nil
local selectedMultiplier = "2x"
local moveSpeed = 18
local dropAltitude = -100
local sellMethod = "Storage Full"
local timedInterval = 120
local autoFarmEnabled = false
local lastSell = os.clock()
local isSelling = false
local maxSellAttempts = 10 -- Número máximo de tentativas de venda
local sellAttemptDelay = 0.5 -- Tempo entre tentativas de venda

-- Referência do Remote Event
local remoteEvent = ReplicatedStorage:WaitForChild("Shared")
    :WaitForChild("Framework")
    :WaitForChild("Network")
    :WaitForChild("Remote")
    :WaitForChild("Event")

-- Armazena o estado original para restauração
local originalGravity = Workspace.Gravity
local originalPhysics = true
local originalHRPProperties = {}

-- Helper: espera personagem e HRP
local function getHRP()
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    
    -- Salva propriedades originais na primeira vez
    if not originalHRPProperties.size then
        originalHRPProperties.size = hrp.Size
        originalHRPProperties.customPhysicalProperties = hrp.CustomPhysicalProperties
    end
    
    return hrp
end

-- Função para desativar/reativar a física
local function setPhysicsEnabled(enabled)
    local char = player.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, enabled)
        end
        
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.AssemblyLinearVelocity = Vector3.new()
                part.AssemblyAngularVelocity = Vector3.new()
                part.CustomPhysicalProperties = enabled and originalHRPProperties.customPhysicalProperties or PhysicalProperties.new(0, 0, 0)
            end
        end
    end
end

-- Cria a plataforma no multiplicador selecionado
local function createPlatform()
    if platform then
        platform:Destroy()
    end
    
    local config = Multipliers[selectedMultiplier]
    
    platform = Instance.new("Part")
    platform.Name = "TempPlatform"
    platform.Size = config.size
    platform.Anchored = true
    platform.CanCollide = true
    platform.Position = config.position
    platform.Transparency = 1
    platform.CastShadow = false
    platform.Parent = Workspace
end

-- Teleporta para altitude abaixo
local function teleportToBelow(pos)
    local hrp = getHRP()
    setPhysicsEnabled(false)
    hrp.CFrame = CFrame.new(pos.X, dropAltitude, pos.Z)
end

-- Tween lateral até posição alvo (mantém Y)
local function tweenToPositionXZ(targetPos)
    local hrp = getHRP()
    local startPos = hrp.Position
    local targetXZ = Vector3.new(targetPos.X, startPos.Y, targetPos.Z)
    local distance = (targetXZ - startPos).Magnitude
    local duration = distance / moveSpeed

    setPhysicsEnabled(false)
    
    local info = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
    local tween = TweenService:Create(hrp, info, {CFrame = CFrame.new(targetXZ)})
    
    local conn = RunService.Heartbeat:Connect(function()
        hrp.AssemblyLinearVelocity = Vector3.new()
        hrp.AssemblyAngularVelocity = Vector3.new()
    end)
    
    tween:Play()
    tween.Completed:Wait()
    conn:Disconnect()
end

-- Função para obter a capacidade atual de bolhas
local function getBubbleStorage()
    local playerGui = player:FindFirstChild("PlayerGui")
    if not playerGui then return 0, 0 end
    
    local label = playerGui
        :FindFirstChild("ScreenGui")
        :FindFirstChild("HUD")
        :FindFirstChild("Left")
        :FindFirstChild("Currency")
        :FindFirstChild("Bubble")
        :FindFirstChild("Frame")
        :FindFirstChild("Label")
    
    if not label then return 0, 0 end
    
    local txt = label.ContentText or label.Text
    local curStr, maxStr = txt:match("([%d,]+)%s*/%s*([%d,]+)")
    local cleanCurStr = curStr and curStr:gsub(",", "") or "0"
    local cleanMaxStr = maxStr and maxStr:gsub(",", "") or "0"
    local cur = tonumber(cleanCurStr) or 0
    local max = tonumber(cleanMaxStr) or 0
    
    return cur, max
end

-- Teleporta para topo da plataforma e dispara o evento de venda
local function teleportAndSell(pos)
    local hrp = getHRP()
    local yOffset = (hrp.Size.Y / 2) + (Multipliers[selectedMultiplier].size.Y / 2)
    local targetPos = pos + Vector3.new(0, yOffset, 0)
    
    setPhysicsEnabled(false)
    hrp.CFrame = CFrame.new(targetPos)
    
    -- Verifica se chegou na altura correta e dispara o evento
    if math.abs(hrp.Position.Y - targetPos.Y) < 5 then
        remoteEvent:FireServer("SellBubble")
    end
    
    task.delay(0.5, function()
        setPhysicsEnabled(true)
    end)
end

-- Restaura todas as configurações originais
local function restoreOriginalSettings()
    -- Restaura gravidade
    Workspace.Gravity = originalGravity
    
    -- Restaura física do personagem
    setPhysicsEnabled(true)
    
    -- Restaura propriedades do HRP
    local char = player.Character
    if char then
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CustomPhysicalProperties = originalHRPProperties.customPhysicalProperties
        end
    end
end

-- Função para vender as bolhas usando o sistema de teleporte
-- com verificação contínua até o armazenamento estar vazio
local function sellBubblesWithMultiplier()
    if isSelling then return end
    isSelling = true
    
    -- Não desativamos mais o autoFarm, apenas marcamos que estamos vendendo
    -- para que o autoFarmTick não tente soprar bolhas durante a venda
    local wasAutoFarmEnabled = autoFarmEnabled
    
    -- Armazena a posição original
    local originalPos = getHRP().Position
    
    -- Cria a plataforma no multiplicador selecionado
    createPlatform()
    
    -- Vai até a plataforma
    teleportToBelow(originalPos)
    tweenToPositionXZ(Multipliers[selectedMultiplier].position)
    
    -- Tentativas de venda até esvaziar o armazenamento
    local attempts = 0
    local currentBubbles = 1  -- Inicia com valor não zero para entrar no loop
    
    while currentBubbles > 0 and attempts < maxSellAttempts do
        attempts = attempts + 1
        
        -- Teleporta e vende
        teleportAndSell(Multipliers[selectedMultiplier].position)
        
        -- Aguarda um pouco para que a venda seja processada
        wait(sellAttemptDelay)
        
        -- Verifica a quantidade atual de bolhas
        currentBubbles, _ = getBubbleStorage()

        -- Se ainda não conseguiu vender todas as bolhas, tenta novamente
        if currentBubbles <= 0 then
            break
        elseif attempts >= maxSellAttempts then
        end
    end
    
    -- Volta para posição original
    teleportToBelow(Multipliers[selectedMultiplier].position)
    tweenToPositionXZ(originalPos)
    teleportAndSell(originalPos)
    
    -- Mantém a plataforma antes de destruir
    wait(1)
    if platform then
        platform:Destroy()
        platform = nil
    end
    
    -- Restaura configurações originais
    restoreOriginalSettings()
    
    -- Atualiza o timestamp da última venda e marca como não vendendo mais
    lastSell = os.clock()
    isSelling = false
    
    if autoFarmEnabled then
    end
end

-- Função que executa um ciclo do autofarm (sem usar thread)
local function autoFarmTick()
    if not autoFarmEnabled then return end
    
    -- Se estiver vendendo, não executa a ação de soprar bolha, mas continua o loop
    if not isSelling then
        -- Executa uma ação de soprar bolha
        remoteEvent:FireServer("BlowBubble")
        
        -- Pega informações da capacidade atual
        local cur, max = getBubbleStorage()
        
        -- Verifica condições para vender
        if sellMethod == "Storage Full" and cur > 0 and cur == max then
            task.spawn(sellBubblesWithMultiplier) -- Usa task.spawn para não bloquear o loop principal
        elseif sellMethod == "Timed" and os.clock() - lastSell >= timedInterval then
            task.spawn(sellBubblesWithMultiplier) -- Usa task.spawn para não bloquear o loop principal
        end
    end
end

-- Variáveis para controle do loop
local autoFarmConnection = nil

-- Função para iniciar o Auto Farm
local function startAutoFarm()
    if autoFarmConnection then return end
    
    autoFarmEnabled = true
    lastSell = os.clock()
    
    -- Usa RunService.Heartbeat em vez de um thread
    autoFarmConnection = RunService.Heartbeat:Connect(function()
        -- Limita a frequência de execução para aproximadamente a cada 0.2 segundos
        if not game:GetService("RunService").Heartbeat:Wait() then return end
        if not autoFarmEnabled then 
            if autoFarmConnection then
                autoFarmConnection:Disconnect()
                autoFarmConnection = nil
            end
            return
        end
        
        -- Continua executando o loop mesmo durante a venda
        autoFarmTick()
    end)
    
    -- Notifica que o autofarm está ativo
end

-- Função para parar o Auto Farm
local function stopAutoFarm()
    autoFarmEnabled = false
    
    if autoFarmConnection then
        autoFarmConnection:Disconnect()
        autoFarmConnection = nil
    end
end

SellOptions:AddDropdown("SellMethodDropdown", {
    Title = "Auto Sell method",
    Description = "Choose when to sell the bubbles",
    Values = { "Storage Full", "Timed" },
    Multi = false,
    Default = "Storage Full",
    Callback = function(Value)
        sellMethod = Value
    end
})

SellOptions:AddInput("TimedIntervalInput", {
    Title = "Sales Interval (Seconds)",
    Description = "Time between sales in Timed mode",
    Default = "120",
    Placeholder = "Enter the time in seconds",
    Numeric = true,
    Finished = false,
    Callback = function(Value)
        timedInterval = tonumber(Value) or 120
    end
})

-- INTERFACE - TAB MULTIPLICADORES
local Dropdown = SellOptions:AddDropdown("MultiplierDropdown", {
    Title = "Select the Multiplier",
    Description = "Choose the desired luck multiplier",
    Values = {"2x", "5x", "250x"},
    Multi = false,
    Default = "2x",
})

Dropdown:OnChanged(function(Value)
    selectedMultiplier = Value
end)

-- INTERFACE - TAB AUTO FARM
BlowSection:AddToggle("AutoFarmToggle", {
    Title = "Auto Sell + Auto Blow",
    Default = false,
    Callback = function(Value)
        if Value then
            startAutoFarm()
        else
            stopAutoFarm()
        end
    end
})

local AutoCollect = false
local CollectDistance = 40 -- valor inicial padrão

-- Slider para ajustar a distância de coleta
CollectSection:AddSlider("CollectDistanceSlider", {
    Title = "Distância de Coleta",
    Description = "Ajusta a distância (studs) para coletar moedas/gemas/caixas",
    Default = 40,
    Min = 10,
    Max = 200,
    Rounding = 0,
    Callback = function(value)
        CollectDistance = value
    end
})

-- Toggle de AutoCollect
CollectSection:AddToggle("AutoCollectToggle", {
    Title = "Auto Collect Coins/Gems/Crates",
    Default = false,
    Callback = function(state)
        AutoCollect = state

        if state then
            task.spawn(function()
                local pickupRemote = game:GetService("ReplicatedStorage"):WaitForChild("Remotes")
                                          :WaitForChild("Pickups"):WaitForChild("CollectPickup")
                local Players = game:GetService("Players")
                local LocalPlayer = Players.LocalPlayer
                local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

                while AutoCollect and task.wait(0.2) do
                    pcall(function()
                        local rendered = workspace:FindFirstChild("Rendered")
                        if rendered then
                            local itemsToCollect = {}

                            for _, folder in ipairs(rendered:GetChildren()) do
                                if folder.Name == "Chunker" then
                                    for _, model in ipairs(folder:GetChildren()) do
                                        if model:IsA("Model") and #model.Name >= 25 then
                                            local primaryPart = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                                            if primaryPart and Character and Character:FindFirstChild("HumanoidRootPart") then
                                                local distance = (primaryPart.Position - Character.HumanoidRootPart.Position).Magnitude
                                                if distance <= CollectDistance then
                                                    table.insert(itemsToCollect, model)
                                                end
                                            end
                                        end
                                    end
                                end
                            end

                            for i, model in ipairs(itemsToCollect) do
                                pickupRemote:FireServer(model.Name)
                                model:Destroy()

                                if i % 20 == 0 then
                                    task.wait(0.2)
                                end
                            end
                        end
                    end)
                end
            end)
        end
    end
})

local equipBestRunning = false -- Variável de controle GLOBAL

UtilitiesSection:AddToggle("EquipBestToggle", {
    Title = "Auto Equip Best Pets",
    Description = "Automatically equips the best pets",
    Default = false,
    Callback = function(state)
        equipBestRunning = state
        
        if state then
            task.spawn(function()
                local remote = game:GetService("ReplicatedStorage")
                    :WaitForChild("Shared")
                    :WaitForChild("Framework")
                    :WaitForChild("Network")
                    :WaitForChild("Remote")
                    :WaitForChild("Event")
                
                while equipBestRunning do
                    local args = {[1] = "EquipBestPets"}
                    remote:FireServer(unpack(args))
                    task.wait(2) -- Espera 2 segundos
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoClaimChests", {
    Title = "Auto Claim Chests",
    Description = "Teleports and claims Giant and Void Chests using Remote Event",
    Default = false,
    Callback = function(state)
        getgenv().AutoClaimChests = state

        if state then
            spawn(function()
                local Players = game:GetService("Players")
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RunService = game:GetService("RunService")
                local Workspace = game:GetService("Workspace")

                local LocalPlayer = Players.LocalPlayer
                local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local HRP = Character:WaitForChild("HumanoidRootPart")
                local Humanoid = Character:WaitForChild("Humanoid")

                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                local chestData = {
                    ["Giant Chest"] = {
                        teleportTo = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
                        walkTo = Vector3.new(13.179579734802246, 427.93109130859375, 158.93988037109375),
                        path = "Giant Chest"
                    },
                    ["Void Chest"] = {
                        teleportTo = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
                        walkTo = Vector3.new(76.66033172607422, 10148.2060546875, 52.507083892822266),
                        path = "Void Chest"
                    }
                }

                local function isChestReady(chestName)
                    local genericChest = Workspace.Rendered.Generic:FindFirstChild(chestName)
                    return genericChest and genericChest:FindFirstChild("Outer") ~= nil
                end

                for chestName, data in pairs(chestData) do
                    if not isChestReady(data.path) then
                        Fluent:Notify({
                            Title = "Cooldown",
                            Content = chestName .. " it's on cooldown!",
                            Duration = 4
                        })
                    end
                end

                local noclipConnection
                noclipConnection = RunService.Stepped:Connect(function()
                    if getgenv().AutoClaimChests then
                        for _, part in ipairs(Character:GetDescendants()) do
                            if part:IsA("BasePart") and part.CanCollide then
                                part.CanCollide = false
                            end
                        end
                    else
                        noclipConnection:Disconnect()
                    end
                end)

                local function fireTeleport(path)
                    RemoteEvent:FireServer("Teleport", path)
                    task.wait(2.5)
                end

                local function walkTo(position)
                    Humanoid:MoveTo(position)
                    Humanoid.MoveToFinished:Wait()
                end

                while getgenv().AutoClaimChests do
                    for chestName, data in pairs(chestData) do
                        if isChestReady(data.path) then
                            fireTeleport(data.teleportTo)
                            walkTo(data.walkTo)
                            task.wait(0.5)
                            RemoteEvent:FireServer("ClaimChest", chestName)
                            Fluent:Notify({
                                Title = "Chest Claimed",
                                Content = chestName .. " successfully collected!",
                                Duration = 3
                            })
                        end
                        task.wait(1)
                    end
                    task.wait(1)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoClaimSeason", {
    Title = "Auto Claim Season",
    Description = "Automatic Season Pass claim",
    Default = false,
    Callback = function(state)
        getgenv().AutoClaimSeason = state

        if state then
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

                while AutoClaimSeason do
                    local args = {
                        [1] = "ClaimSeason"
                    }

                    RemoteEvent:FireServer(unpack(args))
                    task.wait(5) -- tempo entre cada claim (ajuste conforme necessário)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoClaimPlaytime", {
    Title = "Auto Claim Playtime Rewards",
    Description = "Automatically claims playtime rewards (1 to 9)",
    Default = false,
    Callback = function(state)
        AutoClaimPlaytime = state

        task.spawn(function()
            while AutoClaimPlaytime do
                for i = 1, 9 do
                    pcall(function()
                        local args = {
                            [1] = "ClaimPlaytime",
                            [2] = i
                        }

                        game:GetService("ReplicatedStorage")
                            :WaitForChild("Shared")
                            :WaitForChild("Framework")
                            :WaitForChild("Network")
                            :WaitForChild("Remote")
                            :WaitForChild("Function")
                            :InvokeServer(unpack(args))
                    end)
                end

                task.wait(5) -- Espera 5 segundos antes de repetir tudo
            end
        end)
    end
})

UtilitiesSection:AddToggle("AutoGiftGrabber", {
    Title = "Auto Open Mystery Box + Claim",
    Default = false,
    Callback = function(state)
        getgenv().AutoGiftGrabber = state

        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network")
                local RemoteEvent = Network:WaitForChild("Remote"):WaitForChild("Event")
                local RenderedGifts = workspace:WaitForChild("Rendered"):WaitForChild("Gifts")

                while AutoGiftGrabber do
                    RemoteEvent:FireServer("UseGift", "Mystery Box", 10)

                    local startTime = os.clock()
                    local detectedGifts = {}

                    repeat
                        for _, obj in pairs(RenderedGifts:GetChildren()) do
                            if obj:IsA("BasePart") and not detectedGifts[obj] then
                                detectedGifts[obj] = true
                                RemoteEvent:FireServer("ClaimGift", obj.Name)
                                
                                task.delay(0.5, function()
                                    if obj and obj.Parent then
                                        obj:Destroy()
                                    end
                                end)
                            end
                        end
                        task.wait(0.5)
                    until os.clock() - startTime > 10 or not AutoGiftGrabber

                    task.wait(0.5)
                end
            end)
        end 
    end
})

UtilitiesSection:AddToggle("AutoGiftGrabber", {
    Title = "Auto Open Golden Box + Claim",
    Default = false,
    Callback = function(state)
        getgenv().AutoGiftGrabber = state

        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network")
                local RemoteEvent = Network:WaitForChild("Remote"):WaitForChild("Event")
                local RenderedGifts = workspace:WaitForChild("Rendered"):WaitForChild("Gifts")

                while AutoGiftGrabber do
                    RemoteEvent:FireServer("UseGift", "Golden Box", 10)

                    local startTime = os.clock()
                    local detectedGifts = {}

                    repeat
                        for _, obj in pairs(RenderedGifts:GetChildren()) do
                            if obj:IsA("BasePart") and not detectedGifts[obj] then
                                detectedGifts[obj] = true
                                RemoteEvent:FireServer("ClaimGift", obj.Name)
                                
                                task.delay(0.5, function()
                                    if obj and obj.Parent then
                                        obj:Destroy()
                                    end
                                end)
                            end
                        end
                        task.wait(0.5)
                    until os.clock() - startTime > 10 or not AutoGiftGrabber

                    task.wait(0.5)
                end
            end)
        end 
    end
})

UtilitiesSection:AddToggle("AutoStartGenieQuest", {
    Title = "Auto Start Genie Quest",
    Description = "Automatically starts random Genius quests",
    Default = false,
    Callback = function(state)
        getgenv().AutoGenieQuest = state

        if state then
            task.spawn(function()
                local RemoteEvent = game:GetService("ReplicatedStorage")
                    :WaitForChild("Shared")
                    :WaitForChild("Framework")
                    :WaitForChild("Network")
                    :WaitForChild("Remote")
                    :WaitForChild("Event")

                while getgenv().AutoGenieQuest do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("StartGenieQuest", i)
                        task.wait(1)
                    end
                    task.wait(1)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoBuyAlienShop", {
    Title = "Auto Buy Alien Shop Items",
    Description = "Automatically buys items from alien-shop",
    Default = false,
    Callback = function(state)
        getgenv().AutoBuyAlienShop = state

        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework")
                    :WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

                while AutoBuyAlienShop do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("BuyShopItem", "alien-shop", i)
                        task.wait(0.5) -- pequeno delay entre compras
                    end

                    task.wait(3) -- espera 3s antes de comprar novamente
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoBuyShardShop", {
    Title = "Auto Buy Black Market Shop Items",
    Description = "Automatically buys items from shard shop",
    Default = false,
    Callback = function(state)
        getgenv().AutoBuyShardShop = state

        if state then
            task.spawn(function()
                local RemoteEvent = game:GetService("ReplicatedStorage")
                    :WaitForChild("Shared")
                    :WaitForChild("Framework")
                    :WaitForChild("Network")
                    :WaitForChild("Remote")
                    :WaitForChild("Event")

                while getgenv().AutoBuyShardShop do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("BuyShopItem", "shard-shop", i)
                        task.wait(0.5)
                    end
                    task.wait(3)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoDoggyJumpWin", {
    Title = "Auto Win Doggy",
    Description = "Simulates victory in the Doggy Jump minigame (Rewards 1 to 3)",
    Default = false,
    Callback = function(state)
        getgenv().AutoDoggyJumpWin = state

        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework")
                    :WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

                while AutoDoggyJumpWin do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("DoggyJumpWin", i)
                        task.wait(1)
                    end
                    task.wait(3) -- espera 3s antes de repetir
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoWheelSpin", {
    Title = "Auto Wheel Spin",
    Description = "Automatically spins both roulette wheels (free and paid)",
    Default = false,
    Callback = function(state)
        getgenv().AutoWheelSpin = state

        if state then
            task.spawn(function()
                local Event = game:GetService("ReplicatedStorage"):WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")
                
                local Function = game:GetService("ReplicatedStorage"):WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Function")

                while getgenv().AutoWheelSpin do
                    pcall(function()
                        Event:FireServer("ClaimFreeWheelSpin")
                    end)
                    
                    pcall(function()
                        Function:InvokeServer("WheelSpin")
                    end)
                    
                    task.wait(1) -- Espera exatamente 1 segundo
                end
            end)
        end
    end
})

local EggTeleportMap = {
    ["Common Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Spotted Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Iceshard Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Spikey Egg"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
    ["Magma Egg"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Crystal Egg"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Lunar Egg"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",
    ["Void Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Hell Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Nightmare Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Rainbow Egg"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn",
    ["Infinity Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Pastel Egg"] = "Workspace.Event.Portal.Spawn",
    ["Bunny Egg"] = "Workspace.Event.Portal.Spawn"
}

local EggPositions = {
    ["Common Egg"] = Vector3.new(-8.69461727142334, 9.29999828338623, -82.08343505859375),
    ["Spotted Egg"] = Vector3.new(-7.885712146759033, 9.29999828338623, -71.13986206054688),
    ["Iceshard Egg"] = Vector3.new(-8.188074111938477, 9.323458671569824, -60.25547790527344),
    ["Spikey Egg"] = Vector3.new(-6.725212097167969, 422.93157958984375, 157.7880096435547),
    ["Magma Egg"] = Vector3.new(-19.16876220703125, 2665.166015625, 8.449355125427246),
    ["Crystal Egg"] = Vector3.new(-18.302135467529297, 2665.166015625, 18.25184440612793),
    ["Lunar Egg"] = Vector3.new(-57.51275634765625, 6862.583984375, 79.98605346679688),
    ["Void Egg"] = Vector3.new(5.301668167114258, 10147.8046875, 188.5633087158203),
    ["Hell Egg"] = Vector3.new(-8.620597839355469, 10147.8046875, 193.4177703857422),
    ["Nightmare Egg"] = Vector3.new(-17.104894638061523, 10147.8046875, 185.614990234375),
    ["Rainbow Egg"] = Vector3.new(-34.15152359008789, 15972.4248046875, 45.44554138183594),
    ["Infinity Egg"] = Vector3.new(-96.60652923583984, 8.299989700317383, -27.740280151367188),
    ["Pastel Egg"] = Vector3.new(-393.0823669433594, 12012.0830078125, -60.60501480102539),
    ["Bunny Egg"] = Vector3.new(-402.5804443359375, 12012.0830078125, -59.37004089355469)
}

local TaskToEggMap = {
    ["Shiny"] = "Common Egg",
    ["Epic"] = "Spotted Egg",
    ["Legendary"] = "Spikey Egg",
    ["Common"] = "Common Egg",
    ["Rare"] = "Iceshard Egg"
}

Tabs.AutoTask:AddToggle("AutoHatch", {
    Title = "Auto Task Challenge",
    Default = false,
    Callback = function(state)
        getgenv().AutoHatch = state
        
        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Players = game:GetService("Players")
                local RunService = game:GetService("RunService")
                
                local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network")
                local RemoteEvent = Network:WaitForChild("Remote"):WaitForChild("Event")
                local Player = Players.LocalPlayer
                
                local currentTask = nil
                local playTimeTaskActive = false
                local playTimeStart = 0
                local playTimeRequired = 0
                local noclipActive = false
                local noclipConnection = nil

                local function setNoClip(state)
                    if state == noclipActive then return end
                    
                    if state then
                        noclipActive = true
                        noclipConnection = RunService.Stepped:Connect(function()
                            if Player.Character then
                                for _, part in ipairs(Player.Character:GetDescendants()) do
                                    if part:IsA("BasePart") then
                                        part.CanCollide = false
                                    end
                                end
                            end
                        end)
                    else
                        noclipActive = false
                        if noclipConnection then
                            noclipConnection:Disconnect()
                            noclipConnection = nil
                        end
                    end
                end

                local function walkToPosition(position)
                    if not Player.Character then 
                        return false 
                    end
                    
                    local humanoid = Player.Character:FindFirstChildOfClass("Humanoid")
                    local rootPart = Player.Character:FindFirstChild("HumanoidRootPart")
                    
                    if not humanoid or not rootPart then 
                        return false 
                    end
                    
                    setNoClip(true)
                    
                    local originalWalkSpeed = humanoid.WalkSpeed
                    humanoid.WalkSpeed = 24
                    
                    humanoid:MoveTo(position)
                    
                    local startTime = os.time()
                    local distance = (rootPart.Position - position).Magnitude
                    local lastDistance = distance
                    local stuckCounter = 0
                    
                    while distance > 5 and os.time() - startTime < 30 do
                        task.wait(0.5)
                        
                        distance = (rootPart.Position - position).Magnitude
                        
                        if math.abs(distance - lastDistance) < 1 then
                            stuckCounter = stuckCounter + 1
                        else
                            stuckCounter = 0
                        end
                        
                        if stuckCounter >= 3 then
                            humanoid:MoveTo(position)
                            stuckCounter = 0
                        end
                        
                        lastDistance = distance
                        
                    end
                    
                    humanoid.WalkSpeed = originalWalkSpeed
                    
                    local success = (rootPart.Position - position).Magnitude <= 10
                    
                    if success then
                    else
                    end
                    
                    return success
                end

                local function getCurrentTask()
                    local Player = game:GetService("Players").LocalPlayer
                    local ChallengesFrame = Player.PlayerGui.ScreenGui.Season.Frame.Content.Challenges
                
                    local function checkForLabels(parent)
                        for _, child in pairs(parent:GetChildren()) do
                            if child:IsA("TextLabel") and child.Visible and child.Text then
                                local text = child.Text
                                
                                if text:match("Hatch") then
                                    
                                    if text:match("Mythic") then
                                        return nil
                                    end
                                    
                                    for petType, eggName in pairs(TaskToEggMap) do
                                        if text:match(petType) then
                                            local amount = text:match("Hatch (%d+)")
                                            if amount then
                                                return {
                                                    text = text,
                                                    eggName = eggName,
                                                    amount = tonumber(amount),
                                                    type = "hatch"
                                                }
                                            end
                                        end
                                    end
                                    
                                    if text:match("Common Pets") then
                                        local amount = text:match("Hatch (%d+)")
                                        if amount then
                                            return {
                                                text = text,
                                                eggName = "Common Egg",
                                                amount = tonumber(amount),
                                                type = "hatch"
                                            }
                                        end
                                    end
                
                                    for eggName, _ in pairs(EggPositions) do
                                        local shortName = eggName:gsub(" Egg", "")
                                        if text:match(shortName) or text:match(eggName) then
                                            local amount = text:match("Hatch (%d+)")
                                            if amount then
                                                return {
                                                    text = text,
                                                    eggName = eggName,
                                                    amount = tonumber(amount),
                                                    type = "hatch"
                                                }
                                            end
                                        end
                                    end
                                end
                
                                if text:match("Play for") then
                                    local minutes = text:match("Play for (%d+) minutes")
                                    if minutes then
                                        return {
                                            text = text,
                                            type = "playtime",
                                            requiredTime = tonumber(minutes) * 60
                                        }
                                    end
                                end
                            elseif child:IsA("GuiObject") then
                                local result = checkForLabels(child)
                                if result then return result end
                            end
                        end
                        return nil
                    end
                
                    for _, listName in ipairs({"Daily", "Hourly"}) do
                        local list = ChallengesFrame:FindFirstChild(listName)
                        if list and list:FindFirstChild("List") then
                            local result = checkForLabels(list.List)
                            if result then return result end
                        end
                    end
                
                    return nil
                end                            

                local function teleportToIsland(eggName)
                    local teleportPath = EggTeleportMap[eggName]
                    if not teleportPath then
                        return false
                    end
                    
                    
                    RemoteEvent:FireServer("Teleport", teleportPath)
                    
                    task.wait(3)
                    
                    return true
                end

                local function hatchLoop(eggName, eggPosition)
                    local attempts = 0
                    local maxAttempts = 3
                    local atPosition = false
                    
                    while getgenv().AutoHatch and attempts < maxAttempts do
                        local newTask = getCurrentTask()
                        if not newTask or (newTask.type == "hatch" and newTask.eggName ~= eggName) then
                            break
                        end
                        
                        if not atPosition and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
                            local currentPos = Player.Character.HumanoidRootPart.Position
                            if (currentPos - eggPosition).Magnitude > 10 then
                                
                                if teleportToIsland(eggName) then
                                    task.wait(1.5)
                                    
                                    if walkToPosition(eggPosition) then
                                        atPosition = true
                                        attempts = 0  -- Resetar tentativas quando chegar com sucesso
                                    else
                                        attempts = attempts + 1
                                        task.wait(1)
                                        continue
                                    end
                                else
                                    attempts = attempts + 1
                                    task.wait(1.5)
                                    continue
                                end
                            else
                                atPosition = true  -- Já estamos na posição
                            end
                        end
                        
                        if atPosition then
                            RemoteEvent:FireServer("HatchEgg", eggName, 10)
                            task.wait(0.5 + math.random() * 0.3)  -- Intervalo variável para parecer mais natural
                        else
                            atPosition = false  -- Resetar flag para tentar novamente
                            task.wait(1)
                        end
                    end
                    
                    if attempts >= maxAttempts then
                        getgenv().AutoHatch = false
                    end
                    
                    setNoClip(false)
                end

                while getgenv().AutoHatch do
                    local task = getCurrentTask()
                    
                    if playTimeTaskActive then
                        local elapsed = os.time() - playTimeStart
                        if elapsed >= playTimeRequired then
                            playTimeTaskActive = false
                        else
                        end
                    end
                    
                    if task then
                        if task.type == "playtime" and not playTimeTaskActive then
                            playTimeTaskActive = true
                            playTimeStart = os.time()
                            playTimeRequired = task.requiredTime
                        elseif task.type == "hatch" then
                            if currentTask == nil or currentTask.text ~= task.text then
                                currentTask = task
                            end
                            
                            local eggPosition = EggPositions[task.eggName]
                            if eggPosition then
                                hatchLoop(task.eggName, eggPosition)
                            else
                                task.wait(2)
                            end
                        end
                    else
                        wait(2)
                    end
                    
                    wait(1)
                end
                
                if noclipConnection then
                    noclipConnection:Disconnect()
                    noclipConnection = nil
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
        end
    end
})

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local SelectedEgg = "Common Egg"
local HatchAmount = 10
local AutoHatch = false
local Noclip = false
local NoclipConnection = nil
local AutoRiftHatch = false
local IsProcessingNormalHatch = false -- Flag to track if normal hatching is in progress
local SelectedRiftEggs = {} -- Initialize this variable at the top level
local SelectedLuckMultipliers = {} -- Initialize this variable at the top level

local EggTeleportMap = {
    ["Common Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Spotted Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Iceshard Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Spikey Egg"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
    ["Magma Egg"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Crystal Egg"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Lunar Egg"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",
    ["Void Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Hell Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Nightmare Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Rainbow Egg"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn",
    ["Infinity Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["100M Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn"
}

local EggPositions = {
    ["Common Egg"] = Vector3.new(-8.69461727142334, 9.29999828338623, -82.08343505859375),
    ["Spotted Egg"] = Vector3.new(-7.885712146759033, 9.29999828338623, -71.13986206054688),
    ["Iceshard Egg"] = Vector3.new(-8.795853614807129, 9.29999828338623, -59.287872314453125),
    ["Spikey Egg"] = Vector3.new(-6.725212097167969, 422.93157958984375, 157.7880096435547),
    ["Magma Egg"] = Vector3.new(-19.16876220703125, 2665.166015625, 8.449355125427246),
    ["Crystal Egg"] = Vector3.new(-18.302135467529297, 2665.166015625, 18.25184440612793),
    ["Lunar Egg"] = Vector3.new(-57.51275634765625, 6862.583984375, 79.98605346679688),
    ["Void Egg"] = Vector3.new(5.301668167114258, 10147.8046875, 188.5633087158203),
    ["Hell Egg"] = Vector3.new(-8.620597839355469, 10147.8046875, 193.4177703857422),
    ["Nightmare Egg"] = Vector3.new(-17.104894638061523, 10147.8046875, 185.614990234375),
    ["Rainbow Egg"] = Vector3.new(-34.15152359008789, 15972.4248046875, 45.44554138183594),
    ["Infinity Egg"] = Vector3.new(-96.60652923583984, 8.299989700317383, -27.740280151367188),
    ["100M Egg"] = Vector3.new(15.931231498718262, 9.25584602355957, -4.832009315490723)
}

-- Shared noclip function to avoid duplication
local function EnableNoclip()
    if NoclipConnection then NoclipConnection:Disconnect() end
    Noclip = true
    NoclipConnection = RunService.Stepped:Connect(function()
        if Noclip and LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function DisableNoclip()
    Noclip = false
    if NoclipConnection then
        NoclipConnection:Disconnect()
        NoclipConnection = nil
    end
end

local function GetEggNames()
    local keys = {}
    for eggName in pairs(EggTeleportMap) do
        table.insert(keys, eggName)
    end
    return keys
end

local EggDropdown = Egg:AddDropdown("EggDropdown", {
    Title = "Selecting Egg",
    Description = "Choose the egg you want to open",
    Values = GetEggNames(),
    Multi = false,
    Default = 1
})

EggDropdown:OnChanged(function(val)
    SelectedEgg = val
end)

-- Function to check if any valid rift eggs exist
local function CheckForValidRiftEggs()
    if not AutoRiftHatch then return false end
    
    -- Check if SelectedRiftEggs is nil and handle it safely
    if SelectedRiftEggs == nil then
        SelectedRiftEggs = {}
        return false
    end
    
    if #SelectedRiftEggs == 0 then return false end
    
    local Rifts = workspace:WaitForChild("Rendered"):WaitForChild("Rifts")
    for _, egg in pairs(Rifts:GetChildren()) do
        if egg:IsA("Model") and egg:FindFirstChild("Display") then
            local isSelectedEgg = false
            for _, selectedEgg in pairs(SelectedRiftEggs) do
                if egg.Name == selectedEgg then
                    isSelectedEgg = true
                    break
                end
            end
            
            if isSelectedEgg then
                local display = egg.Display
                local gui = display and display:FindFirstChildWhichIsA("SurfaceGui")
                local icon = gui and gui:FindFirstChild("Icon")
                local luck = icon and icon:FindFirstChildWhichIsA("TextLabel")
                
                -- Check if SelectedLuckMultipliers is nil and handle it safely
                if SelectedLuckMultipliers == nil then
                    SelectedLuckMultipliers = {}
                end
                
                local validMultiplier = #SelectedLuckMultipliers == 0
                if luck and luck.Text then
                    for _, multi in pairs(SelectedLuckMultipliers) do
                        if luck.Text == multi then
                            validMultiplier = true
                            break
                        end
                    end
                end
                
                if validMultiplier then
                    return true
                end
            end
        end
    end
    
    return false
end

-- Start normal hatching process
local function StartNormalHatching()
    if IsProcessingNormalHatch then return end
    IsProcessingNormalHatch = true
    
    task.spawn(function()
        local remote = ReplicatedStorage.Shared.Framework.Network.Remote.Event
        local teleportPath = EggTeleportMap[SelectedEgg]
        if teleportPath then
            remote:FireServer("Teleport", teleportPath)
        end

        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
        local Humanoid = Character:WaitForChild("Humanoid")

        task.wait(1)

        local target = EggPositions[SelectedEgg]
        if target then
            Humanoid:MoveTo(target)
            local reached = false
            Humanoid.MoveToFinished:Connect(function(success)
                if success then reached = true end
            end)

            -- Wait until we've reached the egg or conditions change
            while not reached and AutoHatch and not (AutoRiftHatch and CheckForValidRiftEggs()) do
                task.wait(0.5)
            end

            -- Start hatching if we've reached and conditions are still valid
            while AutoHatch and not (AutoRiftHatch and CheckForValidRiftEggs()) do
                pcall(function()
                    remote:FireServer("HatchEgg", SelectedEgg, HatchAmount)
                end)
                task.wait(0.5)
            end
        end
        
        IsProcessingNormalHatch = false
    end)
end

-- Modified regular Auto Hatch to work with the hybrid approach
Egg:AddToggle("AutoHatch", {
    Title = "Auto Hatch",
    Description = "Automatically opens eggs after walking to them",
    Default = false,
    Callback = function(state)
        AutoHatch = state
        
        if state then
            EnableNoclip()
            
            -- Only start normal hatching if there are no valid rift eggs
            if not (AutoRiftHatch and CheckForValidRiftEggs()) then
                StartNormalHatching()
            end
        elseif not state then
            if not AutoRiftHatch then
                DisableNoclip() -- Only disable noclip if Rift isn't running
            end
        end
    end
})

-- Rift Auto Hatch Section
local Rifts = workspace:WaitForChild("Rendered"):WaitForChild("Rifts")

-- SelectedRiftEggs and SelectedLuckMultipliers are now defined at the top of the script
local ActiveTweens = {}
local CurrentTargetEgg = nil
local CurrentTargetMultiplier = nil
local IsHandlingRiftEgg = false
local NoClipEnabled = false
local NoClipConnection = nil
local dropAltitude = -100  -- Altura abaixo do chão
local moveSpeed = 18       -- Velocidade do movimento horizontal
local originalGravity = workspace.Gravity
local PlayerImmobilized = false
local ImmobilizeConnection = nil

local EggNameMap = {
    ["spotted-egg"] = "Spotted Egg",
    ["iceshard-egg"] = "Iceshard Egg",
    ["spikey-egg"] = "Spikey Egg",
    ["magma-egg"] = "Magma Egg",
    ["crystal-egg"] = "Crystal Egg",
    ["lunar-egg"] = "Lunar Egg",
    ["void-egg"] = "Void Egg",
    ["hell-egg"] = "Hell Egg",
    ["nightmare-egg"] = "Nightmare Egg",
    ["rainbow-egg"] = "Rainbow Egg",
    ["infinity-egg"] = "Infinity Egg",
    ["silly-egg"] = "Silly Egg",
    ["man-egg"] = "Aura Egg"
}

local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

local RiftEggNames = {}
for k in pairs(EggNameMap) do
    table.insert(RiftEggNames, k)
end

local RiftEggDropdown = EggRift:AddDropdown("RiftEggDropdown", {
    Title = "Select Rift Eggs",
    Description = "Choose which eggs to hatch",
    Values = RiftEggNames,
    Multi = true,
    Default = {},
})

RiftEggDropdown:OnChanged(function(selectedTable)
    SelectedRiftEggs = {}
    for eggName, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedRiftEggs, eggName)
        end
    end
end)

local LuckMultiplierDropdown = EggRift:AddDropdown("LuckMultiplierDropdown", {
    Title = "Luck Multiplier",
    Description = "Select desired luck multipliers",
    Values = { "x5", "x7", "x10", "x25" },
    Multi = true,
    Default = {},
})

LuckMultiplierDropdown:OnChanged(function(selectedTable)
    SelectedLuckMultipliers = {}
    for multiplier, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedLuckMultipliers, multiplier)
        end
    end
end)

-- Helper function to make the player immobile
local function immobilizePlayer()
    if PlayerImmobilized then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Store original properties
    local originalWalkSpeed = humanoid.WalkSpeed
    local originalJumpPower = humanoid.JumpPower
    local originalAutoRotate = humanoid.AutoRotate
    
    -- Make character immobile
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    humanoid.AutoRotate = false
    
    -- Freeze the character in place with RunService
    if ImmobilizeConnection then
        ImmobilizeConnection:Disconnect()
    end
    
    ImmobilizeConnection = RunService.Heartbeat:Connect(function()
        if character and character:FindFirstChild("HumanoidRootPart") then
            -- Cancel any movement
            character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            character.HumanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
            
            -- Cancel animations that might move the character
            if humanoid then
                local animator = humanoid:FindFirstChildOfClass("Animator")
                if animator then
                    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                        if track.Name:lower():match("walk") or track.Name:lower():match("run") or track.Name:lower():match("jump") then
                            track:Stop()
                        end
                    end
                end
            end
        end
    end)
    
    PlayerImmobilized = true
end

-- Helper function to restore player mobility
local function restorePlayerMobility()
    if not PlayerImmobilized then return end
    
    -- Disconnect the immobilize heartbeat
    if ImmobilizeConnection then
        ImmobilizeConnection:Disconnect()
        ImmobilizeConnection = nil
    end
    
    local character = LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            -- Restore mobility
            humanoid.WalkSpeed = 16 -- Default walk speed
            humanoid.JumpPower = 50 -- Default jump power
            humanoid.AutoRotate = true
        end
    end
    
    PlayerImmobilized = false
end

-- Função auxiliar para controlar física
local function setPhysicsEnabled(enabled)
  if not LocalPlayer.Character then return end
  
  for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
      if part:IsA("BasePart") then
          part.CanCollide = enabled
          part.AssemblyLinearVelocity = Vector3.new()
          part.AssemblyAngularVelocity = Vector3.new()
      end
  end
  
  local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
  if humanoid then
      humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, enabled)
  end
  
  -- Also immobilize or restore mobility based on the enabled parameter
  if not enabled then
      immobilizePlayer()
  else
      restorePlayerMobility()
  end
end

local function enableNoClip()
    if NoClipConnection then return end
    
    NoClipConnection = RunService.Stepped:Connect(function()
        if LocalPlayer.Character then
            for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
    
    -- Also immobilize the player when enabling noclip
    immobilizePlayer()
end

local function disableNoClip()
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    
    if LocalPlayer.Character then
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    
    -- Restore player mobility when disabling noclip
    restorePlayerMobility()
end

local function teleportToEgg(egg)
  local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not hrp then return false end
  
  -- Make sure player is immobilized before teleporting
  immobilizePlayer()
  
  -- 1. Armazena posição original
  local originalPos = hrp.Position
  
  -- 2. Desce para abaixo do chão (-100 no Y)
  setPhysicsEnabled(false)
  hrp.CFrame = CFrame.new(originalPos.X, dropAltitude, originalPos.Z)
  
  -- 3. Move horizontalmente até abaixo do egg (mantém Y = -100)
  local eggPos = egg:GetPivot().Position
  local targetXZ = Vector3.new(eggPos.X, dropAltitude, eggPos.Z)
  local distance = (targetXZ - hrp.Position).Magnitude
  local duration = distance / moveSpeed
  
  local info = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
  local tween = TweenService:Create(hrp, info, {CFrame = CFrame.new(targetXZ)})
  
  tween:Play()
  tween.Completed:Wait()
  
  -- 4. Sobe para posição correta (+3 no Y)
  hrp.CFrame = CFrame.new(eggPos.X, eggPos.Y + 3, eggPos.Z)
  
  return true
end

local function hatchEgg(eggName)
    local args = {
        [1] = "HatchEgg",
        [2] = EggNameMap[eggName],
        [3] = 10
    }
    pcall(function()
        RemoteEvent:FireServer(unpack(args))
    end)
end

local function cancelAllOperations()
    for hrp, tween in pairs(ActiveTweens) do
        if tween then tween:Cancel() end
    end
    ActiveTweens = {}
    disableNoClip()
    restorePlayerMobility()
end

local function chooseNewTarget()
    -- Ensure SelectedRiftEggs is initialized
    if SelectedRiftEggs == nil then
        SelectedRiftEggs = {}
    end
    
    if #SelectedRiftEggs > 0 then
        CurrentTargetEgg = SelectedRiftEggs[math.random(1, #SelectedRiftEggs)]
    else
        local eggs = {}
        for k in pairs(EggNameMap) do table.insert(eggs, k) end
        CurrentTargetEgg = eggs[math.random(1, #eggs)]
    end

    -- Ensure SelectedLuckMultipliers is initialized
    if SelectedLuckMultipliers == nil then
        SelectedLuckMultipliers = {}
    end
    
    if #SelectedLuckMultipliers > 0 then
        CurrentTargetMultiplier = SelectedLuckMultipliers[math.random(1, #SelectedLuckMultipliers)]
    else
        CurrentTargetMultiplier = nil -- accept any multiplier
    end
end

-- Function to enable noclip with proper name (used in the code)
local function EnableNoclip()
    enableNoClip()
    immobilizePlayer()  -- Make sure player is immobilized when noclip is enabled
    NoClipEnabled = true
end

-- Function to disable noclip with proper name (used in the code)
local function DisableNoclip()
    disableNoClip()
    restorePlayerMobility()  -- Restore player mobility when noclip is disabled
    NoClipEnabled = false
end

-- Modified Rift Auto Hatch with dynamic switching to normal hatch
EggRift:AddToggle("AutoRiftHatchToggle", {
    Title = "Auto Hatch (Rift)",
    Description = "Automatically teleport and hatch rift eggs when available",
    Default = false,
    Callback = function(state)
        AutoRiftHatch = state
        
        if state then
            EnableNoclip() -- Make sure noclip is on for any type of hatching
            immobilizePlayer() -- Make sure player is immobilized
            
            chooseNewTarget()
            task.spawn(function()
                while AutoRiftHatch do
                    IsHandlingRiftEgg = false
                    local foundValidEgg = false
                    
                    -- Check if there are any valid Rift eggs to process
                    for _, egg in pairs(Rifts:GetChildren()) do
                        if not AutoRiftHatch then break end
                        
                        local isSelectedEgg = false
                        -- Ensure SelectedRiftEggs is initialized
                        if SelectedRiftEggs ~= nil then
                            for _, selectedEgg in pairs(SelectedRiftEggs) do
                                if egg.Name == selectedEgg then
                                    isSelectedEgg = true
                                    break
                                end
                            end
                        end
                        
                        if isSelectedEgg and egg:IsA("Model") and egg:FindFirstChild("Display") then
                            local display = egg.Display
                            local gui = display and display:FindFirstChildWhichIsA("SurfaceGui")
                            local icon = gui and gui:FindFirstChild("Icon")
                            local luck = icon and icon:FindFirstChildWhichIsA("TextLabel")
                            
                            -- Ensure SelectedLuckMultipliers is initialized
                            if SelectedLuckMultipliers == nil then
                                SelectedLuckMultipliers = {}
                            end
                            
                            local validMultiplier = #SelectedLuckMultipliers == 0
                            if luck and luck.Text then
                                for _, multi in pairs(SelectedLuckMultipliers) do
                                    if luck.Text == multi then
                                        validMultiplier = true
                                        break
                                    end
                                end
                            end
                            
                            if validMultiplier then
                                foundValidEgg = true
                                IsHandlingRiftEgg = true
                                
                                task.wait(0.5) -- Brief pause before teleporting
                                if teleportToEgg(egg) then
                                    -- Keep hatching this egg until it disappears or settings change
                                    while AutoRiftHatch and egg.Parent do
                                        immobilizePlayer() -- Ensure player stays immobile
                                        hatchEgg(egg.Name)
                                        task.wait(0.5)
                                    end
                                end
                                
                                break -- We've processed one egg, exit the loop
                            end
                        end
                    end
                    
                    -- If no valid rift eggs were found and normal hatch is enabled, start that process
                    if not foundValidEgg and AutoHatch and not IsProcessingNormalHatch then
                        StartNormalHatching()
                    end
                    
                    -- If we didn't find any valid rift egg, choose a new target for next check
                    if not foundValidEgg then
                        chooseNewTarget()
                    end
                    
                    task.wait(2) -- Wait before checking again
                end
                
                -- When Rift Auto Hatch is turned off
                if AutoHatch then
                    -- Make sure normal hatching is active
                    if not IsProcessingNormalHatch then
                        StartNormalHatching()
                    end
                else
                    DisableNoclip() -- Only disable if both auto hatches are off
                    restorePlayerMobility() -- Restore player mobility
                end
            end)
        else
            IsHandlingRiftEgg = false
            
            -- Cancel any active rift operations
            for hrp, tween in pairs(ActiveTweens) do
                if tween then tween:Cancel() end
            end
            ActiveTweens = {}
            
            -- If regular Auto Hatch is still on, let it run
            if AutoHatch then
                if not IsProcessingNormalHatch then
                    StartNormalHatching()
                end
            else
                DisableNoclip() -- Only disable if both auto hatches are off
                restorePlayerMobility() -- Restore player mobility
            end
        end
    end
})

local AutoGoldenChest = false
local AutoRoyalChest = false
local ActiveTween
local NoClipConnection

-- Funções de NoClip (compartilhadas)
local function enableNoClip()
    if NoClipConnection then return end
    NoClipConnection = game:GetService("RunService").Stepped:Connect(function()
        if game.Players.LocalPlayer.Character then
            for _, part in ipairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function disableNoClip()
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
end

-- Sistema para Golden Chest
local function teleportAndFarmGolden()
    while AutoGoldenChest do
        local chest = workspace.Rendered.Rifts:FindFirstChild("golden-chest")
        if chest then
            local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                enableNoClip()
                
                -- Tween com tempo fixo de 7 segundos
                local tween = TweenService:Create(hrp, TweenInfo.new(7, Enum.EasingStyle.Linear), {
                    CFrame = chest:GetPivot() * CFrame.new(0, 0, 0)
                })
                
                tween:Play()
                tween.Completed:Wait()
                
                while AutoGoldenChest and chest.Parent do
                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("UnlockRiftChest", "golden-chest")
                    task.wait(1)
                end
            end
        end
        task.wait(1)
    end
    disableNoClip()
end

-- Sistema para Royal Chest
local function teleportAndFarmRoyal()
    while AutoRoyalChest do
        local chest = workspace.Rendered.Rifts:FindFirstChild("royal-chest")
        if chest then
            local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                enableNoClip()
                
                -- Tween com tempo fixo de 7 segundos
                local tween = TweenService:Create(hrp, TweenInfo.new(7, Enum.EasingStyle.Linear), {
                    CFrame = chest:GetPivot() * CFrame.new(0, 0, 0)
                })
                
                tween:Play()
                tween.Completed:Wait()
                
                while AutoRoyalChest and chest.Parent do
                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("UnlockRiftChest", "royal-chest")
                    task.wait(1)
                end
            end
        end
        task.wait(1)
    end
    disableNoClip()
end

-- Toggles
ChestHunt:AddToggle("AutoGoldenChestToggle", {
    Title = "Auto Golden Chest",
    Description = "Teleport and farm golden chest automatically",
    Default = false,
    Callback = function(state)
        AutoGoldenChest = state
        if state then
            task.spawn(teleportAndFarmGolden)
        end
    end
})

ChestHunt:AddToggle("AutoRoyalChestToggle", {
    Title = "Auto Royal Chest",
    Description = "Teleport and farm royal chest automatically",
    Default = false,
    Callback = function(state)
        AutoRoyalChest = state
        if state then
            task.spawn(teleportAndFarmRoyal)
        end
    end
})

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- Remote Event reference
local remoteEvent = ReplicatedStorage:WaitForChild("Shared")
    :WaitForChild("Framework")
    :WaitForChild("Network")
    :WaitForChild("Remote")
    :WaitForChild("Event")

-- Configuration variables
local dropAltitude = -100 -- Vertical position below ground
local claimAltitude = 3 -- Final vertical position for claiming
local moveSpeed = 18 -- Horizontal movement speed
local autoGiftRiftEnabled = false
local noClipConnection = nil
local claimAttemptDelay = 0.5 -- Time between claim attempts
local maxClaimAttempts = 10 -- Maximum claim attempts
local searchInterval = 1 -- How often to search for a new gift rift

-- Helper function to get humanoid root part
local function getHRP()
    local character = player.Character or player.CharacterAdded:Wait()
    return character:WaitForChild("HumanoidRootPart")
end

-- Function to enable/disable character collision
local function setNoClip(enabled)
    if enabled then
        if not noClipConnection then
            noClipConnection = RunService.Stepped:Connect(function()
                if player.Character then
                    for _, part in ipairs(player.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if noClipConnection then
            noClipConnection:Disconnect()
            noClipConnection = nil
        end
    end
end

-- Find gift rift function with multiple strategies
local function findGiftRift()
    -- Strategy 1: Direct path
    local gift = Workspace:FindFirstChild("Rendered", true) and 
                Workspace.Rendered:FindFirstChild("Rifts") and 
                Workspace.Rendered.Rifts:FindFirstChild("gift-rift")
    
    if gift then return gift end
    
    -- Strategy 2: Search in all Rifts folders
    for _, child in pairs(Workspace:GetDescendants()) do
        if child.Name == "Rifts" then
            gift = child:FindFirstChild("gift-rift")
            if gift then return gift end
        end
    end
    
    -- Strategy 3: Search for any object with "gift" and "rift" in name
    for _, obj in pairs(Workspace:GetDescendants()) do
        if (obj.Name:lower():find("gift") and obj.Name:lower():find("rift")) or 
           obj.Name:lower() == "gift-rift" then
            return obj
        end
    end
    
    return nil
end

-- Direct teleport function (simpler approach)
local function teleportTo(position)
    local hrp = getHRP()
    hrp.CFrame = CFrame.new(position)
end

-- Function to find and claim gift rift
local function giftRiftLoop()
    while autoGiftRiftEnabled do
        local gift = findGiftRift()
        
        if gift then
            local giftPosition = gift:GetPivot().Position
            local hrp = getHRP()
            local originalPosition = hrp.Position
            
            -- Enable noclip for smooth movement
            setNoClip(true)
            
            -- Step 1: Go below ground
            teleportTo(Vector3.new(originalPosition.X, dropAltitude, originalPosition.Z))
            task.wait(0.1)
            
            -- Step 2: Move to gift position horizontally (keeping -100 Y)
            teleportTo(Vector3.new(giftPosition.X, dropAltitude, giftPosition.Z))
            task.wait(0.1)
            
            -- Step 3: Move up to claim position
            teleportTo(Vector3.new(giftPosition.X, claimAltitude, giftPosition.Z))
            
            -- Claim attempts
            local attempts = 0
            while autoGiftRiftEnabled and gift.Parent and attempts < maxClaimAttempts do
                attempts = attempts + 1
                
                -- Fire server to claim gift
                remoteEvent:FireServer("ClaimRiftGift", "gift-rift")
                
                -- Try to remove the gift object
                if gift:FindFirstChild("Gift") then
                    gift.Gift:Destroy()
                end
                
                -- Remove the entire gift-rift object
                if gift and gift.Parent then
                    gift:Destroy()
                end
                
                task.wait(claimAttemptDelay)
                
                -- Check if gift still exists
                if not gift.Parent then
                    break
                end
            end
            
            -- Return to original position (same 3-step process)
            teleportTo(Vector3.new(giftPosition.X, dropAltitude, giftPosition.Z))
            task.wait(0.1)
            teleportTo(Vector3.new(originalPosition.X, dropAltitude, originalPosition.Z))
            task.wait(0.1)
            teleportTo(Vector3.new(originalPosition.X, originalPosition.Y, originalPosition.Z))
            
            -- Disable noclip
            setNoClip(false)
        end
        
        -- Wait before searching again
        task.wait(searchInterval)
    end
end

-- Toggle function for UI
local function toggleAutoGiftRift(enabled)
    autoGiftRiftEnabled = enabled
    
    if enabled then
        task.spawn(giftRiftLoop)
    else
        setNoClip(false)
    end
end

-- Add just the toggle to UI
GiftHunt:AddToggle("AutoGiftRiftToggle", {
    Title = "Auto Gift Rift",
    Description = "Automatically claims gift rifts",
    Default = false,
    Callback = function(Value)
        toggleAutoGiftRift(Value)
    end
})

Tabs.Upgrades:AddToggle("AutoUpgrade", {
    Title = "Auto Upgrade Mastery for Buffs",
    Description = "Runs Upgrade Mastery automatically when activated.",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgrade = state  -- Armazenando o estado para controle de loop

        if state then
            spawn(function()  -- Usando spawn para rodar em uma thread separada
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                while AutoUpgrade do  -- Enquanto a toggle estiver ativada, o loop continua
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Buffs"
                    }

                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)  -- Intervalo entre as chamadas (ajustável conforme necessário)
                end
            end)
        else
            getgenv().AutoUpgrade = false
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgradePets", {
    Title = "Auto Upgrade Mastery for Pets",
    Description = "Runs Upgrade Mastery for Pets automatically when activated.",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgradePets = state  -- Controla o estado da toggle

        if state then
            spawn(function()  -- Usando spawn para rodar em uma thread separada
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                while AutoUpgradePets do  -- Enquanto a toggle estiver ativada, o loop continua
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Pets"  -- Aqui está o "Pets" que você mencionou
                    }

                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)  -- Intervalo entre as chamadas (ajustável conforme necessário)
                end
            end)
        else
            getgenv().AutoUpgradePets = false
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgradeShops", {
    Title = "Auto Upgrade Mastery for Shops",
    Description = "Runs Upgrade Mastery for Shops automatically when activated.",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgradeShops = state  -- Controla o estado da toggle

        if state then
            spawn(function()  -- Usando spawn para rodar em uma thread separada
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                while AutoUpgradeShops do  -- Enquanto a toggle estiver ativada, o loop continua
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Shops"  -- Aqui está o "Shops" que você mencionou
                    }

                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)  -- Intervalo entre as chamadas (ajustável conforme necessário)
                end
            end)
        else
            getgenv().AutoUpgradeShops = false
        end
    end
})

local potionList = {}
local dropdownOptions = {}

local potionNames = {"Coins", "Lucky", "Speed", "Mythic"}
local tiers = {1, 2, 3, 4, 5,}
local roman = {"I", "II", "III", "IV", "V"}

for _, potion in ipairs(potionNames) do
    for i, tier in ipairs(tiers) do
        local displayName = potion .. " " .. roman[i]
        potionList[displayName] = {potion, tier}
        table.insert(dropdownOptions, displayName)
    end
end

local MultiDropdown = AutoPotionSection:AddDropdown("Poções", {
    Title = "Selecting Potions",
    Description = "Choose the potions to use",
    Values = dropdownOptions,
    Multi = true,
    Default = {},  -- Predefinir poções selecionadas
})

local SelectedPotions = {}

MultiDropdown:OnChanged(function(Value)
    SelectedPotions = {}
    for potion, _ in pairs(Value) do
        table.insert(SelectedPotions, potion)
    end

end)

local RemoteEvent = game:GetService("ReplicatedStorage")
    :WaitForChild("Shared")
    :WaitForChild("Framework")
    :WaitForChild("Network")
    :WaitForChild("Remote")
    :WaitForChild("Event")

AutoPotionSection:AddToggle("Auto Usar Poções", {
    Title = "Auto Use Potion",
    Description = "Enables automatic use of selected potions",
    Default = false,
    Callback = function(state)
        getgenv().AutoPotion = state

        if state then
            task.spawn(function()
                while getgenv().AutoPotion do
                    if #SelectedPotions == 0 then
                        Fluent:Notify({
                            Title = "Warn",
                            Content = "No potions selected.",
                            Duration = 4
                        })
                        break
                    end

                    for _, displayName in ipairs(SelectedPotions) do
                        local data = potionList[displayName]
                        if data then
                            local name, tier = unpack(data)
                            pcall(function()
                                RemoteEvent:FireServer("UsePotion", name, tier)
                            end)
                            task.wait(0.5)
                        else
                            warn("Potion invalid:", displayName)
                        end
                    end

                    task.wait(0.5)
                end
            end)
        end
    end
})

local potionList = {}
local dropdownOptions = {}

local potionNames = {"Coins", "Lucky", "Speed", "Mythic"}
local tiers = {2, 3, 4, 5}
local roman = {"II", "III", "IV", "V"}

for _, potion in ipairs(potionNames) do
    for i, tier in ipairs(tiers) do
        local displayName = potion .. " " .. roman[i]
        potionList[displayName] = {potion, tier}
        table.insert(dropdownOptions, displayName)
    end
end

local MultiDropdown = AutoCraftPotionSection:AddDropdown("Poções", {
    Title = "Selecting Potions to Craft",
    Description = "Choose the potions and tiers you want to craft",
    Values = dropdownOptions,
    Multi = true,
    Default = {},
})

local SelectedPotions = {}

MultiDropdown:OnChanged(function(Value)
    SelectedPotions = {}
    for potion, _ in pairs(Value) do
        table.insert(SelectedPotions, potion)
    end
end)

local RemoteEvent = game:GetService("ReplicatedStorage")
    :WaitForChild("Shared")
    :WaitForChild("Framework")
    :WaitForChild("Network")
    :WaitForChild("Remote")
    :WaitForChild("Event")

AutoCraftPotionSection:AddToggle("Auto Craft Poções", {
    Title = "Auto Craft Potion",
    Description = "Automatically brews selected potions",
    Default = false,
    Callback = function(state)
        getgenv().AutoCraftPotion = state

        if state then
            task.spawn(function()
                while getgenv().AutoCraftPotion do
                    if #SelectedPotions == 0 then
                        Fluent:Notify({
                            Title = "Warn",
                            Content = "No potions selected for crafting.",
                            Duration = 4
                        })
                        break
                    end

                    for _, displayName in ipairs(SelectedPotions) do
                        local data = potionList[displayName]
                        if data then
                            local name, tier = unpack(data)
                            pcall(function()
                                RemoteEvent:FireServer("CraftPotion", name, tier, false)
                            end)
                            task.wait(0.5)
                        else
                            warn("Potion invalid:", displayName)
                        end
                    end

                    task.wait(1.5)
                end
            end)
        end
    end
})

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local LocalPlayer = Players.LocalPlayer
local Rifts = workspace:WaitForChild("Rendered"):WaitForChild("Rifts")

local AutoRiftHatch = false
local SelectedRiftEggs = {}
local SelectedLuckMultipliers = {}
local ActiveTweens = {}
local CurrentTargetEgg = nil
local CurrentTargetMultiplier = nil
local NoClipConnection = nil

-- Detecta qual request HTTP está disponível
local request = (syn and syn.request) or (http and http.request) or http_request or (krnl and krnl.request)
if not request then
    Fluent:Notify({
        Title = "Erro de Compatibilidade",
        Content = "Seu executor não suporta requisições HTTP (server hop não funcionará).",
        SubContent = "Use AWP, Wave ou outro com suporte a request.",
        Duration = 8
    })
    return
end

-- Server hop
local function serverHop()
    local response = request({
        Url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100",
        Method = "GET"
    })

    if response and response.Body then
        local data = HttpService:JSONDecode(response.Body)
        for _, server in ipairs(data.data) do
            if server.playing < server.maxPlayers and server.id ~= game.JobId then
                TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id, LocalPlayer)
                return
            end
        end
    else
        warn("Falha ao buscar servidores.")
    end
end

local EggNameMap = {
    ["spotted-egg"] = "Spotted Egg",
    ["iceshard-egg"] = "Iceshard Egg",
    ["spikey-egg"] = "Spikey Egg",
    ["magma-egg"] = "Magma Egg",
    ["crystal-egg"] = "Crystal Egg",
    ["lunar-egg"] = "Lunar Egg",
    ["void-egg"] = "Void Egg",
    ["hell-egg"] = "Hell Egg",
    ["nightmare-egg"] = "Nightmare Egg",
    ["rainbow-egg"] = "Rainbow Egg",
    ["infinity-egg"] = "Infinity Egg",
    ["silly-egg"] = "Silly Egg",
    ["man-egg"] = "Aura Egg"
}

local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

-- UI Dropdowns (ajuste conforme seu framework de UI)
local RiftEggNames = {}
for k in pairs(EggNameMap) do
    table.insert(RiftEggNames, k)
end

local RiftEggDropdown = Tabs.ServerHop:AddDropdown("RiftEggDropdown", {
    Title = "Select Rift Eggs",
    Description = "Choose which eggs to hatch",
    Values = RiftEggNames,
    Multi = true,
    Default = {},
})

RiftEggDropdown:OnChanged(function(selectedTable)
    SelectedRiftEggs = {}
    for eggName, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedRiftEggs, eggName)
        end
    end
end)

local LuckMultiplierDropdown = Tabs.ServerHop:AddDropdown("LuckMultiplierDropdown", {
    Title = "Luck Multiplier",
    Description = "Select desired luck multipliers",
    Values = { "x5", "x7", "x10", "x25" },
    Multi = true,
    Default = {},
})

LuckMultiplierDropdown:OnChanged(function(selectedTable)
    SelectedLuckMultipliers = {}
    for multiplier, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedLuckMultipliers, multiplier)
        end
    end
end)

local function enableNoClip()
    if NoClipConnection then return end
    NoClipConnection = RunService.Stepped:Connect(function()
        if LocalPlayer.Character then
            for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function disableNoClip()
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    if LocalPlayer.Character then
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

local function teleportToEgg(egg)
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    if ActiveTweens[hrp] then ActiveTweens[hrp]:Cancel() end
    enableNoClip()

    local targetCFrame = CFrame.new(egg:GetPivot().Position + Vector3.new(0, 3, 0))
    local tween = TweenService:Create(hrp, TweenInfo.new(6, Enum.EasingStyle.Linear), {CFrame = targetCFrame})
    ActiveTweens[hrp] = tween

    tween:Play()
    local success = pcall(function()
        tween.Completed:Wait()
    end)

    ActiveTweens[hrp] = nil
    return success
end

local function hatchEgg(eggName)
    local args = {
        [1] = "HatchEgg",
        [2] = EggNameMap[eggName],
        [3] = 10
    }
    pcall(function()
        RemoteEvent:FireServer(unpack(args))
    end)
end

local function cancelAllOperations()
    for hrp, tween in pairs(ActiveTweens) do
        if tween then tween:Cancel() end
    end
    ActiveTweens = {}
    disableNoClip()
end

local function chooseNewTarget()
    if #SelectedRiftEggs > 0 then
        CurrentTargetEgg = SelectedRiftEggs[math.random(1, #SelectedRiftEggs)]
    else
        local eggs = {}
        for k in pairs(EggNameMap) do table.insert(eggs, k) end
        CurrentTargetEgg = eggs[math.random(1, #eggs)]
    end

    if #SelectedLuckMultipliers > 0 then
        CurrentTargetMultiplier = SelectedLuckMultipliers[math.random(1, #SelectedLuckMultipliers)]
    else
        CurrentTargetMultiplier = nil
    end
end

Tabs.ServerHop:AddToggle("AutoRiftHatchToggle", {
    Title = "Auto Server Hop",
    Default = false,
    Callback = function(state)
        AutoRiftHatch = state
        if state then
            chooseNewTarget()
            task.spawn(function()
                while AutoRiftHatch do
                    local found = false
                    for _, egg in pairs(Rifts:GetChildren()) do
                        if not AutoRiftHatch then break end
                        if egg:IsA("Model") and egg:FindFirstChild("Display") and egg.Name == CurrentTargetEgg then
                            local gui = egg.Display:FindFirstChildWhichIsA("SurfaceGui")
                            local icon = gui and gui:FindFirstChild("Icon")
                            local luck = icon and icon:FindFirstChildWhichIsA("TextLabel")
                            if luck and luck.Text then
                                local validMultiplier = not CurrentTargetMultiplier or luck.Text == CurrentTargetMultiplier
                                if validMultiplier then
                                    found = true
                                    task.wait(2)
                                    if teleportToEgg(egg) then
                                        while AutoRiftHatch and egg.Parent do
                                            hatchEgg(egg.Name)
                                            task.wait(0.5)
                                        end
                                    end
                                end
                            end
                        end
                    end

                    if not found then
                        warn("[Auto Hatch] Nenhum ovo com multiplicador desejado. Fazendo server hop...")
                        serverHop()
                        task.wait(10)
                    end

                    task.wait(0.5)
                end
                disableNoClip()
            end)
        else
            cancelAllOperations()
        end
    end
})

local AutoTween = false

TeleportSection:AddToggle("TweenTeleport", {
    Title = "Unlock All Island",
    Description = "unlock all the islands",
    Default = false,
    Callback = function(state)
        AutoTween = state

        if AutoTween then
            local targetPos = Vector3.new(5.7106, 16206.042, -8.6645)

            local character = game.Players.LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local hrp = character.HumanoidRootPart
                local tweenService = game:GetService("TweenService")

                local tweenInfo = TweenInfo.new(
                    20, -- tempo de transição (segundos)
                    Enum.EasingStyle.Linear,
                    Enum.EasingDirection.Out
                )

                local goal = { CFrame = CFrame.new(targetPos) }

                local tween = tweenService:Create(hrp, tweenInfo, goal)
                tween:Play()

                tween.Completed:Connect(function()
                    AutoTween = false
                end)
            end
        end
    end
})

local teleportLocations = {
    ["Twilight Island"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",
    ["Outer Space"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Spawn (Overworld)"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["The Void"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Floating Island"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
    ["Zen"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn"
    
}

for name, path in pairs(teleportLocations) do
    Tabs.Teleport:AddButton({
        Title = name,
        Description = "Teleport to " .. name,
        Callback = function()
            local RemoteEvent = game:GetService("ReplicatedStorage")
                :WaitForChild("Shared")
                :WaitForChild("Framework")
                :WaitForChild("Network")
                :WaitForChild("Remote")
                :WaitForChild("Event")

            RemoteEvent:FireServer("Teleport", path)

            Fluent:Notify({
                Title = "Teleport",
                Content = "Teleport to: " .. name,
                Duration = 3
            })
        end
    })
end

CodeSection:AddButton({
    Title = "Redeem Codes",
    Description = "Redeem all available codes",
    Callback = function()
        local codes = { "Release", "Thanks", "Lucky" }
        for _, code in ipairs(codes) do
            local success, result = pcall(function()
                return game:GetService("ReplicatedStorage")
                    .Shared.Framework.Network.Remote.Function
                    :InvokeServer("RedeemCode", code)
            end)
            if success then
            else
                warn("Error redeeming code:", code, result)
            end
            task.wait(2)
        end
    end
})

local AntiAfkConfig = {
    connection = nil
}

function AntiAfkConfig:Toggle(state)
    local player = game:GetService("Players").LocalPlayer
    if state then
        self.connection = player.Idled:Connect(function()
            local vu = game:GetService("VirtualUser")
            vu:CaptureController()
            vu:ClickButton2(Vector2.new())
        end)
    else
        if self.connection then
            self.connection:Disconnect()
            self.connection = nil
        end
    end
end

function AntiAfkConfig:Unload()
    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end
end

local Toggle = Tabs.Misc:AddToggle("MyToggle", {
    Title = "Anti AFK", 
    Default = false,
    Callback = function(state)
        if state then
            AntiAfkConfig:Toggle(true)
        else
            AntiAfkConfig:Toggle(false)
        end
    end
})

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/BubbleGumInfinity")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
Window:SelectTab(1) -- Seleciona a primeira aba ao abrir
Fluent:Notify({
    Title = "Bubble Gum Simulator INFINITY | DZ HUB",
    Content = "Script loaded successfully!",
    Duration = 5
})

local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")

-- Remove instância anterior
local ExistingGui = CoreGui:FindFirstChild("MinimizeButtonGui")
if ExistingGui then ExistingGui:Destroy() end

-- Procura a GUI principal
local ScreenGuiToMinimize
for _, gui in ipairs(CoreGui:GetChildren()) do
    if gui:IsA("ScreenGui") then
        for _, descendant in ipairs(gui:GetDescendants()) do
            if descendant:IsA("TextLabel") and descendant.Text == "Bubble Gum Simulator INFINITY | DZ HUB" then
                ScreenGuiToMinimize = gui
                break
            end
        end
    end
    if ScreenGuiToMinimize then break end
end

if not ScreenGuiToMinimize then
    warn("ScreenGui com o texto especificado não encontrado.")
    return
end

-- Cria GUI do botão
local MinimizeGui = Instance.new("ScreenGui", CoreGui)
MinimizeGui.Name = "MinimizeButtonGui"

local MinimizeButton = Instance.new("ImageButton", MinimizeGui)
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Size = UDim2.new(0, 50, 0, 50)
MinimizeButton.Position = UDim2.new(0.1, 0, 0.1, 0)
MinimizeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.BorderSizePixel = 0
MinimizeButton.ImageRectSize = Vector2.new(256, 256)

local UICorner = Instance.new("UICorner", MinimizeButton)

-- Animação do botão com múltiplas spritesheets
local spritesheets = {
    "rbxassetid://90726870075493",
    "rbxassetid://85859195506939",
    "rbxassetid://140138471003989",
    "rbxassetid://92694094525674"
}

local frameWidth, frameHeight = 256, 256
local framesPerSheet = 4
local totalFrames = #spritesheets * framesPerSheet
local currentFrame = 0

MinimizeButton.Image = spritesheets[1]

task.spawn(function()
    while true do
        currentFrame = (currentFrame + 1) % totalFrames
        local sheetIndex = math.floor(currentFrame / framesPerSheet) + 1
        local frameIndex = currentFrame % framesPerSheet

        MinimizeButton.Image = spritesheets[sheetIndex]
        MinimizeButton.ImageRectOffset = Vector2.new(frameIndex * frameWidth, 0)

        task.wait(0.01) -- ajuste de velocidade
    end
end)

-- Função de minimizar
MinimizeButton.MouseButton1Click:Connect(function()
    if Window and Window.Minimize then
        Window:Minimize()
    else
        warn("Minimize function not available")
    end
end)

-- Movimento do botão
local dragging = false
local dragStart, startPos

local function update(input)
    local delta = input.Position - dragStart
    MinimizeButton.Position = UDim2.new(
        startPos.X.Scale,
        startPos.X.Offset + delta.X,
        startPos.Y.Scale,
        startPos.Y.Offset + delta.Y
    )
end

MinimizeButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MinimizeButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

MinimizeButton.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        update(input)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        update(input)
    end
end)
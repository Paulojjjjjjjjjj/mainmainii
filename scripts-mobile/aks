local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Anime Kingdom Simulator | DZ HUB",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ 
        Title = "Main", 
        Icon = "rbxassetid://124620632231839" 
    }),
    AutoRaid = Window:AddTab({ 
        Title = "Auto Raid", 
        Icon = "swords"
    }),
    Dungeon = Window:AddTab({ 
        Title = "Dungeon", 
        Icon = "skull"
    }),
    Egg = Window:AddTab({ 
        Title = "Egg", 
        Icon = "egg" 
    }),
    Misc = Window:AddTab({ 
        Title = "Misc", 
        Icon = "scroll" 
    }),
    Settings = Window:AddTab({ 
        Title = "Settings", 
        Icon = "settings" 
    })
}

---------------------------------------------------
----------------------SECTION----------------------
local FarmingOptions = Tabs.Main:AddSection("Farming Options")
local AutoFarm = Tabs.Main:AddSection("AutoFarm")
local AFK = Tabs.Misc:AddSection("AFK")
----------------------SECTION----------------------
---------------------------------------------------

local player = game.Players.LocalPlayer

-- üîé Coletar IDs √∫nicos dos inimigos nas subpastas
local enemyIds = {}

for _, folder in pairs(workspace._ENEMIES.Server:GetChildren()) do
    for _, enemy in pairs(folder:GetChildren()) do
        if (enemy:IsA("Model") or enemy:IsA("BasePart")) and enemy:GetAttribute("Id") then
            local id = enemy:GetAttribute("Id")
            -- Ignorar o ID "TestDummy"
            if id ~= "TestDummy" and not table.find(enemyIds, id) then
                table.insert(enemyIds, id)
            end
        end
    end
end

table.sort(enemyIds) -- organiza os nomes no dropdown

-- üêæ MultiDropdown: Sele√ß√£o de inimigos
local selectedEnemies = {}

local EnemyDropdown = FarmingOptions:AddDropdown("EnemyDropdown", {
    Title = "Select Enemies",
    Description = "Select the enemies you want to farm.",
    Values = enemyIds,
    Multi = true,
    Default = {},
})

EnemyDropdown:OnChanged(function(value)
    selectedEnemies = {}
    for enemyId, selected in next, value do
        if selected and enemyId ~= "TestDummy" then
            table.insert(selectedEnemies, enemyId)
        end
    end
    print("Inimigos selecionados:", table.concat(selectedEnemies, ", "))
end)

FarmingOptions:AddButton({
    Title = "üîÑ Refresh Enemies",
    Description = "Reloads the list of available enemies.",
    Callback = function()
        enemyIds = {}

        for _, folder in pairs(workspace._ENEMIES.Server:GetChildren()) do
            for _, enemy in pairs(folder:GetChildren()) do
                if (enemy:IsA("Model") or enemy:IsA("BasePart")) and enemy:GetAttribute("Id") then
                    local id = enemy:GetAttribute("Id")
                    if id ~= "TestDummy" and not table.find(enemyIds, id) then
                        table.insert(enemyIds, id)
                    end
                end
            end
        end

        table.sort(enemyIds)

        -- Atualiza os valores do Dropdown
        EnemyDropdown:SetValues(enemyIds)
        EnemyDropdown:SetValue({}) -- opcional: limpa sele√ß√£o anterior

        print("Updated enemy dropdown!")
    end
})

-- üéØ Prioridade de farm
local prioridadeSelecionada = "Nearest"

local PrioridadeDropdown = FarmingOptions:AddDropdown("PrioridadeDropdown", {
    Title = "Farming Priority",
    Description = "Select the Auto Farm priority logic.",
    Values = {"Lowest", "Strongest", "Nearest"},
    Default = "Nearest",
})

PrioridadeDropdown:OnChanged(function(value)
    prioridadeSelecionada = value
    print("Selected priority:", prioridadeSelecionada)
end)

-- üß† L√≥gica de prioridade
local function getPrioritizedEnemy()
    local closestEnemy, lowestHPEnemy, highestHPEnemy
    local closestDist = math.huge
    local lowestHP = math.huge
    local highestHP = -math.huge

    local myPos = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position
    if not myPos then return nil end

    for _, folder in pairs(workspace._ENEMIES.Server:GetChildren()) do
        for _, enemyPart in pairs(folder:GetChildren()) do
            if (enemyPart:IsA("BasePart") or enemyPart:IsA("Model")) then
                local id = enemyPart:GetAttribute("Id")
                local hp = enemyPart:GetAttribute("HP")

                -- Ignorar inimigo com ID "TestDummy"
                if id and id ~= "TestDummy" and hp and table.find(selectedEnemies, id) and hp > 0 then
                    local pos = enemyPart:IsA("Model") and (enemyPart:FindFirstChild("HumanoidRootPart") or enemyPart.PrimaryPart) or enemyPart
                    if pos then
                        local dist = (pos.Position - myPos).Magnitude

                        if dist < closestDist then
                            closestDist = dist
                            closestEnemy = enemyPart
                        end

                        if hp < lowestHP then
                            lowestHP = hp
                            lowestHPEnemy = enemyPart
                        end

                        if hp > highestHP then
                            highestHP = hp
                            highestHPEnemy = enemyPart
                        end
                    end
                end
            end
        end
    end

    if prioridadeSelecionada == "Nearest" then
        return closestEnemy
    elseif prioridadeSelecionada == "Lowest" then
        return lowestHPEnemy
    elseif prioridadeSelecionada == "Strongest" then
        return highestHPEnemy
    end
end

local localPlayer = game.Players.LocalPlayer

-- üß≠ Fun√ß√£o de teleporte for√ßado para uma parte
local function forcedStepTeleport(destination)
    -- Esperar o personagem ser carregado
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        localPlayer.CharacterAdded:Wait() -- Aguarda o personagem ser adicionado
    end

    local root = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    -- Teleporta uma vez
    root.CFrame = CFrame.new(destination.Position + Vector3.new(0, 0, 0))
end

-- ‚¨á Atualiza a Callback da Toggle Auto Farm
local AutoFarmToggle = AutoFarm:AddToggle("AutoFarmToggle", {
    Title = "Auto Farm",
    Description = "Activates automatic farm on selected enemies.",
    Default = false,
    Callback = function(state)
        autoFarm = state
        if autoFarm then
            task.spawn(function()
                while autoFarm do
                    local enemy = getPrioritizedEnemy()
                    if enemy then
                        -- Teleporta at√© o inimigo uma vez
                        forcedStepTeleport(enemy)

                        -- Espera at√© que a vida do inimigo chegue a 0
                        while enemy and enemy:GetAttribute("HP") > 0 do
                            task.wait(0.5)
                        end
                    end

                    -- Ap√≥s o inimigo morrer, teleporta para o pr√≥ximo inimigo
                    task.wait(1) -- Aguarda 1 segundo antes de ir para o pr√≥ximo inimigo
                end
            end)
        end
    end    
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local userId = player.UserId

local remote = ReplicatedStorage:WaitForChild("ffrostflame_bridgenet2@1.0.0"):WaitForChild("dataRemoteEvent")
local petsFolder = workspace._PETS:FindFirstChild(tostring(userId))

-- üêæ Pega os nomes dos pets do jogador
local function getMyPetNames()
    local petNames = {}
    if petsFolder then
        for _, pet in pairs(petsFolder:GetChildren()) do
            table.insert(petNames, pet.Name)
        end
    end
    return petNames
end

-- üîç Pega todos os inimigos que s√£o Partes diretas nas subpastas
local function getAllEnemies()
    local enemies = {}
    for _, folder in pairs(workspace._ENEMIES.Server:GetChildren()) do
        for _, obj in pairs(folder:GetChildren()) do
            if obj:IsA("BasePart") then
                table.insert(enemies, obj)
            end
        end
    end
    return enemies
end

-- üß† Verifica qual inimigo n√£o est√° sendo atacado por seus pets dentro de 20 studs
local function getEnemyNotAttackedByMe()
    local myPets = getMyPetNames()
    local allEnemies = getAllEnemies()

    local closestEnemy = nil
    local closestDistance = 30  -- Limitar a 20 studs de dist√¢ncia
    local myPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position

    for _, enemyPart in ipairs(allEnemies) do
        local petsAttr = enemyPart:GetAttribute("Pets") or ""
        local isBeingAttacked = false

        -- Verifica se o atributo Pets existe e se n√£o est√° vazio
        print("Attribute Pets of " .. enemyPart.Name .. ": " .. petsAttr)
        
        -- Verifica se algum dos pets est√° atacando o inimigo
        for _, myPet in ipairs(myPets) do
            if petsAttr:find(myPet) then
                print("Pet " .. myPet .. " is attacking " .. enemyPart.Name)
                isBeingAttacked = true
                break
            end
        end

        -- Verifica a dist√¢ncia at√© o inimigo
        local dist = (enemyPart.Position - myPosition).Magnitude
        if dist <= closestDistance then
            print("Distance to " .. enemyPart.Name .. ": " .. dist)

            -- Se o atributo Pets estiver vazio ou o inimigo n√£o estiver sendo atacado, podemos atacar
            if (petsAttr == "" or not isBeingAttacked) then
                -- Verifica se o HP do inimigo √© maior que 0
                local enemyHP = enemyPart:GetAttribute("HP") or 0
                if enemyHP > 0 then
                    closestEnemy = enemyPart
                    closestDistance = dist
                end
            end
        end
    end

    if closestEnemy then
        print("Nearest enemy found: " .. closestEnemy.Name)
    else
        print("No enemy found to attack within 20 studs.")
    end

    return closestEnemy
end


-- ‚öîÔ∏è Fun√ß√£o para atacar inimigo (usando nome da Part)
local function attackEnemy(enemyPart)
    local petsAttr = enemyPart:GetAttribute("Pets") or ""

    -- Certifique-se de que o pet n√£o foi adicionado ao atributo m√∫ltiplas vezes
    local newPetsAttr = petsAttr
    for _, myPet in ipairs(getMyPetNames()) do
        if not newPetsAttr:find(myPet) then
            newPetsAttr = newPetsAttr .. myPet .. ","
            print("Adding a pet " .. myPet .. " the enemy " .. enemyPart.Name)
        end
    end

    -- Atualiza o atributo Pets do inimigo se necess√°rio
    if newPetsAttr ~= petsAttr then
        enemyPart:SetAttribute("Pets", newPetsAttr)
        print("Pets attribute updated to: " .. newPetsAttr)
    end

    -- Realiza o ataque
    print("Attacking enemy: " .. enemyPart.Name)
    local args = {
        {
            {
                "PetSystem",
                "Attack",
                enemyPart.Name,
                true,
                ["n"] = 4
            },
            "\2"
        }
    }
    remote:FireServer(unpack(args))
end

-- üîÑ Loop de auto attack
local attacking = false

AutoFarm:AddToggle("Auto Attack", {
    Title = "Auto Attack Nearest",
    Description = "Automatically attacks nearby enemies that are not being attacked by your pets.",
    Default = false,
    Callback = function(state)
        attacking = state
        task.spawn(function()
            while attacking do
                local target = getEnemyNotAttackedByMe()
                if target then
                    -- Verifica se a vida do inimigo chegou a 0
                    local enemyHP = target:GetAttribute("HP") or 0
                    if enemyHP > 0 then
                        attackEnemy(target)
                    else
                        print("enemy " .. target.Name .. " died. Waiting for respawn...")
                    end
                end
                task.wait(0.5)
            end
        end)
    end
})

-- üê∂ Auto Equip Best Pets
local autoEquipBest = false

AutoFarm:AddToggle("Auto Equip Best", {
    Title = "Auto Equip Best Pets",
    Description = "Automatically equips the best pets available.",
    Default = false,
    Callback = function(state)
        autoEquipBest = state
        task.spawn(function()
            while autoEquipBest do
                local args = {
                    [1] = {
                        [1] = {
                            [1] = "PetSystem",
                            [2] = "EquipBest",
                            ["n"] = 2
                        },
                        [2] = "\2"
                    }
                }

                remote:FireServer(unpack(args))
                task.wait(1) -- Tempo entre cada tentativa (pode ajustar)
            end
        end)
    end
})

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("ffrostflame_bridgenet2@1.0.0"):WaitForChild("dataRemoteEvent")

-- Raid System
local raidActive = false
local raidCooldown = 5 -- Intervalo de 5 segundos entre raides
local lastRaidTime = 0
local raidConnection

-- World selection dropdown
local worldOptions = {"World 1", "World 2", "World 3", "World 4", "World 5"}
local selectedWorld = worldOptions[1]

local Dropdown = Tabs.AutoRaid:AddDropdown("WorldDropdown", {
    Title = "Select World",
    Description = "Choose the world for Raid",
    Values = worldOptions,
    Multi = false,
    Default = 1,
})

Dropdown:OnChanged(function(Value)
    selectedWorld = Value
    Fluent:Notify({
        Title = "World Selected",
        Content = "Raid will use: "..Value,
        Duration = 3
    })
end)

-- Fun√ß√µes de Raid
local function createRaid()
    local args = {
        [1] = {
            [1] = {
                [1] = "RaidSystem",
                [2] = "Create",
                ["n"] = 2
            },
            [2] = "\2"
        }
    }
    remote:FireServer(unpack(args))
end

local function selectMap()
    local mapNumber = tonumber(string.match(selectedWorld, "%d+"))
    local args = {
        [1] = {
            [1] = {
                [1] = "RaidSystem",
                [2] = "SelectMap",
                [3] = mapNumber,
                ["n"] = 3
            },
            [2] = "\2"
        }
    }
    remote:FireServer(unpack(args))
end

local function startRaid()
    local args = {
        [1] = {
            [1] = {
                [1] = "RaidSystem",
                [2] = "Start",
                ["n"] = 2
            },
            [2] = "\2"
        }
    }
    remote:FireServer(unpack(args))
end

local function executeRaid()
    -- Verifica se o cooldown de raid foi respeitado
    if os.time() - lastRaidTime < raidCooldown then
        return
    end

    -- Processamento das etapas da raid
    createRaid()
    task.wait(5)  -- Aguarda 3 segundos antes de selecionar o mapa
    selectMap()
    task.wait(5)  -- Aguarda 3 segundos antes de iniciar a raid
    startRaid()
    
    -- Atualiza o tempo da √∫ltima raid
    lastRaidTime = os.time()
end

-- Auto Raid Toggle
Tabs.AutoRaid:AddToggle("AutoRaidToggle", {
    Title = "Auto Raid",
    Description = "Automatically runs raids",
    Default = false,
    Callback = function(state)
        raidActive = state
        if state then
            -- Verifica o intervalo de tempo e ativa a conex√£o para o Heartbeat
            raidConnection = game:GetService("RunService").Heartbeat:Connect(function()
                -- Limita as chamadas de raid com base no cooldown
                if os.time() - lastRaidTime >= raidCooldown then
                    executeRaid()  -- Executa a raid se o cooldown for atingido
                end
            end)
            Fluent:Notify({
                Title = "Auto Raid",
                Content = "Enabled - Running every "..raidCooldown.." seconds",
                Duration = 5
            })
        else
            -- Desativa a conex√£o do Heartbeat
            if raidConnection then
                raidConnection:Disconnect()
            end
            Fluent:Notify({
                Title = "Auto Raid",
                Content = "Disabled",
                Duration = 3
            })
        end
    end
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local userId = player.UserId

local remote = ReplicatedStorage:WaitForChild("ffrostflame_bridgenet2@1.0.0"):WaitForChild("dataRemoteEvent")
local petsFolder = workspace._PETS:FindFirstChild(tostring(userId))

-- üêæ Pega os nomes dos pets do jogador
local function getMyPetNames()
    local petNames = {}
    if petsFolder then
        for _, pet in pairs(petsFolder:GetChildren()) do
            table.insert(petNames, pet.Name)
        end
    end
    return petNames
end

-- üß≠ Teleporte for√ßado para uma parte
local function forcedStepTeleport(destination)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        player.CharacterAdded:Wait()
    end

    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    root.CFrame = CFrame.new(destination.Position + Vector3.new(0, 0, 0))
end

-- üîç Pega todos os inimigos da Raid
local function getRaidEnemies()
    local raidFolder = workspace._ENEMIES.Server:FindFirstChild("Raid")
    if not raidFolder then return {} end

    local myRaidFolder = raidFolder:FindFirstChild(tostring(userId))
    if not myRaidFolder then return {} end

    local enemies = {}
    for _, obj in pairs(myRaidFolder:GetChildren()) do
        if obj:IsA("BasePart") then
            table.insert(enemies, obj)
        end
    end
    return enemies
end

-- üß† Encontra o inimigo mais pr√≥ximo que ainda n√£o est√° sendo atacado por seus pets
local function getRaidEnemyNotAttacked()
    local myPets = getMyPetNames()
    local allEnemies = getRaidEnemies()

    local closestEnemy = nil
    local closestDistance = math.huge
    local myPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position

    for _, enemyPart in ipairs(allEnemies) do
        local petsAttr = enemyPart:GetAttribute("Pets") or ""
        local isBeingAttacked = false

        for _, myPet in ipairs(myPets) do
            if petsAttr:find(myPet) then
                isBeingAttacked = true
                break
            end
        end

        local dist = (enemyPart.Position - myPosition).Magnitude
        if dist < closestDistance and not isBeingAttacked then
            local enemyHP = enemyPart:GetAttribute("HP") or 0
            if enemyHP > 0 then
                closestEnemy = enemyPart
                closestDistance = dist
            end
        end
    end

    return closestEnemy
end

-- ‚öîÔ∏è Fun√ß√£o para atacar inimigo da Raid (sem alterar atributo)
local function attackRaidEnemy(enemyPart)
    local petsAttr = enemyPart:GetAttribute("Pets")
    local myPets = getMyPetNames()

    -- Se o inimigo j√° est√° sendo atacado por seus pets, n√£o faz nada
    if petsAttr and typeof(petsAttr) == "string" then
        for _, myPet in ipairs(myPets) do
            if petsAttr:find(myPet) then
                return -- j√° est√° atacando, ent√£o n√£o faz nada
            end
        end
    end

    -- Verifica se o HP do inimigo √© maior que 0 antes de atacar
    local enemyHP = enemyPart:GetAttribute("HP") or 0
    if enemyHP <= 0 then
        return -- n√£o ataca se o HP do inimigo for 0 ou negativo
    end

    -- Envia ataque
    local args = {
        {
            {
                "PetSystem",
                "Attack",
                enemyPart.Name,
                true,
                ["n"] = 4
            },
            "\2"
        }
    }
    remote:FireServer(unpack(args))
end


-- üîÑ Loop de auto attack na Raid (teleporta s√≥ 1 vez por inimigo)
local autoRaidAttack = false
local targetAtual = nil

Tabs.AutoRaid:AddToggle("Auto Attack (Raid)", {
    Title = "Auto Attack Raid",
    Description = "Automatically attacks enemies in your raid, with a single teleport per enemy.",
    Default = false,
    Callback = function(state)
        autoRaidAttack = state
        task.spawn(function()
            while autoRaidAttack do
                -- Se n√£o temos alvo ou o alvo morreu, procurar novo
                if not targetAtual or (targetAtual:GetAttribute("HP") or 0) <= 0 then
                    targetAtual = getRaidEnemyNotAttacked()
                    if targetAtual then
                        forcedStepTeleport(targetAtual) -- Teleporta s√≥ uma vez por inimigo
                    end
                end

                -- Ataca o inimigo atual, se a vida for maior que 0
                if targetAtual and (targetAtual:GetAttribute("HP") or 0) > 0 then
                    attackRaidEnemy(targetAtual)
                end

                task.wait(0.5)
            end

            targetAtual = nil
        end)
    end
})

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("ffrostflame_bridgenet2@1.0.0"):WaitForChild("dataRemoteEvent")

-- Dungeon System Variables
local dungeonActive = false
local dungeonCooldown = 30 -- seconds between dungeons
local lastDungeonTime = 0
local dungeonConnection

-- Dungeon Options
local dungeonMaps = {
    "RuinedPrison"
}

local difficultyOptions = {
    "Easy",
    "Medium",
    "Hard",
    "Insane",
    "Extreme",
    "Impossible"
}

-- Default Selections
local selectedMap = dungeonMaps[1]
local selectedDifficulty = difficultyOptions[1]

-- UI Elements
-- Map Selection Dropdown
local MapDropdown = Tabs.Dungeon:AddDropdown("MapDropdown", {
    Title = "Select Dungeon Map",
    Description = "Choose the dungeon map",
    Values = dungeonMaps,
    Multi = false,
    Default = 1,
})

MapDropdown:OnChanged(function(Value)
    selectedMap = Value
    Fluent:Notify({
        Title = "Map Selected",
        Content = "Selected: "..Value,
        Duration = 3
    })
end)

-- Difficulty Selection Dropdown
local DifficultyDropdown = Tabs.Dungeon:AddDropdown("DifficultyDropdown", {
    Title = "Select Difficulty",
    Description = "Choose the dungeon difficulty",
    Values = difficultyOptions,
    Multi = false,
    Default = 1,
})

DifficultyDropdown:OnChanged(function(Value)
    selectedDifficulty = Value
    Fluent:Notify({
        Title = "Difficulty Selected",
        Content = "Selected: "..Value,
        Duration = 3
    })
end)

-- Dungeon Functions
local function createDungeon()
    local args = {
        [1] = {
            [1] = {
                [1] = "DungeonSystem",
                [2] = "Create",
                ["n"] = 2
            },
            [2] = "\2"
        }
    }
    remote:FireServer(unpack(args))
end

local function selectMap()
    local args = {
        [1] = {
            [1] = {
                [1] = "DungeonSystem",
                [2] = "SelectMap",
                [3] = selectedMap,
                ["n"] = 3
            },
            [2] = "\2"
        }
    }
    remote:FireServer(unpack(args))
end

local function selectDifficulty()
    local args = {
        [1] = {
            [1] = {
                [1] = "DungeonSystem",
                [2] = "SelectDiff",
                [3] = selectedDifficulty,
                ["n"] = 3
            },
            [2] = "\2"
        }
    }
    remote:FireServer(unpack(args))
end

local function startDungeon()
    local args = {
        [1] = {
            [1] = {
                [1] = "DungeonSystem",
                [2] = "Start",
                ["n"] = 2
            },
            [2] = "\2"
        }
    }
    remote:FireServer(unpack(args))
end

local function executeDungeon()
    if os.time() - lastDungeonTime < dungeonCooldown then return end -- Verifica se o cooldown foi atingido

    -- Previne spam
    lastDungeonTime = os.time()

    createDungeon()
    task.wait(0.5)
    selectMap()
    task.wait(0.5)
    selectDifficulty()
    task.wait(0.5)
    startDungeon()
    
    Fluent:Notify({
        Title = "Dungeon Started",
        Content = string.format("Running %s on %s difficulty", selectedMap, selectedDifficulty),
        Duration = 5
    })
end

-- Auto Dungeon Toggle
Tabs.Dungeon:AddToggle("AutoDungeonToggle", {
    Title = "Auto Dungeon",
    Description = "Automatically runs dungeons",
    Default = false,
    Callback = function(state)
        dungeonActive = state
        if state then
            dungeonConnection = game:GetService("RunService").Heartbeat:Connect(function()
                -- Verifica se o cooldown foi cumprido antes de chamar executeDungeon
                if os.time() - lastDungeonTime >= dungeonCooldown then
                    executeDungeon()
                end
            end)
            Fluent:Notify({
                Title = "Auto Dungeon",
                Content = "Enabled - Running every "..dungeonCooldown.." seconds",
                Duration = 5
            })
        else
            if dungeonConnection then
                dungeonConnection:Disconnect()
            end
            Fluent:Notify({
                Title = "Auto Dungeon",
                Content = "Disabled",
                Duration = 3
            })
        end
    end
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local userId = player.UserId

local remote = ReplicatedStorage:WaitForChild("ffrostflame_bridgenet2@1.0.0"):WaitForChild("dataRemoteEvent")
local petsFolder = workspace._PETS:FindFirstChild(tostring(userId))

-- üêæ Pega os nomes dos pets do jogador
local function getMyPetNames()
    local petNames = {}
    if petsFolder then
        for _, pet in pairs(petsFolder:GetChildren()) do
            table.insert(petNames, pet.Name)
        end
    end
    return petNames
end

-- üß≠ Teleporte for√ßado para uma parte
local function forcedStepTeleport(destination)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        player.CharacterAdded:Wait()
    end

    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    root.CFrame = CFrame.new(destination.Position + Vector3.new(0, 0, 0))
end

-- üîç Pega todos os inimigos da Dungeon
local function getDungeonEnemies()
    local dungeonFolder = workspace._ENEMIES.Server:FindFirstChild("Dungeon")
    if not dungeonFolder then return {} end

    local myDungeonFolder = dungeonFolder:FindFirstChild(tostring(userId))
    if not myDungeonFolder then return {} end

    local enemies = {}
    for _, obj in pairs(myDungeonFolder:GetChildren()) do
        if obj:IsA("BasePart") then
            table.insert(enemies, obj)
        end
    end
    return enemies
end

-- üß† Encontra o inimigo mais pr√≥ximo que ainda n√£o est√° sendo atacado por seus pets
local function getDungeonEnemyNotAttacked()
    local myPets = getMyPetNames()
    local allEnemies = getDungeonEnemies()

    local closestEnemy = nil
    local closestDistance = math.huge
    local myPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position

    for _, enemyPart in ipairs(allEnemies) do
        local petsAttr = enemyPart:GetAttribute("Pets") or ""
        local isBeingAttacked = false

        for _, myPet in ipairs(myPets) do
            if petsAttr:find(myPet) then
                isBeingAttacked = true
                break
            end
        end

        local dist = (enemyPart.Position - myPosition).Magnitude
        if dist < closestDistance and not isBeingAttacked then
            local enemyHP = enemyPart:GetAttribute("HP") or 0
            if enemyHP > 0 then
                closestEnemy = enemyPart
                closestDistance = dist
            end
        end
    end

    return closestEnemy
end

-- ‚öîÔ∏è Fun√ß√£o para atacar inimigo da Dungeon (sem alterar atributo)
local function attackDungeonEnemy(enemyPart)
    local petsAttr = enemyPart:GetAttribute("Pets")
    local myPets = getMyPetNames()

    -- Se o inimigo j√° est√° sendo atacado por seus pets, n√£o faz nada
    if petsAttr and typeof(petsAttr) == "string" then
        for _, myPet in ipairs(myPets) do
            if petsAttr:find(myPet) then
                return -- j√° est√° atacando, ent√£o n√£o faz nada
            end
        end
    end

    -- Verifica se o HP do inimigo √© maior que 0 antes de atacar
    local enemyHP = enemyPart:GetAttribute("HP") or 0
    if enemyHP <= 0 then
        return -- n√£o ataca se o HP do inimigo for 0 ou negativo
    end

    -- Envia ataque
    local args = {
        {
            {
                "PetSystem",
                "Attack",
                enemyPart.Name,
                true,
                ["n"] = 4
            },
            "\2"
        }
    }
    remote:FireServer(unpack(args))
end

-- üîÑ Loop de auto ataque na Dungeon (teleporta s√≥ 1 vez por inimigo)
local autoDungeonAttack = false
local targetAtual = nil

Tabs.Dungeon:AddToggle("Auto Attack Dungeon", {
    Title = "Auto Attack (Dungeon)",
    Description = "Automatically attacks enemies in your dungeon, with a single teleport per enemy.",
    Default = false,
    Callback = function(state)
        autoDungeonAttack = state
        task.spawn(function()
            while autoDungeonAttack do
                -- Se n√£o temos alvo ou o alvo morreu, procurar novo
                if not targetAtual or (targetAtual:GetAttribute("HP") or 0) <= 0 then
                    targetAtual = getDungeonEnemyNotAttacked()
                    if targetAtual then
                        forcedStepTeleport(targetAtual) -- Teleporta s√≥ uma vez por inimigo
                    end
                end

                -- Ataca o inimigo atual, se a vida for maior que 0
                if targetAtual and (targetAtual:GetAttribute("HP") or 0) > 0 then
                    attackDungeonEnemy(targetAtual)
                end

                task.wait(0.5)
            end

            targetAtual = nil
        end)
    end
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("ffrostflame_bridgenet2@1.0.0"):WaitForChild("dataRemoteEvent")

local localPlayer = Players.LocalPlayer
local hrp = localPlayer.Character:WaitForChild("HumanoidRootPart")

local selectedEgg = nil
local hatchMode = "One"
local autoHatchEnabled = false

-- CFrame de cada egg
local EggPositions = {
    ["Slayer Star"] = CFrame.new(2453.99, 103.38, -249.34),
    ["Punch Star"] = CFrame.new(2726.92, 184.99, -5146.72),
    ["Titan Star"] = CFrame.new(2550.88, 109.06, -2370.32),
    ["Cursed Star"] = CFrame.new(2665.92, 98.09, -7507.78),
    ["Player Star"] = CFrame.new(2706.18, 113.30, -10215.18),
    ["Pirate Star"] = CFrame.new(5055.65, 156.99, -130.66),
}

-- Dropdown: Nome do Ovo
local EggList = {}
for name, _ in pairs(EggPositions) do
    table.insert(EggList, name)
end

local EggDropdown = Tabs.Egg:AddDropdown("EggNameDropdown", {
    Title = "Selecting Egg",
    Description = "Choose the egg you want to crack open.",
    Values = EggList,
    Default = "Slayer Star",
})

EggDropdown:OnChanged(function(value)
    selectedEgg = value
    print("Selected egg: ", selectedEgg)
end)

-- Dropdown: Modo (Single ou Multi)
local HatchModeDropdown = Tabs.Egg:AddDropdown("HatchModeDropdown", {
    Title = "Hatch mode",
    Values = {"One", "All"},
    Default = "One",
})

HatchModeDropdown:OnChanged(function(value)
    hatchMode = value
    print("Hatch mode:", hatchMode)
end)

-- Toggle: Auto Hatch com teleporte
Tabs.Egg:AddToggle("AutoHatchRemoteToggle", {
    Title = "Auto Hatch (Remote)",
    Description = "Activates Auto Hatch with teleport.",
    Default = false,
    Callback = function(state)
        autoHatchEnabled = state

        if autoHatchEnabled then
            task.spawn(function()
                while autoHatchEnabled do
                    if selectedEgg and hatchMode and EggPositions[selectedEgg] then
                        -- Teleporta antes de abrir o ovo
                        pcall(function()
                            hrp.CFrame = EggPositions[selectedEgg]
                        end)

                        task.wait(0.5) -- espera pequeno antes de dar hatch

                        local args = {
                            [1] = {
                                [1] = {
                                    [1] = "PetSystem",
                                    [2] = "Open",
                                    [3] = selectedEgg,
                                    [4] = hatchMode,
                                    ["n"] = 4
                                },
                                [2] = "\2"
                            }
                        }

                        remote:FireServer(unpack(args))
                        print("Teleported and opened::", selectedEgg, "| Mode:", hatchMode)
                    end

                    task.wait(2)
                end
            end)
        end
    end
})

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

-- Definir atributo VIP como true
localPlayer:SetAttribute("VIP", true)
print("VIP attribute set to true.")

-- Adicionando bot√£o com a descri√ß√£o
Tabs.Misc:AddButton({
    Title = "Free VIP",
    Callback = function()
        print("VIP FREE!!!!")
    end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("ffrostflame_bridgenet2@1.0.0"):WaitForChild("dataRemoteEvent")

-- Fun√ß√£o para enviar c√≥digo
local function sendCode(code)
    local args = {
        [1] = {
            [1] = {
                [1] = "CodeSystem",
                [2] = "Use",
                [3] = code, -- Coloque o c√≥digo desejado aqui
                ["n"] = 3
            },
            [2] = "\2"
        }
    }

    remote:FireServer(unpack(args))
    print("Code sent:", code)
end

-- Exemplo de c√≥digos para enviar
local codes = {
    "Update2AKS",  -- 5 Armament Tokens and 1x All Potions Tier 1 (NEW)
    "thebest100klikes", -- 25 Crystals (NEW)
    "gracias90klikes", -- 25 Enchantment Tokens and 25 Passive Tokens (NEW)
    "tyfor80klikes", -- 2x All Potions Tier 2 (NEW)
    "SHUTDOWN", -- Reset Raid and Dungeon Cooldown (NEW)
    "TyFor50K", -- 25 Crystals
    "Nice60kLikes", -- 2x All Potions Tier 1
    "OMG70kLikes", -- 2x All Potions Tier 2
    "Update1", -- 5 Enchantment Tokens, 25 Crystals
    "40kOMG", -- 2x All Potions Tier 1
    "THXFOR30K", -- 1x All Potions Tier 1
    "20klikes", -- 1x All Potions Tier 1
    "10KLIKES", -- 1x All Potions Tier 1
    "Release" -- 1x All Potions Tier 2
}

-- Chama a fun√ß√£o sendCode para cada c√≥digo
for _, code in ipairs(codes) do
    sendCode(code)
end

-- Adiciona o bot√£o na interface
Tabs.Misc:AddButton({
    Title = "Redeem Codes",
    Callback = function()
        for _, code in ipairs(codes) do
            sendCode(code)
        end
        print("All the codes have been sent.")
    end
})

-- Anti AFK
local AntiAfkConfig = {
    connection = nil
}

function AntiAfkConfig:Toggle(state)
    local player = game:GetService("Players").LocalPlayer
    if state then
        -- Ativa o Anti AFK
        self.connection = player.Idled:Connect(function()
            local vu = game:GetService("VirtualUser")
            vu:CaptureController()
            vu:ClickButton2(Vector2.new())
        end)
    else
        -- Desativa o Anti AFK
        if self.connection then
            self.connection:Disconnect()
            self.connection = nil
        end
    end
end

function AntiAfkConfig:Unload()
    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end
end

-- Toggle para ligar/desligar o Anti AFK
local Toggle = AFK:AddToggle("MyToggle", {
    Title = "Anti AFK", 
    Default = false,
    Callback = function(state)
        if state then
            -- Ativa o Anti AFK
            AntiAfkConfig:Toggle(true)
            print("Anti AFK enabled")
        else
            -- Desativa o Anti AFK
            AntiAfkConfig:Toggle(false)
            print("Anti AFK disabled")
        end
    end
})


SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
Window:SelectTab(1) -- Seleciona a primeira aba ao abrir
Fluent:Notify({
    Title = "Anime Kingdom Simulator | DZ HUB",
    Content = "Script loaded successfully!",
    Duration = 5
})

local CoreGui = game:GetService("CoreGui")

-- Remover qualquer GUI persistente anterior com o mesmo nome
local ExistingGui = CoreGui:FindFirstChild("MinimizeButtonGui")
if ExistingGui then
    ExistingGui:Destroy()
end

local ScreenGuiToMinimize

-- Itera por todos os ScreenGuis no CoreGui para encontrar o correto
for _, gui in ipairs(CoreGui:GetChildren()) do
    if gui:IsA("ScreenGui") then
        for _, descendant in ipairs(gui:GetDescendants()) do
            if descendant:IsA("TextLabel") and descendant.Text == "Anime Kingdom Simulator | DZ HUB" then
                ScreenGuiToMinimize = gui
                break
            end
        end
    end
    if ScreenGuiToMinimize then break end
end

if not ScreenGuiToMinimize then
    warn("ScreenGui com o texto especificado n√£o encontrado.")
    return
end

print("ScreenGui encontrado:", ScreenGuiToMinimize.Name)

-- Criar bot√£o persistente
local MinimizeGui = Instance.new("ScreenGui", CoreGui)
MinimizeGui.Name = "MinimizeButtonGui"

local MinimizeButton = Instance.new("ImageButton", MinimizeGui)
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Size = UDim2.new(0, 44, 0, 45)
MinimizeButton.Position = UDim2.new(0.1, 0, 0.1, 0)
MinimizeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.BorderSizePixel = 0
MinimizeButton.Image = "rbxassetid://101109248169642" -- Substitua pelo ID da imagem desejado

-- Adicionar UICorner ao bot√£o para arredondar bordas
local UICorner = Instance.new("UICorner", MinimizeButton)

-- Fun√ß√£o para minimizar corretamente
MinimizeButton.MouseButton1Click:Connect(function()
    if Window and Window.Minimize then
        Window:Minimize()
    else
        warn("Fun√ß√£o Window:Minimize n√£o est√° dispon√≠vel.")
    end
end)

-- Adicionar funcionalidade de arrastar o bot√£o
local dragging = false
local dragStart, startPos

local function update(input)
    local delta = input.Position - dragStart
    MinimizeButton.Position = UDim2.new(
        startPos.X.Scale,
        startPos.X.Offset + delta.X,
        startPos.Y.Scale,
        startPos.Y.Offset + delta.Y
    )
end

MinimizeButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MinimizeButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

MinimizeButton.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        update(input)
    end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        update(input)
    end
end)

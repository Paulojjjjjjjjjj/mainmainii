local function fancyNotify(step, total)
    local percentage = math.floor((step / total) * 100)
    local barLength = 20
    local filledLength = math.floor((step / total) * barLength)
    local bar = string.rep("█", filledLength) .. string.rep("░", barLength - filledLength)

    game.StarterGui:SetCore("SendNotification", {
        Title = "⚔️ DZHUB ⚔️",
        Text = "🔄 Loading... " .. percentage .. "%\n[" .. bar .. "]",
        Duration = 1
    })
end

-- Example loading animation
task.spawn(function()
    local totalSteps = 15
    for i = 1, totalSteps do
        fancyNotify(i, totalSteps)
        task.wait(0.1)
    end

    -- Final notification
    game.StarterGui:SetCore("SendNotification", {
        Title = "✅ DZHUB",
        Text = "Loading completed!",
        Duration = 2
    })
end)
task.wait(4)

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Arise Crossover | DZHUB",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ Title = "Main"}),
    Dungeon = Window:AddTab({ Title = "Dungeon"}),
    Teleport = Window:AddTab({ Title = "Teleport"}),
    Misc = Window:AddTab({ Title = "Misc"}),
    Settings = Window:AddTab({ Title = "Settings"})
}

---------------------------------------------------
----------------------SECTION----------------------
local FarmingOptions = Tabs.Main:AddSection("Farming Options")
local AutoFarm = Tabs.Main:AddSection("AutoFarm")
local Action = Tabs.Main:AddSection("Action Options")
local DungeonFarm = Tabs.Dungeon:AddSection("Dungeon Farm")
local Mounts = Tabs.Teleport:AddSection("Mounts")
local TeleportWorlds = Tabs.Teleport:AddSection("Teleport All")
local SpecialLocations = Tabs.Teleport:AddSection("Special Locations")
----------------------SECTION----------------------
---------------------------------------------------

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local enemiesFolder = workspace.__Main.__Enemies.Client
local enemiesServer = workspace.__Main.__Enemies.Server

local lastNames = {}
local selectedEnemyName = nil
local selectedScaleFilter = "Small"
local autoTpEnabled = false

-- Função de teleporte igual ao Auto Dungeon
local function forcedStepTeleport(destination)
    local root = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    for i = 1, 10 do
        root.CFrame = CFrame.new(destination + Vector3.new(0, 0, 0))
        task.wait(0.000000005)
    end
end

-- Teleportar para o inimigo com offset
local function teleportToEnemy(enemy)
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    local part = enemy.PrimaryPart or enemy:FindFirstChildWhichIsA("BasePart")
    if not hrp or not part then return end

    local goalPosition = part.Position + Vector3.new(3, 0, 0)
    forcedStepTeleport(goalPosition)
end

-- Encontrar próximo inimigo com nome igual, HP > 0 e filtro de Scale
local function findNextEnemy()
    for _, npc in pairs(enemiesFolder:GetChildren()) do
        local title = npc:FindFirstChild("HealthBar")
            and npc.HealthBar:FindFirstChild("Main")
            and npc.HealthBar.Main:FindFirstChild("Title")

        if title and title.Text == selectedEnemyName then
            local enemyName = npc.Name
            local matchedServerEnemy = nil

            -- Buscar no servidor o inimigo correspondente
            for _, world in pairs(enemiesServer:GetChildren()) do
                local serverEnemy = world:FindFirstChild(enemyName)
                if serverEnemy then
                    local scale = serverEnemy:GetAttribute("Scale")
                    local hp = serverEnemy:GetAttribute("HP")

                    local isScaleMatch = (
                        (selectedScaleFilter == "Normal" and scale == 1) or
                        (selectedScaleFilter == "Big" and scale == 2)
                    )

                    if hp and hp > 0 and isScaleMatch then
                        matchedServerEnemy = npc
                        break
                    end
                end
            end

            if matchedServerEnemy then
                return matchedServerEnemy
            end
        end
    end
    return nil
end

-- Dropdown de inimigos
local enemyDropdown = FarmingOptions:AddDropdown("EnemyDropdown", {
    Title = "Choose your enemy",
    Values = {},
    Multi = false,
    Default = 1,
    Callback = function(value)
        selectedEnemyName = value
    end
})

-- Dropdown de filtro de tamanho (Scale)
local scaleDropdown = FarmingOptions:AddDropdown("ScaleFilter", {
    Title = "Enemy Size",
    Values = {"Small", "Big"},
    Default = 1,
    Callback = function(value)
        selectedScaleFilter = value
    end
})

-- Toggle de auto farm
AutoFarm:AddToggle("AutoFarm Selected", {
    Title = "Auto Farm Selected",
    Default = false,
    Callback = function(state)
        autoTpEnabled = state
        if state then
            task.spawn(function()
                while autoTpEnabled and task.wait(0.5) do
                    local enemy = findNextEnemy()
                    if enemy then
                        teleportToEnemy(enemy:FindFirstChild("Model"))
                    else
                        task.wait(2)
                    end
                end
            end)
        end
    end
})

-- Atualizar lista de inimigos no dropdown
function updateDropdown()
    local names = {}

    for _, npc in pairs(enemiesFolder:GetChildren()) do
        local success, result = pcall(function()
            local title = npc:FindFirstChild("HealthBar")
                and npc.HealthBar:FindFirstChild("Main")
                and npc.HealthBar.Main:FindFirstChild("Title")
            return title and title.Text
        end)

        if success and result and not table.find(names, result) then
            table.insert(names, result)
        end
    end

    table.sort(names)

    if #names ~= #lastNames or table.concat(names) ~= table.concat(lastNames) then
        lastNames = names
        enemyDropdown:SetValues(names)

        if selectedEnemyName == nil or not table.find(names, selectedEnemyName) then
            selectedEnemyName = names[1] or nil
        end
    end
end

-- Loop para atualizar dropdown constantemente
task.spawn(function()
    while task.wait(2) do
        updateDropdown()
    end
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local BridgeNet2 = ReplicatedStorage:WaitForChild("BridgeNet2")
local dataRemoteEvent = BridgeNet2:WaitForChild("dataRemoteEvent")

local LocalPlayer = Players.LocalPlayer
local ToggleValue = false

-- Create the toggle (assuming you're using a library like Rayfield)
local Toggle = Action:AddToggle("AutoCapture", {Title = "Auto Capture", Default = false })

Toggle:OnChanged(function(Value)
    ToggleValue = Value
    if Value then
        warn("Auto Capture Enabled")
    else
        warn("Auto Capture Disabled")
    end
end)

-- Function to find the nearest enemy
local function findNearestEnemy()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end
    
    local rootPart = character.HumanoidRootPart
    local enemies = workspace.__Main.__Enemies.Client:GetChildren()
    local closestEnemy = nil
    local shortestDistance = math.huge
    
    for _, enemy in ipairs(enemies) do
        if enemy:FindFirstChild("HumanoidRootPart") then
            local distance = (rootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                closestEnemy = enemy
            end
        end
    end
    
    return closestEnemy
end

-- Main loop
local connection
Toggle:OnChanged(function(Value)
    ToggleValue = Value
    
    if connection then
        connection:Disconnect()
        connection = nil
    end
    
    if Value then
        connection = RunService.Heartbeat:Connect(function()
            local nearestEnemy = findNearestEnemy()
            if nearestEnemy then
                local args = {
                    [1] = {
                        [1] = {
                            ["Event"] = "EnemyCapture",
                            ["Enemy"] = nearestEnemy.Name
                        },
                        [2] = "\4"
                    }
                }
                dataRemoteEvent:FireServer(unpack(args))
            end
        end)
    end
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local BridgeNet2 = ReplicatedStorage:WaitForChild("BridgeNet2")
local dataRemoteEvent = BridgeNet2:WaitForChild("dataRemoteEvent")

local LocalPlayer = Players.LocalPlayer
local ToggleValue = false

-- Create the toggle (assuming you're using a library like Rayfield)
local Toggle = Action:AddToggle("AutoDestroy", {Title = "Auto Destroy", Default = false })

Toggle:OnChanged(function(Value)
    ToggleValue = Value
    if Value then
        warn("Auto Destroy Enabled")
    else
        warn("Auto Destroy Disabled")
    end
end)

-- Function to find the nearest enemy
local function findNearestEnemy()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end
    
    local rootPart = character.HumanoidRootPart
    local enemies = workspace.__Main.__Enemies.Client:GetChildren()
    local closestEnemy = nil
    local shortestDistance = math.huge
    
    for _, enemy in ipairs(enemies) do
        if enemy:FindFirstChild("HumanoidRootPart") then
            local distance = (rootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                closestEnemy = enemy
            end
        end
    end
    
    return closestEnemy
end

-- Main loop
local connection
Toggle:OnChanged(function(Value)
    ToggleValue = Value
    
    if connection then
        connection:Disconnect()
        connection = nil
    end
    
    if Value then
        connection = RunService.Heartbeat:Connect(function()
            local nearestEnemy = findNearestEnemy()
            if nearestEnemy then
                local args = {
                    [1] = {
                        [1] = {
                            ["Event"] = "EnemyDestroy",
                            ["Enemy"] = nearestEnemy.Name
                        },
                        [2] = "\4"
                    }
                }
                dataRemoteEvent:FireServer(unpack(args))
            end
        end)
    end
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local BridgeNet2 = ReplicatedStorage:WaitForChild("BridgeNet2")
local dataRemoteEvent = BridgeNet2:WaitForChild("dataRemoteEvent")

local LocalPlayer = Players.LocalPlayer
local ToggleValue = false

-- Create the toggle (assuming you're using a library like Rayfield)
local Toggle = AutoFarm:AddToggle("AutoPunch", {Title = "Auto Punch (Kill Aura)", Default = false })

Toggle:OnChanged(function(Value)
    ToggleValue = Value
    if Value then
        warn("Auto Punch (Kill Aura) Enabled")
    else
        warn("Auto Punch (Kill Aura) Disabled")
    end
end)

-- Function to find the nearest enemy
local function findNearestEnemy()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end
    
    local rootPart = character.HumanoidRootPart
    local enemies = workspace.__Main.__Enemies.Client:GetChildren()
    local closestEnemy = nil
    local shortestDistance = math.huge
    
    for _, enemy in ipairs(enemies) do
        if enemy:FindFirstChild("HumanoidRootPart") then
            local distance = (rootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                closestEnemy = enemy
            end
        end
    end
    
    return closestEnemy
end

-- Main loop
local connection
Toggle:OnChanged(function(Value)
    ToggleValue = Value
    
    if connection then
        connection:Disconnect()
        connection = nil
    end
    
    if Value then
        connection = RunService.Heartbeat:Connect(function()
            local nearestEnemy = findNearestEnemy()
            if nearestEnemy then
                local args = {
                    [1] = {
                        [1] = {
                            ["Event"] = "PunchAttack",
                            ["Enemy"] = nearestEnemy.Name
                        },
                        [2] = "\4"
                    }
                }
                dataRemoteEvent:FireServer(unpack(args))
            end
        end)
    end
end)

local running = false

local Toggle = AutoFarm:AddToggle("AutoEquipBestShadows", {
    Title = "Auto Equip Best Shadows",
    Default = false,
    Callback = function(state)
        running = state -- Define o estado da variável
        
        if state then
            task.spawn(function()
                while running do -- Verifica se o toggle ainda está ativado
                    local player = game:GetService("Players").LocalPlayer
                    local inventory = player.leaderstats.Inventory.Pets
                    local equippedPets = player.leaderstats.Equips.Pets
                    local passes = player.leaderstats.Passes

                    -- Definir quantidade máxima de pets com base na Game Pass
                    local maxPets = passes:FindFirstChild("ExtraEquip") and passes.ExtraEquip.Value and 7 or 4

                    if inventory then
                        -- Criar uma tabela para armazenar os pets com seus ranks
                        local petsTable = {}

                        for _, pet in pairs(inventory:GetChildren()) do
                            local rank = pet:GetAttribute("Rank") or 0 -- Pega o rank do pet
                            table.insert(petsTable, {Name = pet.Name, Rank = rank})
                        end

                        -- Ordenar os pets do maior para o menor rank
                        table.sort(petsTable, function(a, b)
                            return a.Rank > b.Rank
                        end)

                        -- Criar uma lista de pets que já estão equipados
                        local currentlyEquipped = {}
                        for _, petSlot in pairs(equippedPets:GetChildren()) do
                            table.insert(currentlyEquipped, petSlot.Value)
                        end

                        -- Definir os melhores pets para equipar
                        local petsToEquip = {}
                        for i = 1, math.min(maxPets, #petsTable) do
                            local petName = petsTable[i].Name
                            if not table.find(currentlyEquipped, petName) then
                                table.insert(petsToEquip, petName)
                            end
                        end

                        -- Verifica se há pets novos para equipar
                        if #petsToEquip > 0 then
                            local args = {
                                [1] = {
                                    [1] = {
                                        ["Event"] = "EquipBest",
                                        ["Pets"] = petsToEquip
                                    },
                                    [2] = "\t"
                                }
                            }

                            -- Enviar a solicitação para equipar os novos pets
                            game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
                        end
                    end

                    task.wait(5) -- Ajuste o tempo de espera conforme necessário
                end
            end)
        end
    end
})

local player = game:GetService("Players").LocalPlayer
local userId = tostring(player.UserId)
local petsFolder = workspace.__Main.__Pets:FindFirstChild(userId)
local enemiesFolder = workspace.__Main.__Enemies:FindFirstChild("Client")
local remoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

local autoAttackEnabled = false
local lastTarget = nil -- Armazena o último inimigo atacado

local function hasExtraEquip()
    local passes = player.leaderstats.Passes
    return passes and passes:FindFirstChild("ExtraEquip") and passes.ExtraEquip.Value
end

local function getEquippedPets()
    local equippedPets = {}
    local petsData = player.leaderstats.Equips.Pets
    local maxPets = hasExtraEquip() and 7 or 4

    for i = 1, maxPets do
        local petName = petsData:GetAttribute(tostring(i))
        if petName then
            table.insert(equippedPets, petName)
        end
    end

    return equippedPets
end

local function getPetPositions()
    local equippedPets = getEquippedPets()
    local petPositions = {}

    if petsFolder then
        for _, petName in ipairs(equippedPets) do
            local petModelFolder = petsFolder:FindFirstChild(petName)
            if petModelFolder then
                local petModel = petModelFolder:FindFirstChildWhichIsA("Model")
                if petModel and petModel.PrimaryPart then
                    petPositions[petName] = petModel.PrimaryPart.Position
                end
            end
        end
    end

    return petPositions
end

local function getClosestEnemy()
    if not enemiesFolder then return nil end

    local closestEnemy = nil
    local minDistance = math.huge
    local playerPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position

    if not playerPosition then return nil end

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") then
            local enemyPart = enemy.PrimaryPart or enemy:FindFirstChildWhichIsA("BasePart")
            if enemyPart then
                local distance = (enemyPart.Position - playerPosition).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    closestEnemy = enemy
                end
            end
        end
    end

    return closestEnemy
end

local function attackShadow()
    while autoAttackEnabled do
        local enemy = getClosestEnemy()
        if enemy then
            local enemyName = enemy.Name
            local enemyHealthText = enemy:FindFirstChild("HealthBar") 
                and enemy.HealthBar:FindFirstChild("Main") 
                and enemy.HealthBar.Main:FindFirstChild("Bar") 
                and enemy.HealthBar.Main.Bar:FindFirstChild("Amount") 
                and enemy.HealthBar.Main.Bar.Amount.Text

            local enemyHealth = enemyHealthText and tonumber(enemyHealthText:match("%d+")) or 0

            if enemyHealth > 0 then
                if lastTarget ~= enemyName then -- Evita atacar o mesmo inimigo repetidamente
                    lastTarget = enemyName

                    local petPositions = getPetPositions()
                    if next(petPositions) then
                        local args = {
                            [1] = {
                                [1] = {
                                    ["PetPos"] = petPositions,
                                    ["AttackType"] = "All",
                                    ["Event"] = "Attack",
                                    ["Enemy"] = enemyName
                                },
                                [2] = "\5"
                            }
                        }

                        remoteEvent:FireServer(unpack(args))
                    end
                end
            else
                lastTarget = nil -- Reseta o alvo para buscar um novo
            end
        else
            lastTarget = nil
        end

        task.wait(1)
    end
end

-- Toggle para ativar/desativar o Auto Attack Shadow
local Toggle = AutoFarm:AddToggle("AutoAttackNearestEnemy", {
    Title = "Auto Attack Nearest Enemy",
    Default = false,
    Callback = function(state)
        autoAttackEnabled = state
        if state then
            lastTarget = nil -- Reseta o último inimigo quando ativado
            task.spawn(attackShadow)
        end
    end
})

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local MountLocations = {
    Vector3.new(-6160.187, 78.217, 5455.171),
    Vector3.new(3306.613, 83.159, 14.523),
    Vector3.new(-5902.75, 91.000, 419.425),
    Vector3.new(418.633, 57.633, 3371.146),
    Vector3.new(4295.754, 59.064, -4734.791),
    Vector3.new(-623.221, 107.756, -3567.257),
    Vector3.new(-5411.016, 107.441, -5495.721),
}

local searchMountsEnabled = false

-- Teleporte instantâneo entre as ilhas
local function forcedStepTeleport(destination)
    local root = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    for i = 1, 15 do
        root.CFrame = CFrame.new(destination + Vector3.new(0, 3, 0))
        task.wait(0.000000005)
    end
end

-- Teleporte suave até a montaria com TweenService
local function smoothTeleportTo(position)
    local character = localPlayer.Character
    if not character then return end

    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    local tweenInfo = TweenInfo.new(0.35, Enum.EasingStyle.Linear)
    local goal = {CFrame = CFrame.new(position + Vector3.new(0, 3, 0))}
    local tween = TweenService:Create(root, tweenInfo, goal)
    tween:Play()
    tween.Completed:Wait()
end

-- Simula o botão E
local function simulateProximityPrompt(object)
    local prompt = object:FindFirstChildWhichIsA("ProximityPrompt", true)
    if prompt then
        fireproximityprompt(prompt)
    end
end

-- Loop de busca pelas montarias
local function teleportToMountsLoop()
    task.spawn(function()
        while searchMountsEnabled do
            for _, location in ipairs(MountLocations) do
                if not searchMountsEnabled then return end

                -- TP instantâneo entre as ilhas
                forcedStepTeleport(location)
                task.wait(0.5)

                for _, mount in pairs(workspace.__Extra.__Appear:GetChildren()) do
                    local model = mount:FindFirstChildWhichIsA("Model") or mount
                    local root = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")

                    if root then
                        -- TP suave até a montaria
                        smoothTeleportTo(root.Position)
                        task.wait(0.2)
                        simulateProximityPrompt(mount)
                        task.wait(1)
                    end
                end

                task.wait(1)
            end
        end
    end)
end

-- Toggle na interface
Mounts:AddToggle("SearchMounts", {
    Title = "Search Mounts [TEST]",
    Default = false,
    Callback = function(state)
        searchMountsEnabled = state
        if state then
            teleportToMountsLoop()
        end
    end
})


local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- Teleporte forçado em múltiplos steps
local function forcedStepTeleport(destination)
    if not hrp then return end
    for i = 1, 10 do
        hrp.CFrame = CFrame.new(destination + Vector3.new(0, 3, 0)) -- Altura ajustada
        task.wait(0.000000005)
    end
end

-- Tabela de posições
local teleportLocations = {
    ["World Teleport"] = {
        ["World 1"] = Vector3.new(430.431, 28.083, -6.193),
        ["World 2"] = Vector3.new(-3376.060, 30.260, 2252.275),
        ["World 3"] = Vector3.new(-2864.344, 57.738, -2044.594),
        ["World 4"] = Vector3.new(2791.104, 46.427, -2743.594),
        ["World 5"] = Vector3.new(198.628, 38.707, 4276.841),
        ["World 6"] = Vector3.new(192.606, 32.896, -4293.871),
        ["World 7"] = Vector3.new(4817.643, 29.942, -158.618),
        ["World 8"] = Vector3.new(-6324.643, 27.198, -71.441)
    },
    ["World BlackSmith"] = {
        ["World 1"] = Vector3.new(543.510, 28.083, 256.367),
        ["World 2"] = Vector3.new(-3418.732, 30.770, 2276.209),
        ["World 3"] = Vector3.new(-2833.557, 50.677, -2029.143),
        ["World 4"] = Vector3.new(2602.380, 46.427, -2711.782),
        ["World 5"] = Vector3.new(188.722, 37.853, 4388.137),
        ["World 6"] = Vector3.new(286.645, 32.896, -4409.248),
        ["World 7"] = Vector3.new(4890.349, 41.833, -78.664),
        ["World 8"] = Vector3.new(-6337.448, 27.198, -150.964)
    },
    ["World BoatSeller"] = {
        ["World 1"] = Vector3.new(425.565, 29.105, 383.855),
        ["World 2"] = Vector3.new(-3656.606, 24.215, 2368.828),
        ["World 3"] = Vector3.new(-2790.789, 30.202, -2020.528),
        ["World 4"] = Vector3.new(2477.002, 46.427, -2836.929),
        ["World 5"] = Vector3.new(204.880, 38.708, 4257.333),
        ["World 6"] = Vector3.new(100.193, 20.963, -4240.231),
        ["World 7"] = Vector3.new(4821.689, 29.942, -97.917),
        ["World 8"] = Vector3.new(-6214.947, 26.187, -115.281)
    },
    ["Special Locations"] = {
        ["Enchanter"] = Vector3.new(607.443, 28.084, 222.486),
        ["Upgrader"] = Vector3.new(593.785, 28.084, 189.893),
        ["Guild"] = Vector3.new(289.015, 31.853, 157.246),
        ["JejuIsland"] = Vector3.new(3345.334, 60.123, 2607.574)
    }
}

-- Criando os botões e dropdowns
for category, locations in pairs(teleportLocations) do
    if category == "Special Locations" then
        for name, position in pairs(locations) do
            Tabs.Teleport:AddButton({
                Title = "Teleport " .. name,
                Callback = function()
                    if hrp then
                        forcedStepTeleport(position)
                    end
                end
            })
        end
    else
        local values = {}
        for name in pairs(locations) do
            table.insert(values, name)
        end

        TeleportWorlds:AddDropdown(category, {
            Title = category,
            Description = "Select a destination to teleport to",
            Values = values,
            Multi = false,
            Default = 1,
            Callback = function(selected)
                local targetPos = locations[selected]
                if targetPos and hrp then
                    forcedStepTeleport(targetPos)
                end
            end
        })
    end
end

-- Atualizar referência ao HRP se o personagem morrer/renascer
player.CharacterAdded:Connect(function(newChar)
    character = newChar
    hrp = newChar:WaitForChild("HumanoidRootPart")
end)

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local localPlayer = Players.LocalPlayer

local enemiesClient = workspace.__Main.__Enemies:FindFirstChild("Client")
local enemiesServer = workspace.__Main.__Enemies:FindFirstChild("Server")
local petsFolder = workspace.__Main.__Pets:FindFirstChild(tostring(localPlayer.UserId))
local remoteEvent = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

local autoDungeonEnabled = false
local priority = "More Next"
local currentTarget = nil
local attackCooldown = 3
local enemyCooldowns = {}

local function hasExtraEquip()
    local passes = localPlayer.leaderstats.Passes
    return passes and passes:FindFirstChild("ExtraEquip") and passes.ExtraEquip.Value
end

local function getEquippedPets()
    local equippedPets = {}
    local petsData = localPlayer.leaderstats.Equips.Pets
    local maxPets = hasExtraEquip() and 7 or 4

    for i = 1, maxPets do
        local petName = petsData:GetAttribute(tostring(i))
        if petName then
            table.insert(equippedPets, petName)
        end
    end

    return equippedPets
end

local function getPetPositions()
    local equippedPets = getEquippedPets()
    local petPositions = {}

    if petsFolder then
        for _, petName in ipairs(equippedPets) do
            local petModelFolder = petsFolder:FindFirstChild(petName)
            if petModelFolder then
                local petModel = petModelFolder:FindFirstChildWhichIsA("Model")
                if petModel and petModel.PrimaryPart then
                    petPositions[petName] = petModel.PrimaryPart.Position
                end
            end
        end
    end

    return petPositions
end

local function getServerHP(enemyName)
    for _, worldFolder in ipairs(enemiesServer:GetChildren()) do
        local enemy = worldFolder:FindFirstChild(enemyName)
        if enemy and enemy:GetAttribute("HP") then
            return enemy:GetAttribute("HP")
        end
    end
    return 0
end

local function getPriorityEnemy()
    local closest, strongest, weakest = nil, nil, nil
    local minDist, maxHp, minHp = math.huge, 0, math.huge
    local playerPos = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and localPlayer.Character.HumanoidRootPart.Position

    if not playerPos then return nil end

    for _, enemy in ipairs(enemiesClient:GetChildren()) do
        if enemy:IsA("Model") then
            local part = enemy.PrimaryPart or enemy:FindFirstChildWhichIsA("BasePart")
            local hp = getServerHP(enemy.Name)

            if part and hp > 0 then
                local dist = (part.Position - playerPos).Magnitude

                if dist < minDist then
                    minDist = dist
                    closest = enemy
                end
                if hp > maxHp then
                    maxHp = hp
                    strongest = enemy
                end
                if hp < minHp then
                    minHp = hp
                    weakest = enemy
                end
            end
        end
    end

    if priority == "More Next" then return closest
    elseif priority == "Strongest" then return strongest
    elseif priority == "Lowest" then return weakest end

    return nil
end

local function forcedStepTeleport(destination)
    local root = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    for i = 1, 10 do
        root.CFrame = CFrame.new(destination + Vector3.new(0, 3, 0))
        task.wait(0.000000005)
    end
end

local function teleportToEnemy(enemy)
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    local part = enemy.PrimaryPart or enemy:FindFirstChildWhichIsA("BasePart")
    if not hrp or not part then return end

    local goalPosition = part.Position + Vector3.new(3, 0, 0)
    forcedStepTeleport(goalPosition)
end

local function autoDungeonLoop()
    while autoDungeonEnabled do
        local targetEnemy = currentTarget and currentTarget.Parent and getServerHP(currentTarget.Name) > 0 and currentTarget or getPriorityEnemy()
        currentTarget = targetEnemy

        if targetEnemy then
            local enemyName = targetEnemy.Name
            local currentTime = os.clock()

            local lastAttackTime = enemyCooldowns[enemyName] or 0
            if currentTime - lastAttackTime >= attackCooldown then
                enemyCooldowns[enemyName] = currentTime

                teleportToEnemy(targetEnemy)

                local petPositions = getPetPositions()
                if next(petPositions) then
                    local args = {
                        [1] = {
                            [1] = {
                                ["PetPos"] = petPositions,
                                ["AttackType"] = "All",
                                ["Event"] = "Attack",
                                ["Enemy"] = enemyName
                            },
                            [2] = "\5"
                        }
                    }

                    remoteEvent:FireServer(unpack(args))
                end
            end
        else
            currentTarget = nil
        end
        task.wait(0.5)
    end
end

-- UI
DungeonFarm:AddToggle("AutoDungeonToggle", {
    Title = "Auto Dungeon",
    Default = false,
    Callback = function(state)
        autoDungeonEnabled = state
        currentTarget = nil
        if state then
            task.spawn(autoDungeonLoop)
        end
    end
})

DungeonFarm:AddDropdown("PriorityDropdown", {
    Title = "Priority HP",
    Values = {"More Next", "Strongest", "Lowest"},
    Multi = false,
    Default = 1,
    Callback = function(value)
        priority = value
    end
})

Tabs.Misc:AddButton({
    Title = "All Gamepass",
    Description = "Enables or disables all gamepasses",
    Callback = function()
        local passes = game:GetService("Players").LocalPlayer.leaderstats.Passes
        if passes then
            local newState = not passes:GetAttribute(next(passes:GetAttributes())) -- Alterna o estado com base no primeiro atributo encontrado
            for attribute, _ in pairs(passes:GetAttributes()) do
                passes:SetAttribute(attribute, newState)
            end
        end
    end
})

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

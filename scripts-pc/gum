local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

--// Janela principal
local Window = Fluent:CreateWindow({
    Title = "Bubble Gum Simulator INFINITY | DZ HUB",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl
})

--// Abas
local Tabs = {
    Main = Window:AddTab({ 
        Title = "Main",
        Icon = "rbxassetid://124620632231839"
    }),
    AutoTask = Window:AddTab({ 
        Title = "Auto Task",
        Icon = "mail-question"
    }),
    EggHunt = Window:AddTab({ 
        Title = "Egg / Hunt",
        Icon = "egg"
    }),
    Upgrades = Window:AddTab({ 
        Title = "Upgrades",
        Icon = "arrow-big-up"
    }),
    Potions = Window:AddTab({ 
        Title = "Potions",
        Icon = "glass-water"
    }),
    Teleport = Window:AddTab({ 
        Title = "Teleport",
        Icon = "rbxassetid://12689978575"
    }),
    Misc = Window:AddTab({ 
        Title = "Misc",
        Icon = "scroll"
    }),
    Settings = Window:AddTab({ 
        Title = "Settings",
        Icon = "settings"
    })
}

--// Variáveis globais
local AutoBlow = false
local AutoSell = false
local AutoHatch = false
local SelectedEgg = "Iceshard Egg"
local HatchAmount = 1

--// ======= [MAIN TAB SECTIONS] =======
local SellOptions = Tabs.Main:AddSection("Sell Options")
local BlowSection = Tabs.Main:AddSection("Bubble + Sell Automation")
local CollectSection = Tabs.Main:AddSection("Auto Collect")
local UtilitiesSection = Tabs.Main:AddSection("Utilities")
local Egg = Tabs.EggHunt:AddSection("Egg")
local EggRift = Tabs.EggHunt:AddSection("Egg Rift")
local ChestHunt = Tabs.EggHunt:AddSection("Chest Hunt")
local GiftHunt = Tabs.EggHunt:AddSection("Gift Hunt")
local AutoPotionSection = Tabs.Potions:AddSection("Auto Use Potion")
local AutoCraftPotionSection = Tabs.Potions:AddSection("Auto Craft Potion")
local TeleportSection = Tabs.Teleport:AddSection("Unlock All Islands")
local CodeSection = Tabs.Misc:AddSection("Codes") 

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer

-- Auto Blow Feature
local AutoBlow = false
BlowSection:AddToggle("AutoBlow", {
    Title = "Auto Blow",
    Description = "Automatically blows the bubble",
    Default = false,
    Callback = function(state)
        AutoBlow = state
        if state then
            task.spawn(function()
                local lastBlowTime = 0
                local remote = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")
                while AutoBlow do
                    if tick() - lastBlowTime >= 0.1 then
                        pcall(function()
                            remote:FireServer("BlowBubble")
                        end)
                        lastBlowTime = tick()
                    end
                    task.wait(0.5)
                end
            end)
        end
    end
})

-- Auto Sell System
local selectedThreshold = 10000
local returnLocation = nil
local shouldSavePosition = false
local savedPosition = nil
local autoSellEnabled = false
local useTweenService = false
local noReturn = false -- New variable for no return option

local sellAmountOptions = {
    ["1K"] = 1000,
    ["5K"] = 5000,
    ["10K"] = 10000,
    ["25K"] = 25000,
    ["50K"] = 50000,
    ["100K"] = 100000,
    ["225K"] = 225000,
    ["600K"] = 600000,
    ["900K"] = 900000,
    ["1.5M"] = 1500000,
    ["5M"] = 5000000,
    ["50M"] = 50000000,
    ["100M"] = 100000000,
}

local formattedOptions = {}
for label in pairs(sellAmountOptions) do
    table.insert(formattedOptions, label)
end

table.sort(formattedOptions, function(a, b)
    return sellAmountOptions[a] < sellAmountOptions[b]
end)

local thresholdDropdown = SellOptions:AddDropdown("SellAmount", {
    Title = "Minimum Amount to Sell",
    Description = "Minimum bubble amount required to sell",
    Values = formattedOptions,
    Default = "10K",
})

thresholdDropdown:OnChanged(function(val)
    selectedThreshold = sellAmountOptions[val] or 10000
end)

-- Teleport Locations
local teleportLocations = {
    ["Twilight Island"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",
    ["Outer Space"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Spawn (Overworld)"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["The Void"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Floating Island"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
    ["Zen"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn",
    ["Event"] = "Workspace.Event.Portal.Spawn",
    ["None"] = nil -- Added "None" option
}

-- Return Location Dropdown (updated with "None" option)
local returnDropdown = SellOptions:AddDropdown("ReturnIsland", {
    Title = "Return Location After Sell",
    Description = "Choose where to return after selling (or None)",
    Values = {"None", "Twilight Island", "Outer Space", "Spawn (Overworld)", "The Void", "Floating Island", "Zen", "Event"},
    Default = "None",
})

returnDropdown:OnChanged(function(val)
    returnLocation = teleportLocations[val]
    noReturn = val == "None" -- Set noReturn based on selection
end)

-- Save Position Dropdown
local savePosDropdown = SellOptions:AddDropdown("SavePos", {
    Title = "Save Position Before Selling?",
    Description = "Will walk back to original position after selling",
    Values = {"Yes", "No"},
    Default = "No",
})

savePosDropdown:OnChanged(function(val)
    shouldSavePosition = val == "Yes"
end)

-- Tween Service Option Dropdown
local tweenBackDropdown = SellOptions:AddDropdown("TweenBack", {
    Title = "Return Method",
    Description = "Choose how to return to saved position",
    Values = {"Walk", "Tween"},
    Default = "Walk",
})

tweenBackDropdown:OnChanged(function(val)
    useTweenService = val == "Tween"
end)

-- Position Return Function
local function returnToPosition(position)
    if not player.Character or not position then return end
    
    local humanoid = player.Character:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then return end
    
    if useTweenService then
        local tweenService = game:GetService("TweenService")
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local distance = (hrp.Position - position).Magnitude
            local tweenInfo = TweenInfo.new(
                distance / 1000, -- Adjust speed (higher divisor = faster)
                Enum.EasingStyle.Linear
            )
            local tween = tweenService:Create(hrp, tweenInfo, {CFrame = CFrame.new(position)})
            tween:Play()
            tween.Completed:Wait()
        end
    else
        humanoid:MoveTo(position)
        humanoid.MoveToFinished:Wait()
    end
end

-- Main Auto Sell Toggle
BlowSection:AddToggle("AutoSellToggle", {
    Title = "Enable Auto Sell",
    Description = "Activates the complete auto sell system",
    Default = false,
    Callback = function(state)
        autoSellEnabled = state
        if state then
            savedPosition = nil
            selectedThreshold = sellAmountOptions[thresholdDropdown.Value] or 10000
            returnLocation = teleportLocations[returnDropdown.Value]
            noReturn = returnDropdown.Value == "None"
            shouldSavePosition = savePosDropdown.Value == "Yes"
            useTweenService = tweenBackDropdown.Value == "Tween"
        end
    end
})

-- Função para limpar e tentar converter a string para número
local function tryParseNumber(str)
    -- Remover quaisquer caracteres não numéricos e espaços
    local cleanedStr = str:gsub("[^0-9]", "")
    if cleanedStr == "" then
        return 0 -- Se não houver valor numérico, retorna 0
    end
    local num = tonumber(cleanedStr)
    return num or 0 -- Retorna o número ou 0 se não for válido
end

-- Auto Sell Loop with teleport verification
task.spawn(function()
    local remote = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")
    
    -- Twilight Island target coordinates
    local targetPosition = Vector3.new(-77.93646240234375, 6862.2060546875, 88.32815551757812)
    local proximityThreshold = 20 -- How close the player needs to be to consider teleport successful
    
    while true do
        if autoSellEnabled and player.Character then
            -- Pause other processes temporarily
            local wasAutoHatchActive = AutoHatch
            if wasAutoHatchActive then
                AutoHatch = false
                DisableNoclip()
            end
            
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            local bubbleLabel = player.PlayerGui.ScreenGui.HUD.Left.Currency.Bubble.Frame.Label

            if bubbleLabel then
                local bubbleText = bubbleLabel.Text
                local cleanedText = bubbleText:gsub("<[^>]+>", "")
                local amountStr = cleanedText:match("(%d+,?%d*)")

                if amountStr then
                    local initialBubbleAmount = tryParseNumber(amountStr)

                    if initialBubbleAmount >= selectedThreshold then
                        if shouldSavePosition and hrp then
                            savedPosition = hrp.Position
                        end

                        -- Teleport verification function
                        local function verifyTeleport()
                            local teleportAttempts = 0
                            local maxTeleportAttempts = 5
                            local teleportSuccess = false
                            
                            while teleportAttempts < maxTeleportAttempts and not teleportSuccess do
                                -- Try to teleport
                                remote:FireServer("Teleport", teleportLocations["Twilight Island"])
                                
                                -- Wait for teleport to complete
                                task.wait(1.5)
                                
                                -- Check player position
                                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                    local currentPosition = player.Character.HumanoidRootPart.Position
                                    local distance = (currentPosition - targetPosition).Magnitude
                                    
                                    if distance <= proximityThreshold then
                                        teleportSuccess = true
                                        Fluent:Notify({
                                            Title = "Teleport Successful",
                                            Content = "Arrived at Twilight Island",
                                            Duration = 2
                                        })
                                        break
                                    else
                                        warn("Teleport attempt "..(teleportAttempts+1).." failed. Distance: "..distance)
                                    end
                                end
                                
                                teleportAttempts = teleportAttempts + 1
                                task.wait(0.5)
                            end
                            
                            if not teleportSuccess then
                                Fluent:Notify({
                                    Title = "Teleport Failed",
                                    Content = "Could not reach Twilight Island after "..maxTeleportAttempts.." attempts",
                                    Duration = 5
                                })
                                return false
                            end
                            
                            return true
                        end

                        -- Try to teleport and verify location
                        local teleportSuccess = verifyTeleport()
                        
                        -- Only proceed with selling if teleport was successful
                        if teleportSuccess then
                            -- Function to check if the value decreased
                            local function checkBubbleReduced()
                                local currentText = player.PlayerGui.ScreenGui.HUD.Left.Currency.Bubble.Frame.Label.Text
                                local currentCleaned = currentText:gsub("<[^>]+>", "")
                                local currentAmountStr = currentCleaned:match("(%d+,?%d*)")
                                if currentAmountStr then
                                    local currentAmount = tryParseNumber(currentAmountStr)
                                    return currentAmount < initialBubbleAmount
                                end
                                return false
                            end

                            -- Sell loop with verification
                            local sellAttempts = 0
                            local maxAttempts = 10
                            local saleConfirmed = false
                            
                            while sellAttempts < maxAttempts and autoSellEnabled and not saleConfirmed do
                                -- Check current value before trying to sell
                                if checkBubbleReduced() then
                                    saleConfirmed = true
                                    break
                                end
                                
                                -- Try to sell
                                local success, err = pcall(function()
                                    remote:FireServer("SellBubble")
                                end)

                                if success then
                                    -- Wait and check if the value decreased
                                    task.wait(0.5)
                                    saleConfirmed = checkBubbleReduced()
                                    
                                    if saleConfirmed then
                                        Fluent:Notify({
                                            Title = "Auto Sell",
                                            Content = "Sale confirmed!",
                                            Duration = 2
                                        })
                                    else
                                        warn("Sale not confirmed, trying again...")
                                    end
                                else
                                    warn("Error when trying to sell ("..sellAttempts.."): ", err)
                                end
                                
                                sellAttempts = sellAttempts + 1
                                task.wait(0.5)
                            end

                            if not saleConfirmed then
                                Fluent:Notify({
                                    Title = "Auto Sell Error",
                                    Content = "Failed to confirm sale after "..maxAttempts.." attempts",
                                    Duration = 5
                                })
                            end

                            task.wait(1) -- Additional time after sale

                            -- Return if necessary
                            if not noReturn and returnLocation then
                                remote:FireServer("Teleport", returnLocation)
                                task.wait(3)
                            end

                            if shouldSavePosition and savedPosition and hrp then
                                returnToPosition(savedPosition)
                                task.wait(1)
                            end
                        end
                    end
                end
            end
            
            -- Reactivate other processes if they were active
            if wasAutoHatchActive then
                AutoHatch = true
                EnableNoclip()
            end
        end
        task.wait(1)
    end
end)

local AutoCollect = false

CollectSection:AddToggle("AutoCollectToggle", {
    Title = "Auto Collect Coins/Gems/Crates",
    Default = false,
    Callback = function(state)
        AutoCollect = state

        if state then
            task.spawn(function()
                local pickupRemote = game:GetService("ReplicatedStorage"):WaitForChild("Remotes")
                                      :WaitForChild("Pickups"):WaitForChild("CollectPickup")

                while AutoCollect and task.wait(1) do -- Longer wait time (1 second)
                    pcall(function()
                        local rendered = workspace:FindFirstChild("Rendered")
                        if rendered then
                            -- Create a collection of items to pick up
                            local itemsToCollect = {}
                            
                            for _, folder in ipairs(rendered:GetChildren()) do
                                if folder.Name == "Chunker" then
                                    for _, model in ipairs(folder:GetChildren()) do
                                        -- Only collect items with name length >= 25
                                        if model:IsA("Model") and #model.Name >= 25 then
                                            table.insert(itemsToCollect, model)
                                        end
                                    end
                                end
                            end
                            
                            -- Process the batch - collect everything at once then destroy
                            for i, model in ipairs(itemsToCollect) do
                                pickupRemote:FireServer(model.Name)
                                model:Destroy()
                                
                                -- Small yield every 20 items to prevent overwhelming the server
                                if i % 20 == 0 then
                                    task.wait(0.5)
                                end
                            end
                            
                            -- Only notify if items were actually collected
                            if #itemsToCollect > 0 then
                            end
                        end
                    end)
                end
            end)
        end
    end
})

CollectSection:AddToggle("AutoGiftGrabber", {
    Title = "Auto Use Gift",
    Description = "Use gift, give claim",
    Default = false,
    Callback = function(state)
        getgenv().AutoGiftGrabber = state

        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network")
                local RemoteEvent = Network:WaitForChild("Remote"):WaitForChild("Event")
                local RenderedGifts = workspace:WaitForChild("Rendered"):WaitForChild("Gifts")

                while AutoGiftGrabber do
                    -- 1. Usa 10 gifts de uma vez
                    RemoteEvent:FireServer("UseGift", "Mystery Box", 10)

                    -- 2. Detecta e faz claim dos gifts
                    local startTime = os.clock()
                    local detectedGifts = {}

                    repeat
                        for _, obj in pairs(RenderedGifts:GetChildren()) do
                            if obj:IsA("BasePart") and not detectedGifts[obj] then
                                detectedGifts[obj] = true
                                -- Faz o claim
                                RemoteEvent:FireServer("ClaimGift", obj.Name)
                                
                                task.delay(0.5, function()
                                    if obj and obj.Parent then
                                        obj:Destroy()
                                    end
                                end)
                            end
                        end
                        task.wait(0.5)
                    until os.clock() - startTime > 10 or not AutoGiftGrabber

                    task.wait(0.5)
                end
            end)
        end
    end
})

local equipBestRunning = false -- Variável de controle GLOBAL

UtilitiesSection:AddToggle("EquipBestToggle", {
    Title = "Auto Equip Best Pets",
    Description = "Automatically equips the best pets",
    Default = false,
    Callback = function(state)
        equipBestRunning = state
        
        if state then
            task.spawn(function()
                local remote = game:GetService("ReplicatedStorage")
                    :WaitForChild("Shared")
                    :WaitForChild("Framework")
                    :WaitForChild("Network")
                    :WaitForChild("Remote")
                    :WaitForChild("Event")
                
                while equipBestRunning do
                    local args = {[1] = "EquipBestPets"}
                    remote:FireServer(unpack(args))
                    task.wait(2) -- Espera 2 segundos
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoClaimChests", {
    Title = "Auto Claim Chests",
    Description = "Teleports and claims Giant and Void Chests using Remote Event + Noclip",
    Default = false,
    Callback = function(state)
        getgenv().AutoClaimChests = state

        if state then
            spawn(function()
                local Players = game:GetService("Players")
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RunService = game:GetService("RunService")
                local Workspace = game:GetService("Workspace")

                local LocalPlayer = Players.LocalPlayer
                local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local HRP = Character:WaitForChild("HumanoidRootPart")
                local Humanoid = Character:WaitForChild("Humanoid")

                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                local chestData = {
                    ["Giant Chest"] = {
                        teleportTo = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
                        walkTo = Vector3.new(13.179579734802246, 427.93109130859375, 158.93988037109375),
                        path = "Giant Chest"
                    },
                    ["Void Chest"] = {
                        teleportTo = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
                        walkTo = Vector3.new(76.66033172607422, 10148.2060546875, 52.507083892822266),
                        path = "Void Chest"
                    }
                }

                local function isChestReady(chestName)
                    local genericChest = Workspace.Rendered.Generic:FindFirstChild(chestName)
                    return genericChest and genericChest:FindFirstChild("Outer") ~= nil
                end

                -- Notifica imediatamente se os baús estão em cooldown
                for chestName, data in pairs(chestData) do
                    if not isChestReady(data.path) then
                        Fluent:Notify({
                            Title = "Cooldown",
                            Content = chestName .. " it's on cooldown!",
                            Duration = 4
                        })
                    end
                end

                -- Noclip loop
                local noclipConnection
                noclipConnection = RunService.Stepped:Connect(function()
                    if getgenv().AutoClaimChests then
                        for _, part in ipairs(Character:GetDescendants()) do
                            if part:IsA("BasePart") and part.CanCollide then
                                part.CanCollide = false
                            end
                        end
                    else
                        noclipConnection:Disconnect()
                    end
                end)

                local function fireTeleport(path)
                    RemoteEvent:FireServer("Teleport", path)
                    task.wait(2.5)
                end

                local function walkTo(position)
                    Humanoid:MoveTo(position)
                    Humanoid.MoveToFinished:Wait()
                end

                while getgenv().AutoClaimChests do
                    for chestName, data in pairs(chestData) do
                        if isChestReady(data.path) then
                            fireTeleport(data.teleportTo)
                            walkTo(data.walkTo)
                            task.wait(0.5)
                            RemoteEvent:FireServer("ClaimChest", chestName)
                            Fluent:Notify({
                                Title = "Chest Claimed",
                                Content = chestName .. " successfully collected!",
                                Duration = 3
                            })
                        end
                        task.wait(1)
                    end
                    task.wait(1)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoClaimSeason", {
    Title = "Auto Claim Season",
    Description = "Automatic Season Pass claim",
    Default = false,
    Callback = function(state)
        getgenv().AutoClaimSeason = state

        if state then
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

                while AutoClaimSeason do
                    local args = {
                        [1] = "ClaimSeason"
                    }

                    RemoteEvent:FireServer(unpack(args))
                    task.wait(5) -- tempo entre cada claim (ajuste conforme necessário)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoClaimPlaytime", {
    Title = "Auto Claim Playtime Rewards",
    Description = "Automatically claims playtime rewards (1 to 9)",
    Default = false,
    Callback = function(state)
        AutoClaimPlaytime = state

        task.spawn(function()
            while AutoClaimPlaytime do
                for i = 1, 9 do
                    pcall(function()
                        local args = {
                            [1] = "ClaimPlaytime",
                            [2] = i
                        }

                        game:GetService("ReplicatedStorage")
                            :WaitForChild("Shared")
                            :WaitForChild("Framework")
                            :WaitForChild("Network")
                            :WaitForChild("Remote")
                            :WaitForChild("Function")
                            :InvokeServer(unpack(args))
                    end)
                end

                task.wait(5) -- Espera 5 segundos antes de repetir tudo
            end
        end)
    end
})

UtilitiesSection:AddToggle("AutoStartGenieQuest", {
    Title = "Auto Start Genie Quest",
    Description = "Automatically starts random Genius quests",
    Default = false,
    Callback = function(state)
        getgenv().AutoGenieQuest = state

        if state then
            task.spawn(function()
                local RemoteEvent = game:GetService("ReplicatedStorage")
                    :WaitForChild("Shared")
                    :WaitForChild("Framework")
                    :WaitForChild("Network")
                    :WaitForChild("Remote")
                    :WaitForChild("Event")

                while getgenv().AutoGenieQuest do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("StartGenieQuest", i)
                        task.wait(1)
                    end
                    task.wait(1)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoBuyAlienShop", {
    Title = "Auto Buy Alien Shop Items",
    Description = "Automatically buys items from alien-shop",
    Default = false,
    Callback = function(state)
        getgenv().AutoBuyAlienShop = state

        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework")
                    :WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

                while AutoBuyAlienShop do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("BuyShopItem", "alien-shop", i)
                        task.wait(0.5) -- pequeno delay entre compras
                    end

                    task.wait(3) -- espera 3s antes de comprar novamente
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoBuyShardShop", {
    Title = "Auto Buy Black Market Shop Items",
    Description = "Automatically buys items from shard shop",
    Default = false,
    Callback = function(state)
        getgenv().AutoBuyShardShop = state

        if state then
            task.spawn(function()
                local RemoteEvent = game:GetService("ReplicatedStorage")
                    :WaitForChild("Shared")
                    :WaitForChild("Framework")
                    :WaitForChild("Network")
                    :WaitForChild("Remote")
                    :WaitForChild("Event")

                while getgenv().AutoBuyShardShop do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("BuyShopItem", "shard-shop", i)
                        task.wait(0.5)
                    end
                    task.wait(3)
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoDoggyJumpWin", {
    Title = "Auto Win Doggy",
    Description = "Simulates victory in the Doggy Jump minigame (Rewards 1 to 3)",
    Default = false,
    Callback = function(state)
        getgenv().AutoDoggyJumpWin = state

        if state then
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework")
                    :WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

                while AutoDoggyJumpWin do
                    for i = 1, 3 do
                        RemoteEvent:FireServer("DoggyJumpWin", i)
                        task.wait(1)
                    end
                    task.wait(3) -- espera 3s antes de repetir
                end
            end)
        end
    end
})

UtilitiesSection:AddToggle("AutoWheelSpin", {
    Title = "Auto Wheel Spin",
    Description = "Automatically spins both roulette wheels (free and paid)",
    Default = false,
    Callback = function(state)
        getgenv().AutoWheelSpin = state

        if state then
            task.spawn(function()
                local Event = game:GetService("ReplicatedStorage"):WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")
                
                local Function = game:GetService("ReplicatedStorage"):WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Function")

                while getgenv().AutoWheelSpin do
                    -- Roleta grátis
                    pcall(function()
                        Event:FireServer("ClaimFreeWheelSpin")
                    end)
                    
                    -- Roleta paga
                    pcall(function()
                        Function:InvokeServer("WheelSpin")
                    end)
                    
                    task.wait(1) -- Espera exatamente 1 segundo
                end
            end)
        end
    end
})

-- Mapas de teleporte por ovo
local EggTeleportMap = {
    ["Common Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Spotted Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Iceshard Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Spikey Egg"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
    ["Magma Egg"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Crystal Egg"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Lunar Egg"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",
    ["Void Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Hell Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Nightmare Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Rainbow Egg"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn",
    ["Infinity Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Pastel Egg"] = "Workspace.Event.Portal.Spawn",
    ["Bunny Egg"] = "Workspace.Event.Portal.Spawn",
    ["Throwback Egg"] = "Workspace.Event.Portal.Spawn"
}

-- Posições dos ovos
local EggPositions = {
    ["Common Egg"] = Vector3.new(-8.69461727142334, 9.29999828338623, -82.08343505859375),
    ["Spotted Egg"] = Vector3.new(-7.885712146759033, 9.29999828338623, -71.13986206054688),
    ["Iceshard Egg"] = Vector3.new(-8.188074111938477, 9.323458671569824, -60.25547790527344),
    ["Spikey Egg"] = Vector3.new(-6.725212097167969, 422.93157958984375, 157.7880096435547),
    ["Magma Egg"] = Vector3.new(-19.16876220703125, 2665.166015625, 8.449355125427246),
    ["Crystal Egg"] = Vector3.new(-18.302135467529297, 2665.166015625, 18.25184440612793),
    ["Lunar Egg"] = Vector3.new(-57.51275634765625, 6862.583984375, 79.98605346679688),
    ["Void Egg"] = Vector3.new(5.301668167114258, 10147.8046875, 188.5633087158203),
    ["Hell Egg"] = Vector3.new(-8.620597839355469, 10147.8046875, 193.4177703857422),
    ["Nightmare Egg"] = Vector3.new(-17.104894638061523, 10147.8046875, 185.614990234375),
    ["Rainbow Egg"] = Vector3.new(-34.15152359008789, 15972.4248046875, 45.44554138183594),
    ["Infinity Egg"] = Vector3.new(-96.60652923583984, 8.299989700317383, -27.740280151367188),
    ["Pastel Egg"] = Vector3.new(-393.0823669433594, 12012.0830078125, -60.60501480102539),
    ["Bunny Egg"] = Vector3.new(-402.5804443359375, 12012.0830078125, -59.37004089355469),
    ["Throwback Egg"] = Vector3.new(-389.16912841796875, 12012.0830078125, -56.94336700439453)
}

-- Mapeamento de tarefas para ovos
local TaskToEggMap = {
    ["Shiny"] = "Common Egg",
    ["Epic"] = "Spotted Egg",
    ["Legendary"] = "Spikey Egg",
    ["Common"] = "Common Egg"
}

-- Toggle para ativar/desativar o Auto Hatch
Tabs.AutoTask:AddToggle("AutoHatch", {
    Title = "Auto Tasks Competitive",
    Default = false,
    Callback = function(state)
        getgenv().AutoHatch = state
        
        if state then
            spawn(function()
                -- Serviços
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Players = game:GetService("Players")
                local RunService = game:GetService("RunService")
                
                -- Configuração de rede
                local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network")
                local RemoteEvent = Network:WaitForChild("Remote"):WaitForChild("Event")
                local Player = Players.LocalPlayer
                
                -- Variáveis de estado
                local currentTask = nil
                local playTimeTaskActive = false
                local playTimeStart = 0
                local playTimeRequired = 0
                local noclipActive = false
                local noclipConnection = nil

                -- Função para ativar/desativar NoClip
                local function setNoClip(state)
                    if state == noclipActive then return end
                    
                    if state then
                        noclipActive = true
                        noclipConnection = RunService.Stepped:Connect(function()
                            if Player.Character then
                                for _, part in ipairs(Player.Character:GetDescendants()) do
                                    if part:IsA("BasePart") then
                                        part.CanCollide = false
                                    end
                                end
                            end
                        end)
                        print("[NoClip] Ativado")
                    else
                        noclipActive = false
                        if noclipConnection then
                            noclipConnection:Disconnect()
                            noclipConnection = nil
                        end
                        print("[NoClip] Desativado")
                    end
                end

                -- Função melhorada para caminhar até uma posição
                local function walkToPosition(position)
                    if not Player.Character then 
                        print("[ERRO] Personagem não encontrado ao tentar caminhar")
                        return false 
                    end
                    
                    local humanoid = Player.Character:FindFirstChildOfClass("Humanoid")
                    local rootPart = Player.Character:FindFirstChild("HumanoidRootPart")
                    
                    if not humanoid or not rootPart then 
                        print("[ERRO] Humanoid ou RootPart não encontrado")
                        return false 
                    end
                    
                    -- Ativar NoClip para evitar colisões durante o caminho
                    setNoClip(true)
                    
                    -- Aumentar velocidade de caminhada
                    local originalWalkSpeed = humanoid.WalkSpeed
                    humanoid.WalkSpeed = 24
                    
                    print("[INFO] Caminhando até a posição do ovo...")
                    humanoid:MoveTo(position)
                    
                    local startTime = os.time()
                    local distance = (rootPart.Position - position).Magnitude
                    local lastDistance = distance
                    local stuckCounter = 0
                    
                    -- Loop para verificar progresso e evitar travamentos
                    while distance > 5 and os.time() - startTime < 30 do
                        task.wait(0.5)
                        
                        -- Verificar se o movimento está estagnado
                        distance = (rootPart.Position - position).Magnitude
                        
                        -- Se a distância não mudou significativamente, incrementar contador de "preso"
                        if math.abs(distance - lastDistance) < 1 then
                            stuckCounter = stuckCounter + 1
                        else
                            stuckCounter = 0
                        end
                        
                        -- Se preso por muito tempo, tentar mover novamente
                        if stuckCounter >= 3 then
                            print("[AVISO] Parece que estamos presos, tentando mover novamente")
                            humanoid:MoveTo(position)
                            stuckCounter = 0
                        end
                        
                        -- Atualizar última distância para comparação
                        lastDistance = distance
                        
                        -- Log do progresso
                        print(string.format("[INFO] Distância até o alvo: %.2f", distance))
                    end
                    
                    -- Restaurar velocidade original
                    humanoid.WalkSpeed = originalWalkSpeed
                    
                    -- Verificar se chegamos ao destino
                    local success = (rootPart.Position - position).Magnitude <= 10
                    
                    -- Manter NoClip apenas se ainda não chegamos ao destino
                    if success then
                        print("[INFO] Chegamos com sucesso ao ovo!")
                        -- Podemos desativar NoClip aqui se quisermos
                        -- setNoClip(false)
                    else
                        print("[AVISO] Não conseguimos chegar ao ovo após 30 segundos")
                    end
                    
                    return success
                end

                local function getCurrentTask()
                    local TasksFrame = Player.PlayerGui.ScreenGui.Competitive.Frame.Content.Tasks
                    
                    local function checkForLabels(parent)
                        for _, child in pairs(parent:GetChildren()) do
                            if child:IsA("TextLabel") and child.Visible and child.Text then
                                local text = child.Text
                                print("[INFO] Verificando tarefa:", text)  -- Log para verificar o texto
                                
                                -- Verifica tarefas de hatch
                                if text:match("Hatch") then
                                    print("[INFO] Encontrada tarefa de hatch:", text)
                                    
                                    -- Ignora Mythic
                                    if text:match("Mythic") then
                                        print("[INFO] Ignorando tarefa Mythic")
                                        return nil
                                    end
                                    
                                    -- Verifica tipos específicos (usando o formato plural também)
                                    for petType, eggName in pairs(TaskToEggMap) do
                                        if text:match(petType) then
                                            print("[INFO] Encontrado tipo de pet:", petType, "usando ovo:", eggName)
                                            local amount = text:match("Hatch (%d+)")
                                            if amount then
                                                return {
                                                    text = text,
                                                    eggName = eggName,
                                                    amount = tonumber(amount),
                                                    type = "hatch"
                                                }
                                            end
                                        end
                                    end
                                    
                                    -- Tarefas comuns de hatch
                                    if text:match("Common Pets") then
                                        print("[INFO] Encontrada tarefa de Hatch de Common Pets")
                                        local amount = text:match("Hatch (%d+)")
                                        if amount then
                                            return {
                                                text = text,
                                                eggName = "Common Egg",
                                                amount = tonumber(amount),
                                                type = "hatch"
                                            }
                                        end
                                    end

                                    -- Verificar nomes específicos de ovos
                                    for eggName, _ in pairs(EggPositions) do
                                        local shortName = eggName:gsub(" Egg", "")
                                        if text:match(shortName) or text:match(eggName) then
                                            print("[INFO] Encontrado ovo pelo nome:", eggName)
                                            local amount = text:match("Hatch (%d+)")
                                            if amount then
                                                return {
                                                    text = text,
                                                    eggName = eggName,
                                                    amount = tonumber(amount),
                                                    type = "hatch"
                                                }
                                            end
                                        end
                                    end
                                end
                                
                                -- Verifica tarefa de tempo de jogo
                                if text:match("Play for") then
                                    print("[INFO] Encontrada tarefa de tempo de jogo:", text)
                                    local minutes = text:match("Play for (%d+) minutes")
                                    if minutes then
                                        return {
                                            text = text,
                                            type = "playtime",
                                            requiredTime = tonumber(minutes) * 60
                                        }
                                    end
                                end
                            elseif child:IsA("GuiObject") then
                                local result = checkForLabels(child)
                                if result then return result end
                            end
                        end
                        return nil
                    end
                    
                    return checkForLabels(TasksFrame)
                end

                -- Função para teleportar para a ilha certa
                local function teleportToIsland(eggName)
                    local teleportPath = EggTeleportMap[eggName]
                    if not teleportPath then
                        print("[ERRO] Caminho de teleporte não encontrado para:", eggName)
                        return false
                    end
                    
                    print("[INFO] Teleportando para ilha:", teleportPath)
                    
                    -- Enviar comando de teleporte
                    RemoteEvent:FireServer("Teleport", teleportPath)
                    
                    -- Esperar um pouco para o teleporte acontecer
                    task.wait(3)
                    
                    return true
                end

                -- Função principal de hatch
                local function hatchLoop(eggName, eggPosition)
                    local attempts = 0
                    local maxAttempts = 3
                    local atPosition = false
                    
                    while getgenv().AutoHatch and attempts < maxAttempts do
                        -- Verificar se a tarefa mudou
                        local newTask = getCurrentTask()
                        if not newTask or (newTask.type == "hatch" and newTask.eggName ~= eggName) then
                            print("[INFO] Tarefa mudou ou foi completada")
                            break
                        end
                        
                        -- Verificar se estamos na posição correta
                        if not atPosition and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
                            local currentPos = Player.Character.HumanoidRootPart.Position
                            if (currentPos - eggPosition).Magnitude > 10 then
                                print("[INFO] Tentando ir até o ovo:", eggName)
                                
                                -- Primeiro teleportar para a ilha
                                if teleportToIsland(eggName) then
                                    task.wait(1.5)
                                    
                                    -- Depois caminhar até o ovo
                                    print("[INFO] Caminhando até o ovo...")
                                    if walkToPosition(eggPosition) then
                                        print("[INFO] Chegamos ao ovo com sucesso!")
                                        atPosition = true
                                        attempts = 0  -- Resetar tentativas quando chegar com sucesso
                                    else
                                        print("[AVISO] Falha ao caminhar até o ovo, tentativa:", attempts + 1)
                                        attempts = attempts + 1
                                        task.wait(1)
                                        continue
                                    end
                                else
                                    print("[ERRO] Falha ao teleportar para ilha")
                                    attempts = attempts + 1
                                    task.wait(1.5)
                                    continue
                                end
                            else
                                atPosition = true  -- Já estamos na posição
                            end
                        end
                        
                        -- Se chegamos até o ovo, realizar hatch
                        if atPosition then
                            print("[INFO] Abrindo ovo:", eggName)
                            RemoteEvent:FireServer("HatchEgg", eggName, 10)
                            task.wait(0.5 + math.random() * 0.3)  -- Intervalo variável para parecer mais natural
                        else
                            print("[AVISO] Ainda não estamos na posição do ovo")
                            atPosition = false  -- Resetar flag para tentar novamente
                            task.wait(1)
                        end
                    end
                    
                    if attempts >= maxAttempts then
                        print("[ERRO] Número máximo de tentativas atingido. Pausando auto-hatch.")
                        getgenv().AutoHatch = false
                    end
                    
                    -- Desativar NoClip quando terminar
                    setNoClip(false)
                end

                -- Loop principal
                while getgenv().AutoHatch do
                    local task = getCurrentTask()
                    
                    -- Gerenciar tarefa de tempo de jogo
                    if playTimeTaskActive then
                        local elapsed = os.time() - playTimeStart
                        if elapsed >= playTimeRequired then
                            playTimeTaskActive = false
                            print("[INFO] Tarefa de tempo completada!")
                        else
                            print(string.format("[INFO] Tempo de jogo: %d/%d segundos", elapsed, playTimeRequired))
                        end
                    end
                    
                    if task then
                        if task.type == "playtime" and not playTimeTaskActive then
                            -- Iniciar tarefa de tempo
                            playTimeTaskActive = true
                            playTimeStart = os.time()
                            playTimeRequired = task.requiredTime
                            print("[INFO] Iniciando tarefa de tempo: "..task.text)
                        elseif task.type == "hatch" then
                            if currentTask == nil or currentTask.text ~= task.text then
                                -- Nova tarefa de hatch
                                currentTask = task
                                print("[INFO] Nova tarefa: " .. task.text)
                            end
                            
                            -- Verificar se o ovo existe no mapa
                            local eggPosition = EggPositions[task.eggName]
                            if eggPosition then
                                print("[INFO] Iniciando processo de hatch para:", task.eggName)
                                hatchLoop(task.eggName, eggPosition)
                            else
                                print("[ERRO] Posição não encontrada para ovo:", task.eggName)
                                task.wait(2)
                            end
                        end
                    else
                        print("[INFO] Nenhuma tarefa válida encontrada. Aguardando...")
                        wait(2)
                    end
                    
                    wait(1)
                end
                
                -- Limpeza final
                if noclipConnection then
                    noclipConnection:Disconnect()
                    noclipConnection = nil
                end
            end)
        else
            -- Desativar NoClip ao desligar
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
        end
    end
})

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local SelectedEgg = "Common Egg"
local HatchAmount = 10
local AutoHatch = false
local Noclip = false
local NoclipConnection = nil

-- Mapas de teleporte por ovo
local EggTeleportMap = {
    ["Common Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Spotted Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Iceshard Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",

    ["Spikey Egg"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",

    ["Magma Egg"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Crystal Egg"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",

    ["Lunar Egg"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",

    ["Void Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Hell Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Nightmare Egg"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",

    ["Rainbow Egg"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn",

    ["Infinity Egg"] = "Workspace.Worlds.The Overworld.PortalSpawn",

    ["Pastel Egg"] = "Workspace.Event.Portal.Spawn",
    ["Bunny Egg"] = "Workspace.Event.Portal.Spawn",
    ["Throwback Egg"] = "Workspace.Event.Portal.Spawn"
}

-- Posições atualizadas dos ovos
local EggPositions = {
    ["Common Egg"] = Vector3.new(-8.69461727142334, 9.29999828338623, -82.08343505859375),
    ["Spotted Egg"] = Vector3.new(-7.885712146759033, 9.29999828338623, -71.13986206054688),
    ["Iceshard Egg"] = Vector3.new(-8.795853614807129, 9.29999828338623, -59.287872314453125),
    ["Spikey Egg"] = Vector3.new(-6.725212097167969, 422.93157958984375, 157.7880096435547),
    ["Magma Egg"] = Vector3.new(-19.16876220703125, 2665.166015625, 8.449355125427246),
    ["Crystal Egg"] = Vector3.new(-18.302135467529297, 2665.166015625, 18.25184440612793),
    ["Lunar Egg"] = Vector3.new(-57.51275634765625, 6862.583984375, 79.98605346679688),
    ["Void Egg"] = Vector3.new(5.301668167114258, 10147.8046875, 188.5633087158203),
    ["Hell Egg"] = Vector3.new(-8.620597839355469, 10147.8046875, 193.4177703857422),
    ["Nightmare Egg"] = Vector3.new(-17.104894638061523, 10147.8046875, 185.614990234375),
    ["Rainbow Egg"] = Vector3.new(-34.15152359008789, 15972.4248046875, 45.44554138183594),
    ["Infinity Egg"] = Vector3.new(-96.60652923583984, 8.299989700317383, -27.740280151367188),
    ["Pastel Egg"] = Vector3.new(-393.0823669433594, 12012.0830078125, -60.60501480102539),
    ["Bunny Egg"] = Vector3.new(-402.5804443359375, 12012.0830078125, -59.37004089355469),
    ["Throwback Egg"] = Vector3.new(-389.16912841796875, 12012.0830078125, -56.94336700439453)
}

local function EnableNoclip()
    if NoclipConnection then NoclipConnection:Disconnect() end
    Noclip = true
    NoclipConnection = RunService.Stepped:Connect(function()
        if Noclip and LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function DisableNoclip()
    Noclip = false
    if NoclipConnection then
        NoclipConnection:Disconnect()
        NoclipConnection = nil
    end
end

local function GetEggNames()
    local keys = {}
    for eggName in pairs(EggTeleportMap) do
        table.insert(keys, eggName)
    end
    return keys
end

local EggDropdown = Egg:AddDropdown("EggDropdown", {
    Title = "Selecting Egg",
    Description = "Choose the egg you want to open",
    Values = GetEggNames(),
    Multi = false,
    Default = 1
})

EggDropdown:OnChanged(function(val)
    SelectedEgg = val
end)

-- Auto Hatch Toggle
Egg:AddToggle("AutoHatch", {
    Title = "Auto Hatch",
    Description = "Automatically opens eggs after walking to them",
    Default = false,
    Callback = function(state)
        AutoHatch = state
        if state then
            EnableNoclip()
            task.spawn(function()
                local remote = ReplicatedStorage.Shared.Framework.Network.Remote.Event
                local teleportPath = EggTeleportMap[SelectedEgg]
                if teleportPath then
                    remote:FireServer("Teleport", teleportPath)
                end

                local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
                local Humanoid = Character:WaitForChild("Humanoid")

                task.wait(1)

                local target = EggPositions[SelectedEgg]
                if target then
                    Humanoid:MoveTo(target)
                    local reached = false
                    Humanoid.MoveToFinished:Connect(function(success)
                        if success then reached = true end
                    end)

                    while not reached and AutoHatch do
                        task.wait(0.5)
                    end

                    while AutoHatch do
                        pcall(function()
                            remote:FireServer("HatchEgg", SelectedEgg, HatchAmount)
                        end)
                        task.wait(0.5)
                    end
                end
            end)
        else
            DisableNoclip()
        end
    end
})

EggRift:AddParagraph({
    Title = "Warning",
    Content = "Note:\n- 'event-1' refers to the Bunny Egg\n- 'event-2' refers to the Pastel Egg\n- 'event-3' refers to the Throwback Egg"
})

-- Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Rifts = workspace:WaitForChild("Rendered"):WaitForChild("Rifts")

-- Variables
local AutoRiftHatch = false
local SelectedRiftEggs = {}
local SelectedLuckMultipliers = {}
local ActiveTweens = {}
local CurrentTargetEgg = nil
local CurrentTargetMultiplier = nil
local NoClipEnabled = false
local NoClipConnection = nil

-- Egg Name Mapping
local EggNameMap = {
    ["spotted-egg"] = "Spotted Egg",
    ["iceshard-egg"] = "Iceshard Egg",
    ["spikey-egg"] = "Spikey Egg",
    ["magma-egg"] = "Magma Egg",
    ["crystal-egg"] = "Crystal Egg",
    ["lunar-egg"] = "Lunar Egg",
    ["void-egg"] = "Void Egg",
    ["hell-egg"] = "Hell Egg",
    ["nightmare-egg"] = "Nightmare Egg",
    ["rainbow-egg"] = "Rainbow Egg",
    ["infinity-egg"] = "Infinity Egg",
    ["event-1"] = "Bunny Egg",
    ["event-2"] = "Pastel Egg",
    ["event-3"] = "Throwback Egg"
}

-- RemoteEvent
local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event")

-- Dropdown Egg Names
local RiftEggNames = {}
for k in pairs(EggNameMap) do
    table.insert(RiftEggNames, k)
end

local RiftEggDropdown = EggRift:AddDropdown("RiftEggDropdown", {
    Title = "Select Rift Eggs",
    Description = "Choose which eggs to hatch",
    Values = RiftEggNames,
    Multi = true,
    Default = {},
})

RiftEggDropdown:OnChanged(function(selectedTable)
    SelectedRiftEggs = {}
    for eggName, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedRiftEggs, eggName)
        end
    end
end)

local LuckMultiplierDropdown = EggRift:AddDropdown("LuckMultiplierDropdown", {
    Title = "Luck Multiplier",
    Description = "Select desired luck multipliers",
    Values = { "x5", "x7", "x10", "x25" },
    Multi = true,
    Default = {},
})

LuckMultiplierDropdown:OnChanged(function(selectedTable)
    SelectedLuckMultipliers = {}
    for multiplier, isSelected in pairs(selectedTable) do
        if isSelected then
            table.insert(SelectedLuckMultipliers, multiplier)
        end
    end
end)

-- NoClip Functionality
local function enableNoClip()
    if NoClipConnection then return end
    
    NoClipConnection = RunService.Stepped:Connect(function()
        if LocalPlayer.Character then
            for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function disableNoClip()
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    
    if LocalPlayer.Character then
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- Utility Functions
local function teleportToEgg(egg)
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    -- Cancel any existing tween
    if ActiveTweens[hrp] then 
        ActiveTweens[hrp]:Cancel() 
    end
    
    -- Enable NoClip during teleport
    enableNoClip()
    
    local targetCFrame = CFrame.new(egg:GetPivot().Position + Vector3.new(0, 3, 0))
    local tween = TweenService:Create(hrp, TweenInfo.new(6, Enum.EasingStyle.Linear), {CFrame = targetCFrame})
    ActiveTweens[hrp] = tween
    
    tween:Play()
    local success = pcall(function() 
        tween.Completed:Wait()
    end)
    
    ActiveTweens[hrp] = nil
    return success
end

local function hatchEgg(eggName)
    local args = {
        [1] = "HatchEgg",
        [2] = EggNameMap[eggName],
        [3] = 10
    }
    pcall(function()
        RemoteEvent:FireServer(unpack(args))
    end)
end

local function cancelAllOperations()
    for hrp, tween in pairs(ActiveTweens) do
        if tween then tween:Cancel() end
    end
    ActiveTweens = {}
    disableNoClip()
end

local function chooseNewTarget()
    if #SelectedRiftEggs > 0 then
        CurrentTargetEgg = SelectedRiftEggs[math.random(1, #SelectedRiftEggs)]
    else
        local eggs = {}
        for k in pairs(EggNameMap) do table.insert(eggs, k) end
        CurrentTargetEgg = eggs[math.random(1, #eggs)]
    end

    if #SelectedLuckMultipliers > 0 then
        CurrentTargetMultiplier = SelectedLuckMultipliers[math.random(1, #SelectedLuckMultipliers)]
    else
        CurrentTargetMultiplier = nil -- accept any multiplier
    end
end

-- Main Toggle
EggRift:AddToggle("AutoRiftHatchToggle", {
    Title = "Auto Hatch (Rift)",
    Description = "Automatically teleport and hatch rift eggs",
    Default = false,
    Callback = function(state)
        AutoRiftHatch = state
        if state then
            chooseNewTarget()
            task.spawn(function()
                while AutoRiftHatch do
                    local found = false
                    for _, egg in pairs(Rifts:GetChildren()) do
                        if not AutoRiftHatch then break end
                        if egg:IsA("Model") and egg:FindFirstChild("Display") and egg.Name == CurrentTargetEgg then
                            local display = egg.Display
                            local gui = display:FindFirstChildWhichIsA("SurfaceGui")
                            local icon = gui and gui:FindFirstChild("Icon")
                            local luck = icon and icon:FindFirstChildWhichIsA("TextLabel")
                            if luck and luck.Text then
                                local validMultiplier = not CurrentTargetMultiplier or luck.Text == CurrentTargetMultiplier
                                if validMultiplier then
                                    found = true
                                    task.wait(2) -- Aguarda antes de teleportar
                                    if teleportToEgg(egg) then
                                        while AutoRiftHatch and egg.Parent do
                                            hatchEgg(egg.Name)
                                            task.wait(0.5) -- Loop contínuo só para hatch
                                        end
                                    end
                                    
                                end
                            end
                        end
                    end

                    if not found then
                        local stillExists = false
                        for _, egg in pairs(Rifts:GetChildren()) do
                            if egg:IsA("Model") and egg.Name == CurrentTargetEgg then
                                local display = egg:FindFirstChild("Display")
                                local gui = display and display:FindFirstChildWhichIsA("SurfaceGui")
                                local icon = gui and gui:FindFirstChild("Icon")
                                local luck = icon and icon:FindFirstChildWhichIsA("TextLabel")
                                local validMultiplier = not CurrentTargetMultiplier or (luck and luck.Text == CurrentTargetMultiplier)
                                
                                if validMultiplier then
                                    stillExists = true
                                    break
                                end
                            end
                        end
                    
                        if not stillExists then
                            chooseNewTarget()
                        end
                    end                    

                    task.wait(0.5)
                end
                disableNoClip() -- Ensure NoClip is disabled when loop ends
            end)
        else
            cancelAllOperations()
        end
    end
})

local AutoGoldenChest = false
local ActiveTween
local NoClipConnection

local function enableNoClip()
    if NoClipConnection then return end
    NoClipConnection = game:GetService("RunService").Stepped:Connect(function()
        if game.Players.LocalPlayer.Character then
            for _, part in ipairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function disableNoClip()
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
end

local function teleportAndFarm()
    while AutoGoldenChest do
        local chest = workspace.Rendered.Rifts:FindFirstChild("golden-chest")
        if chest then
            -- Teleport with TweenService (6 seconds)
            local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                enableNoClip()
                local tween = TweenService:Create(hrp, TweenInfo.new(7), {
                    CFrame = chest:GetPivot() * CFrame.new(0, 0, 0)
                })
                tween:Play()
                tween.Completed:Wait()
                
                -- Farm while chest exists
                while AutoGoldenChest and chest.Parent do
                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("UnlockRiftChest", "golden-chest")
                    task.wait(1)
                end
            end
        end
        task.wait(1)
    end
    disableNoClip()
end

-- Add this to your existing Fluent UI
ChestHunt:AddToggle("AutoGoldenChestToggle", {
    Title = "Auto Golden Chest",
    Description = "Teleport and farm golden chest automatically",
    Default = false,
    Callback = function(state)
        AutoGoldenChest = state
        if state then
            task.spawn(teleportAndFarm)
        end
    end
})

local AutoGiftRift = false
local ActiveTween
local NoClipConnection

-- Função NoClip (reutilizável)
local function manageNoClip(enable)
    if enable then
        if not NoClipConnection then
            NoClipConnection = game:GetService("RunService").Stepped:Connect(function()
                if game.Players.LocalPlayer.Character then
                    for _, part in ipairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if NoClipConnection then
            NoClipConnection:Disconnect()
            NoClipConnection = nil
        end
    end
end

-- Função principal para o Gift Rift
local function teleportAndClaimGift()
    while AutoGiftRift do
        local gift = workspace.Rendered.Rifts:FindFirstChild("gift-rift")
        if gift then
            -- Teleporte com TweenService (6 segundos)
            local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                manageNoClip(true)
                local tween = TweenService:Create(hrp, TweenInfo.new(6), {
                    CFrame = gift:GetPivot() * CFrame.new(0, 0, -3)
                })
                tween:Play()
                tween.Completed:Wait()
                
                -- Fica reivindicando enquanto o gift existir
                while AutoGiftRift and gift.Parent do
                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimRiftGift", "gift-rift")
                    task.wait(0.5) -- Intervalo entre claims
                end
            end
        end
        task.wait(1) -- Verifica a cada 1 segundo se o gift reapareceu
    end
    manageNoClip(false)
end

-- Adicione esta toggle à sua interface Fluent
GiftHunt:AddToggle("AutoGiftRiftToggle", {
    Title = "Auto Gift Rift",
    Description = "Automatically teleports and collects gifts",
    Default = false,
    Callback = function(state)
        AutoGiftRift = state
        if state then
            task.spawn(teleportAndClaimGift)
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgrade", {
    Title = "Auto Upgrade Mastery for Buffs",
    Description = "Runs Upgrade Mastery automatically when activated.",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgrade = state  -- Armazenando o estado para controle de loop

        if state then
            spawn(function()  -- Usando spawn para rodar em uma thread separada
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                while AutoUpgrade do  -- Enquanto a toggle estiver ativada, o loop continua
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Buffs"
                    }

                    -- Envia a requisição ao servidor
                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)  -- Intervalo entre as chamadas (ajustável conforme necessário)
                end
            end)
        else
            -- Se a toggle for desativada, o loop será interrompido
            getgenv().AutoUpgrade = false
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgradePets", {
    Title = "Auto Upgrade Mastery for Pets",
    Description = "Runs Upgrade Mastery for Pets automatically when activated.",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgradePets = state  -- Controla o estado da toggle

        if state then
            spawn(function()  -- Usando spawn para rodar em uma thread separada
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                while AutoUpgradePets do  -- Enquanto a toggle estiver ativada, o loop continua
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Pets"  -- Aqui está o "Pets" que você mencionou
                    }

                    -- Envia a requisição ao servidor
                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)  -- Intervalo entre as chamadas (ajustável conforme necessário)
                end
            end)
        else
            -- Se a toggle for desativada, o loop será interrompido
            getgenv().AutoUpgradePets = false
        end
    end
})

Tabs.Upgrades:AddToggle("AutoUpgradeShops", {
    Title = "Auto Upgrade Mastery for Shops",
    Description = "Runs Upgrade Mastery for Shops automatically when activated.",
    Default = false,
    Callback = function(state)
        getgenv().AutoUpgradeShops = state  -- Controla o estado da toggle

        if state then
            spawn(function()  -- Usando spawn para rodar em uma thread separada
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage:WaitForChild("Shared")
                    :WaitForChild("Framework"):WaitForChild("Network")
                    :WaitForChild("Remote"):WaitForChild("Event")

                while AutoUpgradeShops do  -- Enquanto a toggle estiver ativada, o loop continua
                    local args = {
                        [1] = "UpgradeMastery",
                        [2] = "Shops"  -- Aqui está o "Shops" que você mencionou
                    }

                    -- Envia a requisição ao servidor
                    RemoteEvent:FireServer(unpack(args))
                    task.wait(1)  -- Intervalo entre as chamadas (ajustável conforme necessário)
                end
            end)
        else
            -- Se a toggle for desativada, o loop será interrompido
            getgenv().AutoUpgradeShops = false
        end
    end
})

-- Tabela com poções válidas
local potionList = {}
local dropdownOptions = {}

local potionNames = {"Coins", "Lucky", "Speed", "Mythic"}
local tiers = {1, 2, 3, 4, 5,}
local roman = {"I", "II", "III", "IV", "V"}

-- Cria mapeamento: "Lucky I" → {"Lucky", 1}
for _, potion in ipairs(potionNames) do
    for i, tier in ipairs(tiers) do
        local displayName = potion .. " " .. roman[i]
        potionList[displayName] = {potion, tier}
        table.insert(dropdownOptions, displayName)
    end
end

-- Criando o Dropdown com seleção múltipla
local MultiDropdown = AutoPotionSection:AddDropdown("Poções", {
    Title = "Selecting Potions",
    Description = "Choose the potions to use",
    Values = dropdownOptions,
    Multi = true,
    Default = {},  -- Predefinir poções selecionadas
})

-- A variável SelectedPotions vai ser atualizada quando o usuário fizer alterações
local SelectedPotions = {}

-- Função para capturar as seleções após mudança
MultiDropdown:OnChanged(function(Value)
    -- Atualiza a lista de poções selecionadas
    SelectedPotions = {}
    for potion, _ in pairs(Value) do
        table.insert(SelectedPotions, potion)
    end

    -- Exibe as poções selecionadas no console
    print("Selected potions:", table.concat(SelectedPotions, ", "))
end)

-- RemoteEvent
local RemoteEvent = game:GetService("ReplicatedStorage")
    :WaitForChild("Shared")
    :WaitForChild("Framework")
    :WaitForChild("Network")
    :WaitForChild("Remote")
    :WaitForChild("Event")

-- Toggle Auto Potion
AutoPotionSection:AddToggle("Auto Usar Poções", {
    Title = "Auto Use Potion",
    Description = "Enables automatic use of selected potions",
    Default = false,
    Callback = function(state)
        getgenv().AutoPotion = state

        if state then
            task.spawn(function()
                while getgenv().AutoPotion do
                    -- Verifica se existem poções selecionadas
                    if #SelectedPotions == 0 then
                        Fluent:Notify({
                            Title = "Warn",
                            Content = "No potions selected.",
                            Duration = 4
                        })
                        break
                    end

                    -- Envia as poções selecionadas para o servidor
                    for _, displayName in ipairs(SelectedPotions) do
                        local data = potionList[displayName]
                        if data then
                            local name, tier = unpack(data)
                            print("Sending:", name, tier)
                            pcall(function()
                                RemoteEvent:FireServer("UsePotion", name, tier)
                            end)
                            task.wait(0.5)
                        else
                            warn("Potion invalid:", displayName)
                        end
                    end

                    task.wait(0.5)
                end
            end)
        end
    end
})

-- Tabela com poções válidas
local potionList = {}
local dropdownOptions = {}

local potionNames = {"Coins", "Lucky", "Speed", "Mythic"}
local tiers = {2, 3, 4, 5}
local roman = {"II", "III", "IV", "V"}

-- Cria mapeamento: "Lucky I" → {"Lucky", 1}
for _, potion in ipairs(potionNames) do
    for i, tier in ipairs(tiers) do
        local displayName = potion .. " " .. roman[i]
        potionList[displayName] = {potion, tier}
        table.insert(dropdownOptions, displayName)
    end
end

-- Criando o Dropdown com seleção múltipla
local MultiDropdown = AutoCraftPotionSection:AddDropdown("Poções", {
    Title = "Selecting Potions to Craft",
    Description = "Choose the potions and tiers you want to craft",
    Values = dropdownOptions,
    Multi = true,
    Default = {},
})

-- Lista com as poções selecionadas
local SelectedPotions = {}

-- Atualiza quando o usuário seleciona
MultiDropdown:OnChanged(function(Value)
    SelectedPotions = {}
    for potion, _ in pairs(Value) do
        table.insert(SelectedPotions, potion)
    end
    print("Poções para craft:", table.concat(SelectedPotions, ", "))
end)

-- RemoteEvent
local RemoteEvent = game:GetService("ReplicatedStorage")
    :WaitForChild("Shared")
    :WaitForChild("Framework")
    :WaitForChild("Network")
    :WaitForChild("Remote")
    :WaitForChild("Event")

-- Toggle Auto Craft
AutoCraftPotionSection:AddToggle("Auto Craft Poções", {
    Title = "Auto Craft Potion",
    Description = "Automatically brews selected potions",
    Default = false,
    Callback = function(state)
        getgenv().AutoCraftPotion = state

        if state then
            task.spawn(function()
                while getgenv().AutoCraftPotion do
                    if #SelectedPotions == 0 then
                        Fluent:Notify({
                            Title = "Warn",
                            Content = "No potions selected for crafting.",
                            Duration = 4
                        })
                        break
                    end

                    for _, displayName in ipairs(SelectedPotions) do
                        local data = potionList[displayName]
                        if data then
                            local name, tier = unpack(data)
                            print("Craftando:", name, tier)
                            pcall(function()
                                RemoteEvent:FireServer("CraftPotion", name, tier, false)
                            end)
                            task.wait(0.5)
                        else
                            warn("Potion invalid:", displayName)
                        end
                    end

                    task.wait(1.5)
                end
            end)
        end
    end
})

-- Toggle para teleportar com TweenService
local AutoTween = false

TeleportSection:AddToggle("TweenTeleport", {
    Title = "Unlock All Island",
    Description = "unlock all the islands",
    Default = false,
    Callback = function(state)
        AutoTween = state

        if AutoTween then
            local targetPos = Vector3.new(5.7106, 16206.042, -8.6645)

            local character = game.Players.LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local hrp = character.HumanoidRootPart
                local tweenService = game:GetService("TweenService")

                local tweenInfo = TweenInfo.new(
                    20, -- tempo de transição (segundos)
                    Enum.EasingStyle.Linear,
                    Enum.EasingDirection.Out
                )

                local goal = { CFrame = CFrame.new(targetPos) }

                local tween = tweenService:Create(hrp, tweenInfo, goal)
                tween:Play()

                tween.Completed:Connect(function()
                    AutoTween = false
                end)
            end
        end
    end
})

-- Tabela com locais de teleporte
local teleportLocations = {
    ["Twilight Island"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",
    ["Outer Space"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Spawn (Overworld)"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["The Void"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Floating Island"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
    ["Zen"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn",
    ["Event"] = "Workspace.Event.Portal.Spawn"
    
}

-- Loop para criar os botões de teleporte
for name, path in pairs(teleportLocations) do
    Tabs.Teleport:AddButton({
        Title = name,
        Description = "Teleport to " .. name,
        Callback = function()
            local RemoteEvent = game:GetService("ReplicatedStorage")
                :WaitForChild("Shared")
                :WaitForChild("Framework")
                :WaitForChild("Network")
                :WaitForChild("Remote")
                :WaitForChild("Event")

            RemoteEvent:FireServer("Teleport", path)

            Fluent:Notify({
                Title = "Teleport",
                Content = "Teleport to: " .. name,
                Duration = 3
            })
        end
    })
end

--// Botão de resgatar códigos
CodeSection:AddButton({
    Title = "Redeem Codes",
    Description = "Redeem all available codes",
    Callback = function()
        local codes = { "Release", "Thanks", "Lucky" }
        for _, code in ipairs(codes) do
            local success, result = pcall(function()
                return game:GetService("ReplicatedStorage")
                    .Shared.Framework.Network.Remote.Function
                    :InvokeServer("RedeemCode", code)
            end)
            if success then
                print("Code redeemed:", code)
            else
                warn("Error redeeming code:", code, result)
            end
            task.wait(2)
        end
    end
})

-- Anti AFK
local AntiAfkConfig = {
    connection = nil
}

function AntiAfkConfig:Toggle(state)
    local player = game:GetService("Players").LocalPlayer
    if state then
        -- Ativa o Anti AFK
        self.connection = player.Idled:Connect(function()
            local vu = game:GetService("VirtualUser")
            vu:CaptureController()
            vu:ClickButton2(Vector2.new())
        end)
    else
        -- Desativa o Anti AFK
        if self.connection then
            self.connection:Disconnect()
            self.connection = nil
        end
    end
end

function AntiAfkConfig:Unload()
    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end
end

-- Toggle para ligar/desligar o Anti AFK
local Toggle = Tabs.Misc:AddToggle("MyToggle", {
    Title = "Anti AFK", 
    Default = false,
    Callback = function(state)
        if state then
            -- Ativa o Anti AFK
            AntiAfkConfig:Toggle(true)
        else
            AntiAfkConfig:Toggle(false)
        end
    end
})

--// ======= [SETTINGS] =======

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/BubbleGumInfinity")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
Window:SelectTab(1) -- Seleciona a primeira aba ao abrir
Fluent:Notify({
    Title = "Bubble Gum Simulator INFINITY | DZ HUB",
    Content = "Script loaded successfully!",
    Duration = 5
})
